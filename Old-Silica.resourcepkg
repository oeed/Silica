local files = {interfaces={
  alert = {
    [ "silica/interface" ] = "<WindowContainer>\
\
\9<Label x=6  width=\"100%-6\" y=5 text=\"Self-destruct?\" />\
\9<Button identifier=okayButton right=\"100%-6\" bottom=\"100%-5\" text=Okay />\
\9\
</WindowContainer>",
  },
};resources={
  [ "folder-open" ] = {
    [ "image/paint" ] = "                                \
                                \
    11111111                    \
  114444444411                  \
 14444444444441                 \
 14444444444441                 \
144444444444441111111111111     \
1444444444444444444444444441    \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
1444441111111111111111111111111 \
14441111111111111111111111111111\
1441111111111111111111111111111 \
141111111111111111111111111111  \
11111111111111111111111111111   \
 111111111111111111111111111    \
  1111111111111111111111111     \
                                \
                                \
                                ",
  },
  folder = {
    [ "image/paint" ] = "                                \
                                \
    11111111                    \
  114444444411                  \
 14444444444441                 \
 14444444444441                 \
144444444444441111111111111     \
1444444444444444444444444441    \
14444444444444444444444444441   \
14444444444444444444444444441   \
14444444444444444444444444441   \
1444411111111111111111111111111 \
14441111111111111111111111111111\
14411111111111111111111111111111\
14411111111111111111111111111111\
14411111111111111111111111111111\
1441111111111111111111111111111 \
1441111111111111111111111111111 \
1411111111111111111111111111111 \
141111111111111111111111111111  \
141111111111111111111111111111  \
141111111111111111111111111111  \
141111111111111111111111111111  \
14111111111111111111111111111   \
11111111111111111111111111111   \
11111111111111111111111111111   \
11111111111111111111111111111   \
 111111111111111111111111111    \
  1111111111111111111111111     \
                                \
                                \
                                ",
  },
  [ "folder-small" ] = {
    [ "image/paint" ] = " 111      \
14441     \
144441111 \
1444444441\
1441111111\
1411111111\
1411111111\
1111111111\
1111111111\
 11111111 ",
  },
};fonts={
  Auckland = {
    [ "silica/font" ] = "\0fontType\0bitmap\0\0version\0000.9\0\0name\0Auckland\0\0author\0oeed\0\1\8 \3\0\0\0!\1˙\"\3¿\0¿#\5(˛(˛($\5$T˛TH%\5B\12\16`Ñ&\0048T˛T'\1¿(\2|Ç)\2Ç|*\3†@†+\5\16\16|\16\16,\2\1\2-\5\16\16\16\16\16.\1\2/\5\2\12\16`Ä0\4|ÇÇ|1\2@˛2\5BÜäíb3\5Díííl4\5\24(Hà˛5\5‰íííå6\5|íííL7\5ÄÜò†¿8\5líííl9\5dííí|:\1\";\2\1\"<\4\16(DÇ=\4\20\20\20\20>\4ÇD(\16?\5`Ääê`@\9~ÄÑ™™™úÇ|A\5\14pêp\14B\4˛íílC\5|ÇÇÇDD\4˛ÇÇ|E\4˛ííÇF\4˛êêÄG\5|ÇÇäLH\5˛\16\16\16˛I\5ÇÇ˛ÇÇJ\5\12\2\2\2¸K\5˛\16 PéL\4˛\2\2\2M\7˛@ \16 @˛N\5˛@ \16˛O\5|ÇÇÇ|P\4˛êê`Q\5|ÇÇÑzR\4˛êênS\5díííLT\5ÄÄ˛ÄÄU\5¸\2\2\2¸V\5‡\28\2\28‡W\7¸\2\12\16\12\2¸X\5éP PéY\5¿0\0140¿Z\5Üäí¢¬[\2˛Ç\\\5Ä`\16\12\2]\2Ç˛^\5 @Ä@ _\5\2\2\2\2\2`\2Ä@a\6\4***\28\2b\5˛\"\"\"\28c\5\28\"\"\"\20d\6\28\"\"\"¸\2e\5\28***\18f\4\16~êêg\5\25%%%\30h\4˛  \30i\1æj\4\6\1\1æk\4˛\8\20\"l\1˛m\7\30  \24  \30n\5>   \30o\5\28\"\"\"\28p\5?$$$\24q\5\24$$$?r\5\30   \16s\4\18**$t\4 ¸\"\"u\6<\2\2\2<\2v\0050\12\2\0120w\5<\2\12\2<x\5\"\20\8\20\"y\0059\5\5\5>z\5\"&*2\"{\3\16lÇ|\1˛}\3Çl\16~\6\8\16\16\8\8\16\127\0Ä\6(|™™ÇDÅ\7\16>BÇB>\16Ç\2\2\1É\4\17~ê@Ñ\3\3\0\3Ö\7\0\2\0\2\0\2\0Ü\3 ˛ á\3(˛(à\3@Ä@â\9D®T*D\0\4\
\4ä\5\18™j™$ã\3\16(Då\7|ÇÇ˛ííÇç\7D™|(|™Dé\5\"¶j≤\"è\6@@0HDDê\9\16(DÇ™í™Ç˛ë\2Ä@í\2@Äì\5Ä@\0Ä@î\5@Ä\0@Äï\0068|||8\0ñ\5\16\16\16\16\16ó\8\16\16\16\16\16\16\16\16ò\4@Ä@Äô\9Ä‡Ä\0‡Ä‡Ä‡ö\4\18™j§õ\3D(\16ú\8\28\"\"\"\28**\18ù\7\8\28>\8\8\8xû\3íVöü\5 ê\14ê †\5\0\0\0\0\0°\1æ¢\0048D˛D£\5\18|ííB§\0038(8•\5‘4\0304‘¶\1Óß\4Z™™¥®\5\0Ä\0Ä\0©\6|Çí™Ç|™\4@†¿ ´\6\16(D\16(D¨\4   8≠\3\16\16\16Æ\6|Çö¢Ç|Ø\5ÄÄÄÄÄ∞\3‡†‡±\5\"\"˙\"\"≤\3ò®»≥\3à®P¥\5\0\0@Ä\0µ\5?\2\2<\2∂\5`˛Ä˛∑\1\16∏\2\1\3π\3H¯\8∫\4`êê`ª\6D(\16D(\16º\6»\16 L\4\14Ω\5»\16 V\
æ\6®R\4\11\17\3ø\5\12\18¢\2\4¿\5\2åT\12\2¡\5\2\12Tå\2¬\5\2LîL\2√\5BåTå\2ƒ\5\6ò(ò\6≈\5\6\24®\24\6∆\6\14pê˛íÇ«\5|ÇÉÇD»\4>™j\"…\4>j™\" \4>j™bÀ\4>™*¢Ã\3\18ûRÕ\3\18^íŒ\3RûRœ\3¢>¢–\5\16˛íÇ|—\4^àDû“\4\28¢b\28”\4\28b¢\28‘\4\\¢b\28’\4\\¢bú÷\4\28¢\"ú◊\5D(\16(Dÿ\7\2|äí¢|ÄŸ\5<ÇB\2<⁄\5<\2BÇ<€\5<BÇB<‹\5<Ç\2Ç<›\5 \16Nê ﬁ\4˛DD8ﬂ\5\127êíj\4‡\6\4™j*\28\2·\6\4*j™\28\2‚\6\4j™j\28\2„\6\4j™jú\2‰\6\4™*™\28\2Â\6\4*™*\28\2Ê\9\4***\28***\18Á\5\28#\"\"\20Ë\5\28™j*\18È\5\28*j™\18Í\5\28j™j\18Î\5\28™*™\18Ï\2Ä^Ì\2^ÄÓ\3@û@Ô\3Ä>Ä\5\28\"¢‚\28Ò\5^êPê\14Ú\5\28¢b\"\28Û\5\28\"b¢\28Ù\5\28b¢b\28ı\5\\¢b¢\28ˆ\5\28¢\"¢\28˜\5\16\16T\16\16¯\5\28&*2\28˘\6<ÇB\2<\2˙\6<\2BÇ<\2˚\6<BÇB<\2¸\6<Ç\2Ç<\2˝\0059\5EÖ>˛\4~$$\24ˇ\0059Ö\5Ö>\0\0",
  },
  Napier = {
    [ "silica/font" ] = "\0version\0000.9\0\0name\0Auckland\0\0fontType\0bitmap\0\0author\0oeed\0\1\8\0\0 \3\0\0\0!\1˙\"\3¿\0¿#\5(˛(˛($\5$T˛TH%\5B\12\16`Ñ&\0048T˛T'\1¿(\2|Ç)\2Ç|*\3†@†+\5\16\16|\16\16,\2\1\2-\5\16\16\16\16\16.\1\2/\5\2\12\16`Ä0\4|ÇÇ|1\2@˛2\5BÜäíb3\5Díííl4\5\24(Hà˛5\5‰íííå6\5|íííL7\5ÄÜò†¿8\5líííl9\5dííí|:\1\";\2\1\"<\4\16(DÇ=\4\20\20\20\20>\4ÇD(\16?\5`Ääê`@\9~ÄÑ™™™úÇ|A\5\14pêp\14B\4˛íílC\5|ÇÇÇDD\4˛ÇÇ|E\4˛ííÇF\4˛êêÄG\5|ÇÇäLH\5˛\16\16\16˛I\5ÇÇ˛ÇÇJ\5\12\2\2\2¸K\5˛\16 PéL\4˛\2\2\2M\7˛@ \16 @˛N\5˛@ \16˛O\5|ÇÇÇ|P\4˛êê`Q\5|ÇÇÑzR\4˛êênS\5díííLT\5ÄÄ˛ÄÄU\5¸\2\2\2¸V\5‡\28\2\28‡W\7¸\2\12\16\12\2¸X\5éP PéY\5¿0\0140¿Z\5Üäí¢¬[\2˛Ç\\\5Ä`\16\12\2]\2Ç˛^\5 @Ä@ _\5\2\2\2\2\2`\2Ä@a\6\4***\28\2b\5˛\"\"\"\28c\5\28\"\"\"\20d\6\28\"\"\"¸\2e\5\28***\18f\4\16~êêg\5\25%%%\30h\4˛  \30i\1æj\4\6\1\1æk\4˛\8\20\"l\1˛m\7\30  \24  \30n\5>   \30o\5\28\"\"\"\28p\5?$$$\24q\5\24$$$?r\5\30   \16s\4\18**$t\4 ¸\"\"u\6<\2\2\2<\2v\0050\12\2\0120w\5<\2\12\2<x\5\"\20\8\20\"y\0059\5\5\5>z\5\"&*2\"{\3\16lÇ|\1˛}\3Çl\16~\6\8\16\16\8\8\16\127\0Ä\6(|™™ÇDÅ\7\16>BÇB>\16Ç\2\2\1É\4\17~ê@Ñ\3\3\0\3Ö\7\0\2\0\2\0\2\0Ü\3 ˛ á\3(˛(à\3@Ä@â\9D®T*D\0\4\
\4ä\5\18™j™$ã\3\16(Då\7|ÇÇ˛ííÇç\7D™|(|™Dé\5\"¶j≤\"è\6@@0HDDê\9\16(DÇ™í™Ç˛ë\2Ä@í\2@Äì\5Ä@\0Ä@î\5@Ä\0@Äï\0068|||8\0ñ\5\16\16\16\16\16ó\8\16\16\16\16\16\16\16\16ò\4@Ä@Äô\9Ä‡Ä\0‡Ä‡Ä‡ö\4\18™j§õ\3D(\16ú\8\28\"\"\"\28**\18ù\7\8\28>\8\8\8xû\3íVöü\5 ê\14ê †\5\0\0\0\0\0°\1æ¢\0048D˛D£\5\18|ííB§\0038(8•\5‘4\0304‘¶\1Óß\4Z™™¥®\5\0Ä\0Ä\0©\6|Çí™Ç|™\4@†¿ ´\6\16(D\16(D¨\4   8≠\3\16\16\16Æ\6|Çö¢Ç|Ø\5ÄÄÄÄÄ∞\3‡†‡±\5\"\"˙\"\"≤\3ò®»≥\3à®P¥\5\0\0@Ä\0µ\5?\2\2<\2∂\5`˛Ä˛∑\1\16∏\2\1\3π\3H¯\8∫\4`êê`ª\6D(\16D(\16º\6»\16 L\4\14Ω\5»\16 V\
æ\6®R\4\11\17\3ø\5\12\18¢\2\4¿\5\2åT\12\2¡\5\2\12Tå\2¬\5\2LîL\2√\5BåTå\2ƒ\5\6ò(ò\6≈\5\6\24®\24\6∆\6\14pê˛íÇ«\5|ÇÉÇD»\4>™j\"…\4>j™\" \4>j™bÀ\4>™*¢Ã\3\18ûRÕ\3\18^íŒ\3RûRœ\3¢>¢–\5\16˛íÇ|—\4^àDû“\4\28¢b\28”\4\28b¢\28‘\4\\¢b\28’\4\\¢bú÷\4\28¢\"ú◊\5D(\16(Dÿ\7\2|äí¢|ÄŸ\5<ÇB\2<⁄\5<\2BÇ<€\5<BÇB<‹\5<Ç\2Ç<›\5 \16Nê ﬁ\4˛DD8ﬂ\5\127êíj\4‡\6\4™j*\28\2·\6\4*j™\28\2‚\6\4j™j\28\2„\6\4j™jú\2‰\6\4™*™\28\2Â\6\4*™*\28\2Ê\9\4***\28***\18Á\5\28#\"\"\20Ë\5\28™j*\18È\5\28*j™\18Í\5\28j™j\18Î\5\28™*™\18Ï\2Ä^Ì\2^ÄÓ\3@û@Ô\3Ä>Ä\5\28\"¢‚\28Ò\5^êPê\14Ú\5\28¢b\"\28Û\5\28\"b¢\28Ù\5\28b¢b\28ı\5\\¢b¢\28ˆ\5\28¢\"¢\28˜\5\16\16T\16\16¯\5\28&*2\28˘\6<ÇB\2<\2˙\6<\2BÇ<\2˚\6<BÇB<\2¸\6<Ç\2Ç<\2˝\0059\5EÖ>˛\4~$$\24ˇ\0059Ö\5Ö>",
  },
};themes={
  cyan = {
    [ "silica/theme" ] = "<Theme extends=default>\
\9<Window>\
\9\9<topCornerRadius type=\"number\" default=\"4\" />\
\9\9<bottomCornerRadius type=\"number\" default=\"2\" />\
\9\9<barColour type=\"Graphics.colours\" default=\"CYAN\" disabled=\"LIGHT_GREY\" />\
\9\9<separatorColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" disabled=\"WHITE\" />\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"GREY\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" />\
\9</Window>\
\9\
\9<CloseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"CYAN\" pressed=\"RED\" disabled=\"TRANSPARENT\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"WHITE\" disabled=\"GREY\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</CloseWindowButton>\
\9\
\9<MinimiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"CYAN\" pressed=\"ORANGE\" disabled=\"TRANSPARENT\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"WHITE\" disabled=\"GREY\"/>\
\9\9<cornerRadius type=\"number\" default=\"0\" />\
\9</MinimiseWindowButton>\
\9\
\9<MaximiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"CYAN\" pressed=\"LIME\" disabled=\"TRANSPARENT\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"WHITE\" disabled=\"GREY\"/>\
\9\9<cornerRadius type=\"number\" default=\"0\" />\
\9</MaximiseWindowButton>\
</Theme>",
  },
  default = {
    [ "silica/theme" ] = "<Theme>\
\9\
\9<View>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" />\
\9</View>\
\
\9<Button>\
\9\9<cornerRadius type=\"number\" default=\"8\" />\
\9\9<leftMargin type=\"number\" default=\"7\" />\
\9\9<rightMargin type=\"number\" default=\"7\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"BLUE\" focused=\"BLUE\" disabled=\"WHITE\"/>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" pressed=\"WHITE\" focused=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" focused=\"TRANSPARENT\" disabled=\"LIGHT_GREY\" pressed=\"TRANSPARENT\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" disabled=\"TRANSPARENT\"/>\
\9</Button>\
\
\9<SymbolButton>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"WHITE\" focused=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9</SymbolButton>\
\
\9<SegmentButton>\
\9\9<centerMargin type=\"number\" default=\"4\" />\
\9\9<separatorBackgroundColour type=\"Graphics.colours\" default=\"WHITE\"/>\
\9\9<separatorFillColour type=\"Graphics.colours\" default=\"LIGHT_GREY\"/>\
\9\9<separatorOutlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\"/>\
\9\9<separatorIsDashed type=\"boolean\" default=\"true\"/>\
\9</SegmentButton>\
\
\9<SymbolSegmentButton>\
\9\9<centerMargin type=\"number\" default=\"5\" />\
\9\9<symbolColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"WHITE\" focused=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9</SymbolSegmentButton>\
\
\9<Menu>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" />\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" />\
\9</Menu>\
\9\
\9<MenuButton>\
\9\9<arrowColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\"/>\
\9\9<rightMargin type=\"number\" default=\"15\" />\
\9</MenuButton>\
\9\
\9<MenuItem>\
\9\9<fillColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"BLUE\" disabled=\"TRANSPARENT\"/>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" pressed=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9\9<shortcutColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\"/>\
\9</MenuItem>\
\
\9<MenuBar>\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" disabled=\"LIGHT_GREY\" />\
\9\9<separatorColour type=\"Graphics.colours\" default=\"GREY\" disabled=\"LIGHT_GREY\" />\
\9</MenuBar>\
\9\
\9<MenuBarItem>\
\9\9<fillColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"BLUE\" disabled=\"TRANSPARENT\"/>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" pressed=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9</MenuBarItem>\
\
\9<Radio>\
\9\9<cornerRadius type=\"number\" default=\"4\" pressed=\"4\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"LIGHT_BLUE\" checked=\"BLUE\" disabledChecked=\"GREY\" disabled=\"WHITE\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" pressed=\"BLUE\" checked=\"TRANSPARENT\" disabledChecked=\"TRANSPARENT\" disabled=\"LIGHT_GREY\"/>\
\9</Radio>\
\
\9<Checkbox>\
\9\9<cornerRadius type=\"number\" default=\"2\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"LIGHT_BLUE\" checked=\"BLUE\" disabledChecked=\"GREY\" disabled=\"WHITE\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" pressed=\"BLUE\" checked=\"TRANSPARENT\" disabledChecked=\"TRANSPARENT\" disabled=\"LIGHT_GREY\"/>\
\9\9<checkColour type=\"Graphics.colours\" default=\"TRANSPARENT\" checked=\"WHITE\" disabledChecked=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9</Checkbox>\
\
\9<ProgressBar>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" disabled=\"WHITE\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" disabled=\"LIGHT_GREY\"/>\
\9\9<barColour type=\"Graphics.colours\" default=\"BLUE\" disabled=\"GREY\"/>\
\9\9<stripeColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\"/>\
\9\9<barOutlineColour type=\"Graphics.colours\" default=\"BLUE\" disabled=\"GREY\"/>\
\9</ProgressBar>\
\
\9<Window>\
\9\9<topCornerRadius type=\"number\" default=\"4\" />\
\9\9<bottomCornerRadius type=\"number\" default=\"2\" />\
\9\9<barColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" disabled=\"LIGHT_GREY\" />\
\9\9<separatorColour type=\"Graphics.colours\" default=\"GREY\" disabled=\"LIGHT_GREY\" />\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"GREY\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" />\
\9</Window>\
\9\
\9<CloseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"RED\" pressed=\"RED\" disabled=\"TRANSPARENT\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"GREY\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</CloseWindowButton>\
\9\
\9<MinimiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"ORANGE\" pressed=\"ORANGE\" disabled=\"TRANSPARENT\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"GREY\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</MinimiseWindowButton>\
\9\
\9<MaximiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"LIME\" pressed=\"LIME\" disabled=\"TRANSPARENT\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"GREY\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</MaximiseWindowButton>\
\
\9<Scrollbar>\
\9\9<fillColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" />\
\9\9<scrollerColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"BLUE\" disabled=\"WHITE\" />\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"TRANSPARENT\" />\
\9\9<grabberColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"WHITE\" disabled=\"LIGHT_GREY\" />\
\9\9<cornerRadius type=\"number\" default=\"2\" />\
\9</Scrollbar>\
\
\9<ScrollView>\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" />\
\9</ScrollView>\
\
\9<Label>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"LIGHT_GREY\"/>\
\9\9<fillColour type=\"Graphics.colours\" default=\"TRANSPARENT\" disabled=\"TRANSPARENT\"/>\
\9</Label>\
\
\9<TextBox>\
\9\9<cornerRadius type=\"number\" default=\"8\" />\
\9\9<leftMargin type=\"number\" default=\"7\" />\
\9\9<rightMargin type=\"number\" default=\"7\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" disabled=\"WHITE\"/>\
\9\9<selectionColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" />\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"LIGHT_GREY\"/>\
\9\9<cursorColour type=\"Graphics.colours\" default=\"BLACK\" />\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" focused=\"BLUE\" pressed=\"BLUE\" />\
\9\9<placeholderColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" />\
\9</TextBox>\
\
\9<SearchBox>\
\9\9<leftMargin type=\"number\" default=\"18\" />\
\9\9<searchSymbolColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" />\
\9</SearchBox>\
\
\9<ApplicationContainer>\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\"/>\
\9</ApplicationContainer>\
\
\9<SeparatorView>\
\9\9<fillColour type=\"Graphics.colours\" default=\"LIGHT_GREY\"/>\
        <isDashed type=\"boolean\" default=\"true\"/>\
\9</SeparatorView>\
\
\9<ToolbarContainer>\
\9\9<fillColour type=\"Graphics.colours\" default=\"BLUE\" />\
\9\9<separatorFillColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" />\
\9\9<separatorIsDashed type=\"boolean\" default=\"false\" />\
\9</ToolbarContainer>\
\
\9<ToolbarButton>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" focused=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\" pressed=\"LIGHT_BLUE\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"TRANSPARENT\" />\
\9</ToolbarButton>\
\
\9<ToolbarSymbolButton>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" focused=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\" pressed=\"LIGHT_BLUE\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"TRANSPARENT\" />\
\9</ToolbarSymbolButton>\
\
\9<ToolbarSymbolSegmentButton>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" focused=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\" pressed=\"LIGHT_BLUE\"/>\
\9\9<separatorOutlineColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"TRANSPARENT\" />\
\9</ToolbarSymbolSegmentButton>\
\
\9<ToolbarSegmentButton>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" focused=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\" pressed=\"LIGHT_BLUE\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"TRANSPARENT\" />\
\9</ToolbarSegmentButton>\
\
\9<FlowContainer>\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" />\
\9</FlowContainer>\
\
\9<ListItem>\
\9\9<fillColour type=\"Graphics.colours\" default=\"TRANSPARENT\" selected=\"BLUE\" disabled=\"TRANSPARENT\"/>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" selected=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
        <cornerRadius type=\"number\" default=\"6\" />\
\9</ListItem>\
\
</Theme>",
  },
};loadfirst={
  [ "silica/config" ] = "class\
interface\
Graphics\
Application\
InterfaceOutlet\
Animation\
View\
DragDropManager",
};classes={
  IToolbarDynamicItem = {
    [ "text/lua" ] = "\
interface \"IToolbarDynamicItem\" {}",
  },
  BitmapFont = {
    [ "text/lua" ] = "\
local floor, ceil = math.floor, math.ceil\
\
local function readstring( handle )\
\9local v = handle.read()\
\9local s = \"\"\
\9while v ~= 0 do\
\9\9s = s .. string.char( v )\
\9\9v = handle.read()\
\9end\
\9return s\
end\
local function writestring( handle, text )\
\9for i = 1, #text do\
\9\9handle.write( text:byte( i ) )\
\9end\
end\
\
local function bhasbit( n, i )\
\9if not n then log(debug.traceback()) end\
\9return floor( n / 2 ^ ( 8 - i ) ) % 2 == 1\
end\
\
class \"BitmapFont\" extends \"Font\" {\
\9\
}\
\
function BitmapFont.static:decodeCharacter( bytes, width, height )\
\9local character = {}\
\9local s = ceil( height / 8 )\
\9local function hasbit( x, y )\
\9\9local byte = ( x - 1 ) * s + ceil( y / 8 )\
\9\9local index = y % 8\
\9\9if index == 0 then index = 8 end\
\9\9local s = \"\"\
\9\9for i = 1, 8 do\
\9\9\9-- log(bytes[byte])\
\9\9\9s = s .. ( bhasbit( bytes[byte], i ) and 1 or 0 )\
\9\9end\
\9\9return bhasbit( bytes[byte], index )\
\9end\
\9character.width = width\
\9for y = 1, height do\
\9\9character[y] = {}\
\9\9for x = 1, width do\
\9\9\9character[y][x] = hasbit( x, y )\
\9\9end\
\9end\
\9return character\
end\
\
function BitmapFont.static:encodeCharacter( character, width, height )\
\9local bytes = {}\
\9for x = 1, width do\
\9\9local byte = {}\
\9\9local function close()\
\9\9\9if #byte == 0 then return end\
\9\9\9local n = 0\
\9\9\9for i = 1, #byte do\
\9\9\9\9n = n * 2 + byte[i]\
\9\9\9end\
\9\9\9byte = {}\
\9\9\9bytes[#bytes + 1] = n\
\9\9end\
\9\9local function append( b )\
\9\9\9byte[#byte + 1] = b and 1 or 0\
\9\9\9if #byte == 8 then\
\9\9\9\9close()\
\9\9\9end\
\9\9end\
\9\9for y = 1, ceil( height / 8 ) * 8 do\
\9\9\9if character[y] then\
\9\9\9\9append( character[y][x] )\
\9\9\9else\
\9\9\9\9append()\
\9\9\9end\
\9\9end\
\9\9close()\
\9end\
\9return bytes\
end\
\
function BitmapFont.static:encodeSet( characters, height )\
\9local bytes = {}\
\9for k, v in pairs( characters ) do\
\9\9local width = v.width or ( v[1] and #v[1] or 0 )\
\9\9bytes[#bytes + 1] = k\
\9\9bytes[#bytes + 1] = width\
\9\9for _, byte in ipairs( BitmapFont.encodeCharacter( v, width, height ) ) do\
\9\9\9bytes[#bytes + 1] = byte\
\9\9end\
\9end\
\9return bytes\
end\
\
function BitmapFont.static:decodeSet( bytes, height )\
\9local hf = ceil( height / 8 )\
\9local characters = {}\
\9while bytes[1] do\
\9\9local character = bytes[1]\
\9\9local width = bytes[2]\
\9\9table.remove( bytes, 1 )\
\9\9table.remove( bytes, 1 )\
\9\9local bitmapcount = hf * width\
\9\9characters[character] = BitmapFont.static:decodeCharacter( bytes, width, height )\
\9\9for i = 1, bitmapcount do\
\9\9\9table.remove( bytes, 1 )\
\9\9end\
\9end\
\9return characters\
end\
\
function BitmapFont.static:encodeFile( file, characters, height, metadata )\
\9local h = fs.open( file, \"wb\" )\
\9if h then\
\9\9for k, v in pairs( metadata or {} ) do\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( k ) )\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( v ) )\
\9\9\9h.write( 0 )\
\9\9end\
\9\9h.write( 1 )\
\9\9h.write( height )\
\9\9for _, byte in ipairs( BitmapFont.static:encodeSet( characters, height ) ) do\
\9\9\9h.write( byte )\
\9\9end\
\9\9h.close()\
\9\9return true\
\9end\
end\
\
function BitmapFont.static:decodeFile( file )\
\9local h = fs.open( file, \"rb\" )\
\9if h then\
\9\9local metadata = {}\
\9\9local v = h.read()\
\9\9while v == 0 do\
\9\9\9local key, value = readstring( h ), readstring( h )\
\9\9\9metadata[key] = value\
\9\9\9v = h.read()\
\9\9end\
\9\9local height = h.read()\
\9\9local bytes = {}\
\9\9for byte in h.read do\
\9\9\9bytes[#bytes + 1] = byte\
\9\9end\
\9\9local characters = BitmapFont.static:decodeSet( bytes, height )\
\9\9return characters, height, metadata\
\9end\
end\
\
function BitmapFont.static:convertFile( input, output, charsetStart, height, metadata )\
\9local newchar = colours.red\
\9local filled = colours.white\
\9local image = paintutils.loadImage( input )\
\9local n = charsetStart or 0\
\
\9local chars = { [n] = {} }\
\9for x = 1, #image[1] do\
\9\9if image[1][x] == newchar then\
\9\9\9n = n + 1\
\9\9\9chars[n] = {}\
\9\9else\
\9\9\9for y = 1, #image do\
\9\9\9\9chars[n][y] = chars[n][y] or {}\
\9\9\9\9chars[n][y][#chars[n][y] + 1] = image[y][x] == filled\
\9\9\9end\
\9\9end\
\9end\
\
\9return BitmapFont.encodeFile( output, chars, height, metadata )\
end",
  },
  Symbol = {
    [ "text/lua" ] = "\
class \"Symbol\" {\
    \
    symbolName = false;\
    width = 7;\
    height = 7;\
    serialisedPaths = {};\
    \
}\
\
local symbolClasses = {}\
\
function Symbol.static:register( symbolName, subclass )\
    if not symbolName then\
        error( \"Symbol subclass '\" .. tostring( subclass ) .. \"' does not have a symbolName.\", 0 )\
    end\
\
    if symbolClasses[symbolName] then\
        error( \"Symbol subclass '\" .. tostring( subclass ) .. \"' attempted to overwite symbol with name '\" .. symbolName .. \"' ('\" .. tostring( symbolClasses[symbolName] ) .. \"')\", 0 )\
    end\
\
    symbolClasses[symbolName] = subclass\
end\
\
function Symbol.static:constructed( _class )\
    if _class ~= Symbol then\
        Symbol.register( _class.symbolName, _class )\
    end\
end\
\
function Symbol.static:fromName( name )\
    local symbol = symbolClasses[name]\
    if not symbol then\
        error( \"Unable to find symbol with name '\" .. name .. \"'\", 3 )\
    end\
    return symbol\
end",
  },
  TextBox = {
    [ "text/lua" ] = "\
--[[\
\9TODO\
\9\9Shift clicking\
\9\9Shift-left/right\
\9\9Ctrl-left/right\
\9\9Home\
\9\9End\
\9\9Delete\
\9\9Ctrl-shift-left/right\
\9\9Ctrl-a\
]]\
\
local CURSOR_ANIMATION_SPEED = 0.45\
\
local floor = math.floor\
\
class \"TextBox\" extends \"View\" {\
\
\9height = 15; -- the default height\
\9width = 120;\
\9text = \"\";\
\9placeholder = \"\";\
\
\9font = false;\
\
\9backgroundObject = false;\
\9textObject = false;\
\9placeholderObject = false;\
\9cursorObject = false;\
\9selectionObject = false;\
\9cursorFlashCounter = 0;\
\
\9cursorX = Number;\
\9selectionX = Number;\
\9selectionWidth = Number;\
\
\9margin = Number;\
\9leftMargin = 0;\
\9rightMargin = 0;\
\9isFocused = false;\
\9isPressed = false;\
\9isMasked = false; -- whether bullets are shown instead of characters (for passwords)\
\
\9scroll = 0;\
\9cursorPosition = 1;\
\9maximumLength = false;\
\9selectionPosition = false;\
\
}\
\
--[[\
\9@constructor\
\9@desc Creates a text box view and connects the event handlers\
]]\
function TextBox:initialise( ... )\
\9self:super( ... )\
\9self:event( KeyUpEvent, self.onKeyUp )\
\9self:event( KeyDownEvent, self.onKeyDown )\
\9self:event( CharacterEvent, self.onCharacter )\
\9self:event( MouseDownEvent, self.onMouseDown )\
\9self:event( MouseUpEvent, self.onMouseUp )\
\9self:event( MouseDragEvent, self.onMouseDrag )\
    self:event( KeyboardShortcutEvent, self.onKeyboardShortcut )\
\9self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
end\
\
--[[\
\9@instance\
\9@desc Sets up the canvas and it's graphics objects\
]]\
function TextBox:initialiseCanvas()\
\9self:super()\
\9local width, height, theme = self.width, self.height, self.theme\
\9local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, width, height ) )\
\9local selectionObject = self.canvas:insert( Rectangle( 0, 4, 1, self.height - 6 ) )\
\9local placeholderObject = self.canvas:insert( Text( self.leftMargin, 5, self.width, 10, self.placeholder ) )\
\9local textObject = self.canvas:insert( Text( self.leftMargin, 5, self.width, 10, self.text ) )\
\9local cursorObject = self.canvas:insert( Cursor( 0, 4, self.height - 6 ) )\
\9cursorObject.isVisible = false\
\9selectionObject.isVisible = false\
\
\9theme:connect( backgroundObject, \"fillColour\" )\
\9theme:connect( backgroundObject, \"outlineColour\" )\
\9theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
\9theme:connect( textObject, \"textColour\" )\
\9theme:connect( placeholderObject, \"textColour\", \"placeholderColour\" )\
\9theme:connect( cursorObject, \"fillColour\", \"cursorColour\" )\
\9theme:connect( selectionObject, \"fillColour\", \"selectionColour\" )\
\9theme:connect( self, \"leftMargin\" )\
\9theme:connect( self, \"rightMargin\" )\
\
\9self.backgroundObject = backgroundObject\
\9self.textObject = textObject\
\9self.placeholderObject = placeholderObject\
\9self.cursorObject = cursorObject\
\9self.selectionObject = selectionObject\
\
\9if not self.font then\
\9\9self.font = Font.systemFont\
\9end\
end\
\
function TextBox:update( deltaTime )\
\9self:super( deltaTime )\
\
\9if self.isFocused then\
\9\9local cursorFlashCounter = self.cursorFlashCounter\
\9\9local visible = cursorFlashCounter % 2 < 1\
\9\9local rem = cursorFlashCounter % 1\
\9\9local colour\
\9\9if rem > .85 then\
\9\9\9if visible then\
\9\9\9\9colour = ( rem > .95 and colours.lightGrey ) or colours.grey\
\9\9\9else\
\9\9\9\9colour = ( rem > .95 and colours.grey ) or colours.lightGrey\
\9\9\9\9visible = true\
\9\9\9end\
\9\9else\
\9\9\9colour = colours.black\
\9\9end\
\9\9self.cursorObject.fillColour = colour\
\9\9self.cursorObject.isVisible = visible\
\9\9self.cursorFlashCounter = cursorFlashCounter + deltaTime\
\9end\
end\
\
function TextBox:updateHeight( height )\
\9self.backgroundObject.height = height\
end\
\
function TextBox:updateWidth( width )\
\9self.backgroundObject.width = width\
\9local textObject = self.textObject\
\9textObject.x = self.leftMargin + 1 - self.scroll\
\9textObject.width = width - self.leftMargin - self.rightMargin\
\9local placeholderObject = self.placeholderObject\
\9placeholderObject.x = self.leftMargin + 1\
\9placeholderObject.width = width - self.leftMargin - self.rightMargin\
end\
\
function TextBox.leftMargin:set( leftMargin )\
\9self.leftMargin = leftMargin\
\9local textObject = self.textObject\
\9if textObject then\
\9\9textObject.x = leftMargin + 1 - self.scroll\
\9\9self.placeholderObject.x = leftMargin + 2\
\9end\
end\
\
function TextBox:updateSelection()\
\9local selectionObject = self.selectionObject\
\9local leftMargin = self.leftMargin\
\9local cursorPosition = self.cursorPosition\
\9local selectionPosition = self.selectionPosition\
\
\9local isVisible = selectionObject.isVisible\
\9if not selectionPosition then--or cursorPosition == selectionPosition then\
\9\9if isVisible then selectionObject.isVisible = false end\
\9else\
\9\9local cursorX = leftMargin + math.max( self:charToViewCoords( cursorPosition ) - 1, 1 ) - self.scroll\
\9\9local selectionX = leftMargin + math.max( self:charToViewCoords( selectionPosition ) - 1, 1 ) - self.scroll\
\
\9\9if not isVisible then selectionObject.isVisible = true end\
\
\9\9local x, width, f\
\9\9if cursorX == selectionX then\
\9\9\9-- if isVisible then selectionObject.isVisible = false end\
\9\9\9local _x, _width = selectionObject.x, selectionObject.width\
\9\9\9x = math.floor( _x + _width / 2 )\
\9\9\9width = 0\
\9\9\9f = function() selectionObject.isVisible = false end\
\9\9else\
\9\9\9x = math.min( cursorX, selectionX )\
\9\9\9width = math.max( cursorX, selectionX ) - x\
\9\9end\
\
\9\9if not isVisible then\
\9\9\9selectionObject.x = x\
\9\9\9selectionObject.width = width\
\9\9else\
\9\9\9self:animate( \"selectionX\", x, CURSOR_ANIMATION_SPEED, f, Animation.easings.OUT_QUART )\
\9\9\9self:animate( \"selectionWidth\", width, CURSOR_ANIMATION_SPEED, nil, Animation.easings.OUT_QUART )\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Converts the coordinates relative to the text box to the character position\
\9@param [number] x -- the x coordinate\
\9@return [number] characterPosition -- the charcter position\
]]\
function TextBox:viewToCharCoords( x )\
\9if x <= 0 then\
\9\9return 1\
\9end\
\9local font = self.font\
\9local width = font.getWidth\
\9local text = self.isMasked and string.rep( string.char( 149 ), #self.text ) or self.text\
\9for i = 1, #text do\
\9\9local cw = width( font, text:sub( i, i ) )\
\9\9if x <= cw / 2 then\
\9\9\9return i\
\9\9end\
\9\9x = x - cw\
\9end\
\9return #text + 1\
end\
\
function TextBox:charToViewCoords( char )\
\9local text = self.isMasked and string.rep( string.char( 149 ), #self.text ) or self.text\
\9return self.font:getWidth( text:sub( 1, char - 1 ) ) + 1\
end\
\
--[[\
\9@instance\
\9@desc Callback to check whether a character entered by the user is valid, intended to be overridden by sub-classes\
\9@param [string] character\
\9@return [boolean] isValid\
]]\
function TextBox:isValidChar( character )\
\9return true\
end\
\
function TextBox.scroll:set( scroll )\
\9self.scroll = scroll\
\9self.textObject.x = self.leftMargin + 1 - self.scroll\
\9self:updateSelection()\
\9self:updateCursorPosition()\
end\
\
function TextBox.cursorPosition:set( cursorPosition )\
\9cursorPosition = math.max( math.min( cursorPosition, #self.text + 1 ), 1 )\
\9self.cursorPosition = cursorPosition\
\9self.cursorFlashCounter = 0\
\9if self:charToViewCoords( cursorPosition ) - self.scroll < 1 then\
\9\9self.scroll = self:charToViewCoords( cursorPosition ) - 1\
\9elseif self:charToViewCoords( cursorPosition ) - self.scroll > ( self.width - self.leftMargin - self.rightMargin ) then\
\9\9self.scroll = self:charToViewCoords( cursorPosition ) - ( self.width - self.leftMargin - self.rightMargin )\
\9end\
\
\9self:updateCursorPosition()\
end\
\
function TextBox.cursorX:set( cursorX )\
\9self.cursorObject.x = cursorX\
end\
\
function TextBox.cursorX:get()\
\9return self.cursorObject.x\
end\
\
function TextBox.selectionX:set( selectionX )\
\9self.selectionObject.x = selectionX\
end\
\
function TextBox.selectionX:get()\
\9return self.selectionObject.x\
end\
\
function TextBox.selectionWidth:set( selectionWidth )\
\9self.selectionObject.width = selectionWidth\
end\
\
function TextBox.selectionWidth:get()\
\9return self.selectionObject.width\
end\
\
function TextBox:updateCursorPosition()\
\9local value = self.leftMargin + math.max( self:charToViewCoords( self.selectionPosition or self.cursorPosition ) - 1, 1 ) - self.scroll\
\9self:animate( \"cursorX\", value, CURSOR_ANIMATION_SPEED, nil, Animation.easings.OUT_QUART )\
end\
\
function TextBox.selectionPosition:set( selectionPosition )\
\9self.selectionPosition = selectionPosition\
\9self.cursorFlashCounter = 0\
\9self:updateSelection()\
\9self:updateCursorPosition()\
end\
\
--[[\
\9@instance\
\9@desc ima leave this... until floobits,.. just yeah\
\9es@param [string] character\
\9@return [boolean] isValid\
]]\
local sub = string.sub -- move to top\
local concat = table.concat\
function TextBox:write( text )\
\9local t = {}\
\9local valid = self.isValidChar\
\9for i = 1, #text do\
\9\9local char = sub( text, 1, 1 )\
\9\9if valid( self, char ) then\
\9\9\9t[#t + 1] = char\
\9\9end\
\9end\
\9local text = self.text\
\9local s = concat( t )\
\9local cp, sp = self.cursorPosition, self.selectionPosition\
\9if sp then\
\9\9sp = sp - 1\
\9\9self.text = text:sub( 1, math.min( cp, sp ) - 1 ) .. s .. text:sub( math.max( cp, sp ) + 1 )\
\9\9self.cursorPosition =  math.min( cp, sp ) + #s\
\9\9self.selectionPosition = false\
\9else\
\9\9self.text = text:sub( 1, cp - 1 ) .. s .. text:sub( cp )\
\9\9self.cursorPosition =  cp + #s\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns the character at the given character position\
\9@param [number] characterPosition -- the character position\
\9@return [string] character -- the character\
]]\
function TextBox:charCoordsToChar( characterPosition )\
\9return character\
end\
\
--[[\
\9@instance\
\9@desc What does this actually do?\
\9@param [type] arg1 -- description\
\9@param [type] arg2 -- description\
\9@param [type] arg3 -- description\
\9@return [type] returnedValue -- description\
]]\
function TextBox:charToCharCoords( arg1, arg2, arg3 )\
\9return returnedValue\
end\
\
--[[\
\9@instance\
\9@desc Converts the character position to screen coordinates\
\9@param [number] characterPosition -- the position of the character\
\9@return [number] x -- the x coordinate realtive to the text box\
\9@return [number] y -- the y coordinate realtive to the text box\
]]\
function TextBox:charCoordsToViewCoordinates( characterPosition )\
\9return x, y\
end\
\
--[[\
\9@instance\
\9@desc Set the text of the text box.\
\9@param [string] text -- the text of the text box\
]]\
function TextBox.text:set( text )\
\9self.text = text\
\9self.textObject.text = self.isMasked and string.rep( string.char( 149 ), #text ) or text\
\9self.placeholderObject.isVisible = #text == 0\
end\
\
function TextBox.placeholder:set( placeholder )\
\9self.placeholder = placeholder\
\9local placeholderObject = self.placeholderObject\
\9if placeholderObject then\
\9\9placeholderObject.text = placeholder or ''\
\9end\
end\
\
function TextBox.isMasked:set( isMasked )\
\9self.isMasked = isMasked\
\9self.text = self.text\
end\
\
--[[\
\9@instance\
\9@desc Set the margin on either side of the text\
\9@param [number] margin -- the space around the text\
]]\
function TextBox.margin:set( margin )\
\9self.leftMargin = margin\
\9self.rightMargin = margin\
end\
\
function TextBox.font:set( font )\
\9self.font = font\
\9local textObject = self.textObject\
\9if textObject then\
\9\9textObject.font = font\
\9\9self.placeholderObject.font = font\
\9\9self.cursorObject.height = font.height + 1\
\9\9self.selectionObject.height = font.height + 1\
\9end\
end\
\
function TextBox:updateThemeStyle()\
\9self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or ( self.isFocused and \"focused\" or \"default\" ) ) or \"disabled\"\
end\
\
function TextBox.isPressed:set( isPressed )\
\9self.isPressed = isPressed\
\9self:updateThemeStyle()\
end\
\
function TextBox.isEnabled:set( isEnabled )\
\9self.isEnabled = isEnabled\
\9if not isEnabled then\
\9\9self:unfocus( TextBox )\
\9end\
\9self:updateThemeStyle()\
end\
\
function TextBox.isFocused:set( isFocused )\
\9self.isFocused = isFocused\
\9self.cursorObject.isVisible = isFocused\
\9self.cursorPosition = self.cursorPosition or 1\
\9self.isFocused = isFocused\
\9self:updateThemeStyle()\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
\9@param [Event] event -- the mouse up event\
\9@return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onGlobalMouseUp( Event event, Event.phases phase )\
\9if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self.isPressed = false\
\9\9if self.isEnabled and self:hitTestEvent( event ) then\
\9\9\9return self.event:handleEvent( event )\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is released. Focuses on the text box\
\9@param [MouseDownEvent] event -- the mouse down event\
\9@return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onMouseUp( Event event, Event.phases phase )\
\9if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self:focus( TextBox )\
\9end\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
\9@param [MouseDownEvent] event -- the mouse down event\
\9@return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onMouseDown( Event event, Event.phases phase )\
\9if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self.isPressed = true\
\9\9self.cursorPosition = self:viewToCharCoords( event.x - self.leftMargin + self.scroll )\
\9\9self.selectionPosition = false\
\9end\
\9return true\
end\
\
function TextBox:onMouseDrag( Event event, Event.phases phase )\
\9if self.isPressed and self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self.isPressed = true\
\9\9self.selectionPosition = self:viewToCharCoords( event.x - self.leftMargin + self.scroll )\
\9end\
\9return true\
end\
\
function TextBox:onKeyDown( Event event, Event.phases phase )\
\9if self.isFocused then\
\9\9local keyCode = event.keyCode\
\9\9local text = self.text\
\
\9\9if keyCode == keys.backspace then\
\9\9\9if self.selectionPosition then\
\9\9\9\9self:write \"\"\
\9\9\9elseif self.cursorPosition > 1 then\
\9\9\9\9self.text = text:sub( 1, self.cursorPosition - 2 ) .. text:sub( self.cursorPosition )\
\9\9\9\9self.cursorPosition = self.cursorPosition - 1\
\9\9\9end\
\9\9elseif keyCode == keys.left then\
\9\9\9local selectionPosition = self.selectionPosition\
\9\9\9local cursorPosition = self.cursorPosition\
\
\9\9\9if selectionPosition then\
\9\9\9\9self.cursorPosition = math.min( cursorPosition, selectionPosition )\
\9\9\9\9self.selectionPosition = false\
\9\9\9else\
\9\9\9\9self.cursorPosition = cursorPosition - 1\
\9\9\9end\
\9\9elseif keyCode == keys.right then\
\9\9\9local selectionPosition = self.selectionPosition\
\9\9\9local cursorPosition = self.cursorPosition\
\
\9\9\9if selectionPosition then\
\9\9\9\9self.cursorPosition = math.max( cursorPosition, selectionPosition )\
\9\9\9\9self.selectionPosition = false\
\9\9\9else\
\9\9\9\9self.cursorPosition = cursorPosition + 1\
\9\9\9end\
\9\9elseif keyCode == keys[\"end\"] then\
\
\9\9elseif keyCode == keys.home then\
\
\9\9elseif keyCode == keys.delete then\
\
\9\9end\
\9end\
end\
\
function TextBox:onKeyUp( Event event, Event.phases phase )\
\9if self.isFocused then\
\9\9\
\9end\
end\
\
function TextBox:onCharacter( Event event, Event.phases phase )\
\9if self.isFocused then\
\9\9local text = self.text\
\9\9self:write( CharacterEvent )\
\9end\
end\
\
--[[\
    @instance\
    @desc Fired when the a keyboard shortcut is fired\
    @param [Event] event -- the keyboard shortcut\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onKeyboardShortcut( Event event, Event.phases phase )\
    if self.isFocused then\
        if event:matchesKeys( { \"ctrl\", \"left\" } ) or event:matchesKeys( { \"home\" } ) then\
        \9self.selectionPosition = false\
        \9self.cursorPosition = 1\
        elseif event:matchesKeys( { \"ctrl\", \"right\" } ) or event:matchesKeys( { \"end\" } ) then\
        \9self.selectionPosition = false\
        \9self.cursorPosition = #self.text + 1\
        elseif event:matchesKeys( { \"ctrl\", \"shift\", \"left\" } ) then -- ehm, nope, select a word\
        \9self.selectionPosition = 1\
        elseif event:matchesKeys( { \"ctrl\", \"shift\", \"right\" } ) then -- ehm, nope, select a word\
        \9self.selectionPosition = #self.text + 1\
        elseif event:matchesKeys( { \"shift\", \"left\" } ) then\
        \9local selectionPosition = self.selectionPosition\
        \9if selectionPosition then\
\9        \9self.selectionPosition = math.max( 1, selectionPosition - 1 )\
\9    \9else\
\9    \9\9self.selectionPosition = math.max( 1, self.cursorPosition - 1 )\
\9    \9end\
        elseif event:matchesKeys( { \"shift\", \"right\" } ) then\
        \9local selectionPosition = self.selectionPosition\
        \9if selectionPosition then\
\9        \9self.selectionPosition = math.min( #self.text + 1, selectionPosition + 1 )\
\9    \9else\
\9    \9\9self.selectionPosition = math.min( #self.text + 1, self.cursorPosition + 1 )\
\9    \9end\
        elseif event:matchesKeys( { \"ctrl\", \"a\" } ) then\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = #self.text + 1\
        elseif event:matchesKeys( { \"ctrl\", \"backspace\" } ) then\
        \9local cursorPosition = self.cursorPosition\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = false\
        \9self.text = self.text:sub( cursorPosition )\
        elseif event:matchesKeys( { \"ctrl\", \"home\" } ) then\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = #self.text + 1\
        elseif event:matchesKeys( { \"ctrl\", \"end\" } ) then\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = #self.text + 1\
        else\
            return false\
        end\
        return true\
    end\
end",
  },
  ClipboardData = {
    [ "text/lua" ] = "\
class \"ClipboardData\" {}\
\
function ClipboardData:initialise()\
end",
  },
  MouseScrollEvent = {
    [ "text/lua" ] = "\
class \"MouseScrollEvent\" extends \"MouseEvent\" {\
    static = {\
        eventType = \"mouse_scroll\";\
    };\
\9direction = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.direction] direction -- the direction of the scroll\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseScrollEvent:initialise( direction, x, y )\
\9self.direction = direction\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end\
",
  },
  MouseUpEvent = {
    [ "text/lua" ] = "\
class \"MouseUpEvent\" extends \"MouseEvent\" {\
    static = {\
        eventType = \"mouse_up\";\
    };\
\9mouseButton = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseUpEvent:initialise( mouseButton, x, y )\
\9self.mouseButton = mouseButton\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end\
",
  },
  ProgressBarStripes = {
    [ "text/lua" ] = "\
class \"ProgressBarStripes\" extends \"RoundedRectangle\" {\
\9stripeColour = false;\
\9animationStep = 0;\
\9stripeWidth = 9;\
}\
\
 -- @constructor( number x, number y, number width, number height, graphics.fillColour fillColour )\
function ProgressBarStripes:initialise( x, y, width, height, fillColour, outlineColour, stripeColour, radius )\
\9self:super( x, y, width, height, fillColour, outlineColour, radius, 0, radius, 0 )\
\9self.fillColour = fillColour\
\9self.outlineColour = fillColour\
\9self.stripeColour = stripeColour\
end\
\
function ProgressBarStripes.animationStep:set( animationStep )\
\9self.hasChanged = true\
\9self.animationStep = math.floor( animationStep )\
end\
\
function ProgressBarStripes:drawTo( canvas, isShadow )\
\9if self.isVisible and ( not isShadow or ( isShadow and self.drawsShadow ) ) then\
\9\9local fill = self.fill\
\9\9local outline\
\9\9if self.outlineColour ~= Graphics.colours.TRANSPARENT then\
\9\9\9outline = self:getOutline( fill )\
\9\9end\
\
\9\9local fillColour = self.fillColour\
\9\9local stripeColour = self.stripeColour\
\9\9local outlineColour = self.outlineColour\
\9\9local stripeWidth = self.stripeWidth\
\9\9local animationStep = self.animationStep\
\9\9local _x = self.x - 1\
\9\9local _y = self.y - 1\
\
\9\9local function fmap( x, y, colour )\
\9\9\9if fill[x] and fill[x][y] then\
\9\9\9\9return ( ( ( x + y - animationStep ) / stripeWidth ) % 2 < 1 ) and fillColour or stripeColour\
\9\9\9end\
\9\9end\
\9\9local function ofmap( x, y, colour )\
\9\9\9if outline[x] and outline[x][y] then\
\9\9\9\9return outlineColour\
\9\9\9elseif fill[x] and fill[x][y] then\
\9\9\9\9return ( ( ( x + y - animationStep ) / stripeWidth ) % 2 < 1 ) and fillColour or stripeColour\
\9\9\9end\
\9\9end\
\9\9canvas:map( outline and ofmap or fmap, _x, _y, self.width, self.height )\
\
\9\9if outline then\
\9\9\9for x, row in pairs( outline ) do\
\9\9\9\9for y, _ in pairs( row ) do\
\9\9\9\9\9canvas:setPixel( _x + x, _y + y, outlineColour )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9\
    return self\
end",
  },
  MouseHeldEvent = {
    [ "text/lua" ] = "\
class \"MouseHeldEvent\" extends \"MouseEvent\" {\
    eventType = \"mouse_held\";\
    mouseButton = false;\
    isSentToChildren = false;\
}\
\
--[[\
    @constructor\
    @desc Creates a mouse held event from the arguments\
    @param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
    @param [number] x -- the x screen coordinate\
    @param [number] y -- the y screen coordinate\
    @param [number] globalX -- the global x screen coordinate\
    @param [number] globalY -- the global y screen coordinate\
]]\
function MouseHeldEvent:initialise( mouseButton, x, y, globalX, globalY )\
    self.mouseButton = mouseButton\
    self.x = x\
    self.y = y\
    self.globalX = globalX\
    self.globalY = globalY\
end",
  },
  SiblingAddedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"SiblingAddedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_sibling_added\";\
    };\
\9view = false; -- the new sibling that was added\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a siblings changed event from the arguments\
\9@param [View] view -- the new sibling view\
]]\
function SiblingAddedInterfaceEvent:initialise( view )\
\9self.view = view\
end",
  },
  CharacterEvent = {
    [ "text/lua" ] = "\
class \"CharacterEvent\" extends \"Event\" {\
    static = {\
        eventType = \"char\";\
    };\
\9character = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a char event from the arguments\
\9@param [string] character -- the event character\
]]\
function CharacterEvent:initialise( character )\
\9self.character = character\
end",
  },
  Shader = {
    [ "text/lua" ] = "\
class \"Shader\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.LIGHT_GREY;\
}\
\
function Shader:initialise( x, y, width, height, shader )\
\9self:super( x, y, width, height )\
\9self.shader = shader\
end\
--[[\
    @instance\
    @desc Draws a the graphics object to the canvas\
    @param [Canvas] canvas -- the canvas to draw to\
    @return self\
]]\
function Shader:drawTo( canvas, isShadow )\
\9if self.isVisible and ( not isShadow or ( isShadow and self.drawsShadow ) ) then\
\9\9canvas:map( self.shader, self.x, self.y, self.width, self.height )\
\9end\
\9\
    return self\
end",
  },
  SegmentButton = {
    [ "text/lua" ] = "\
-- TODO: this needs some fixes to make the last button have a gap on it's left when pushed\
\
class \"SegmentButton\" extends \"Button\" {\
\9\
\9separatorObject = false;\
    separatorBackgroundObject = false;\
    centerMargin = false;\
    leftRadius = false;\
    rightRadius = false;\
\
}\
\
function SegmentButton:initialise( ... )\
    self:super( ... )\
    self:event( ParentChangedInterfaceEvent, self.onSiblingOrParentChanged )\
    self:event( SiblingAddedInterfaceEvent, self.onSiblingOrParentChanged )\
    self:event( SiblingAddedInterfaceEvent, self.onSiblingOrParentChanged )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function SegmentButton:initialiseCanvas()\
\9self:super()\
    local separatorBackgroundObject = self.canvas:insert( Rectangle( self.width, 1, 1, self.height -1 ) )\
    local separatorObject = self.canvas:insert( Separator( self.width, 3, 1, self.height - 4 ) )\
    separatorBackgroundObject.leftOutlineWidth = 0\
    separatorBackgroundObject.rightOutlineWidth = 0\
    local theme = self.theme\
    theme:connect( separatorObject, \"fillColour\", \"separatorFillColour\" )\
    theme:connect( separatorObject, \"isDashed\", \"separatorIsDashed\" )\
    theme:connect( separatorBackgroundObject, \"fillColour\", \"separatorBackgroundColour\" )\
    theme:connect( separatorBackgroundObject, \"outlineColour\", \"separatorOutlineColour\" )\
    theme:connect( self, \"centerMargin\" )\
    self.separatorBackgroundObject = separatorBackgroundObject\
    self.separatorObject = separatorObject\
    theme:disconnect( self.backgroundObject, \"radius\", \"cornerRadius\" )\
    theme:disconnect( self.shadowObject, \"radius\", \"cornerRadius\" )\
end\
\
 -- yes, set, not update\
function SegmentButton.width:set( width )\
    self:super( width )\
    local isFirst = self.isFirst\
    local isLast = self.isLast\
    self.backgroundObject.width = isLast and width - 1 or width - 1\
    self.shadowObject.width = (isLast or isFirst) and width - 1 or width\
    self.separatorObject.x = width\
    self.separatorBackgroundObject.x = width\
    \
    local textObject = self.textObject\
    if textObject then\
        local leftMargin, rightMargin = self.leftMargin, self.rightMargin\
        textObject.x = self.isPressed and leftMargin + 2 or leftMargin + 1\
        textObject.width = width - leftMargin - rightMargin\
    end\
    self.parent.needsLayoutUpdate = true\
end\
\
function SegmentButton.rightMargin:get()\
    return self.isLast and self.rightMargin or self.centerMargin\
end\
\
function SegmentButton.leftMargin:get()\
    return self.isFirst and self.leftMargin or self.centerMargin\
end\
\
function SegmentButton.isPressed:set( isPressed )\
    self:super( isPressed )\
    local isFirst = self.isFirst\
    local isLast = self.isLast\
    if isLast then\
        local width = self.width\
        self.backgroundObject.x = isPressed and 2 or 1\
        self.backgroundObject.width = width - self.centerMargin --isPressed and width - 4 or width - 2\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when it's siblings changed or it is added/removed from it's parent\
    @param [Event] event -- the event\
]]\
function SegmentButton:onSiblingOrParentChanged( Event event, Event.phases phase )\
    local backgroundObject = self.backgroundObject\
    local shadowObject = self.shadowObject\
    local isFirst = self.isFirst\
    local isLast = self.isLast\
    local theme = self.theme\
\
    shadowObject.x = (isLast or isFirst) and 2 or 1\
    backgroundObject.leftOutlineWidth = isFirst and 1 or 0\
    backgroundObject.rightOutlineWidth = isLast and 1 or 0\
    self.separatorObject.isVisible = not isLast\
    self.separatorBackgroundObject.isVisible = not isLast\
\
\
    if isFirst then\
        theme:connect( backgroundObject, \"leftRadius\", \"cornerRadius\" )\
        theme:connect( shadowObject, \"leftRadius\", \"cornerRadius\" )\
    else\
        theme:disconnect( backgroundObject, \"leftRadius\", \"cornerRadius\" )\
        theme:disconnect( shadowObject, \"leftRadius\", \"cornerRadius\" )\
    end\
\
    if isLast then\
        theme:connect( backgroundObject, \"rightRadius\", \"cornerRadius\" )\
        theme:connect( shadowObject, \"rightRadius\", \"cornerRadius\" )\
    else\
        theme:disconnect( backgroundObject, \"rightRadius\", \"cornerRadius\" )\
        theme:disconnect( shadowObject, \"rightRadius\", \"cornerRadius\" )\
    end\
\
\
    local width = self.width\
    local isPressed = self.isPressed\
    -- backgroundObject.width = (isLast and isPressed) and width or width - 1\
    shadowObject.width = ((isLast and not isPressed) or isFirst) and width - 1 or width\
end",
  },
  Cursor = {
    [ "text/lua" ] = "\
class \"Cursor\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.BLACK;\
}\
\
function Cursor:initialise( x, y, height )\
\9self:super( x, y, 1, height )\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Cursor.fill:get()\
\9if self.fill then return self.fill end\
\9local fill = {}\
\9local fillX = {}\
\9for y = 1, self.height do\
\9\9fillX[y] = true\
\9end\
\9fill[1] = fillX\
\9return fill\
end",
  },
  MenuButton = {
    [ "text/lua" ] = "\
class \"MenuButton\" extends \"Button\" {\
\
    width = 45;\
\
    menu = false;\
    menuName = false;\
\
    menuMargin = 5;\
\
    isActive = Boolean; -- TODO: isReadOnly\
\
    closeArrowObject = false;\
    openArrowObject = false;\
    needsArrowUpdate = false;\
}\
\
--[[\
    @constructor\
    @desc Creates a MenuButton object and connects the event handlers\
]]\
function MenuButton:initialise( ... )\
    self:super( ... )\
    local menuName = self.menuName\
    if not menuName then error( \"MenuButtons must specify the property menuName (the name of the interface file to use).\", 0 ) end\
    menu = Menu.fromInterface( menuName )\
    menu.owner = self\
    menu.isSingleShot = false\
    menu.isVisible = false\
    menu.hitTestOwner = true\
    menu.topMargin = Menu.topMargin + 8\
    self.menu = menu\
    self:event( MenuChangedInterfaceEvent, self.onMenuChanged )\
    self:event( ParentChangedInterfaceEvent, self.onParentChanged )\
end\
\
function MenuButton:onParentChanged( Event event, Event.phases phase )\
    local menu = self.menu\
    if menu then\
        menu = self.menu\
        if menu.parent then\
            menu.parent:removeChild( menu )\
        end\
        menu.x = self.x - 5\
        menu.y = self.y + 7\
        self.parent:insert( menu )\
    end\
end\
\
function MenuButton:updateX( x )\
    local menu = self.menu\
    if menu then\
        menu.x = self.x - 5\
    end\
end\
\
function MenuButton:updateY( y )\
    local menu = self.menu\
    if menu then\
        menu.y = self.y + 5\
    end\
end\
\
function MenuButton:updateHeight( height )\
    self.needsArrowUpdate = true\
end\
\
function MenuButton:initialiseCanvas()\
    self:super()\
    local arrowX, arrowY = self.width - 12, math.ceil( ( self.height - 4 ) / 2 )\
\
    local closeArrowObject = Path( 1, 1, 7, 4, 1, 4 )\
    closeArrowObject:lineTo( 4, 1 )\
    closeArrowObject:lineTo( 7, 4 )\
    closeArrowObject:close( false )\
    closeArrowObject.isVisible = false\
    self.closeArrowObject = closeArrowObject\
    self.canvas:insert( closeArrowObject )\
\
    local openArrowObject = Path( 1, 1, 7, 4, 1, 1 )\
    openArrowObject:lineTo( 4, 4 )\
    openArrowObject:lineTo( 7, 1 )\
    openArrowObject:close( false )\
    self.openArrowObject = openArrowObject\
    self.canvas:insert( openArrowObject )\
\
    self.theme:connect( closeArrowObject, \"outlineColour\", \"arrowColour\" )\
    self.theme:connect( openArrowObject, \"outlineColour\", \"arrowColour\" )\
    self.needsArrowUpdate = true\
end\
\
--[[\
    @instance\
    @desc Whether the button is pressed or open\
    @return [boolean] isActive -- whether the button is active\
]]\
function MenuButton.isActive:get()\
    return self.isPressed or self.menu.isOpen\
end\
\
function MenuButton:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isActive and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function MenuButton:update()\
    self:super()\
    if self.needsArrowUpdate then\
        self:updateArrows()\
    end\
end\
\
--[[\
    @instance\
    @desc Description\
    @param [type] arg1 -- description\
    @param [type] arg2 -- description\
    @param [type] arg3 -- description\
    @return [type] returnedValue -- description\
]]\
function MenuButton:updateArrows()\
    local menu = self.menu\
    local isOpen = menu and menu.isOpen\
    local arrowX, arrowY = self.width - 12, math.ceil( ( self.height - 4 ) / 2 ) + 1\
    local activeArrow = isOpen and self.closeArrowObject or self.openArrowObject\
    local inactiveArrow = isOpen and self.openArrowObject or self.closeArrowObject\
    activeArrow.isVisible = true\
    inactiveArrow.isVisible = false\
    activeArrow.x = arrowX + ( self.isPressed and 1 or 0 )\
    activeArrow.y = arrowY + ( self.isPressed and 1 or 0 )\
    self.needsArrowUpdate = false\
end\
\
function MenuButton.isPressed:set( isPressed )\
    self:super( isPressed )\
    self.needsArrowUpdate = true\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released while over the button. Toggles the menu if it hit tests.\
    @param [Event] event -- the mouse up event\
]]\
function MenuButton:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isEnabled and self.isPressed then\
        self.isPressed = false\
        if self:hitTestEvent( event ) then\
            self.menu:toggle()\
            return self.event:handleEvent( event )\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the owned menu opens or closes\
    @param [Event] event -- the menu changed event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuButton:onMenuChanged( Event event, Event.phases phase )\
    self:updateArrows()\
    self:updateThemeStyle()\
\
    if self.menu.isOpen then\
        self.parent:sendToFront( self.menu )\
        self.parent:sendToFront( self )\
    end\
    return true\
end",
  },
  ThemeChangedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"ThemeChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_theme_changed\";\
    };\
\9newThemeName = false;\
\9oldThemeName = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a theme changed event from the arguments\
\9@param newThemeName -- the theme that is now active\
\9@param oldThemeName -- the theme that was previously active\
]]\
function ThemeChangedInterfaceEvent:initialise( newThemeName, oldThemeName )\
\9self.newThemeName = newThemeName\
\9self.oldThemeName = oldThemeName\
end\
",
  },
  GraphicsObject = {
    [ "text/lua" ] = "\
class \"GraphicsObject\" {\
\9x = 1; -- @property x [number] - The x position of the object\
\9y = 1; -- @property y [number] - The y position of the object\
\9width = 0; -- @property width [number] - The width of the object\
\9height = 0; -- @property height [number] - The height of the object\
\9hasChanged = false; -- @property hasChanged [boolean] - Whether or not the object's internals have hasChanged since it was last drawn\
\9parent = false; -- @property parent [Canvas] - The parent of the object, if it exists\
\9outlineColour = Graphics.colours(); -- @property [Graphics.colours] -- The colour of the outline\
\9leftOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9topOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9rightOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9bottomOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9outlineWidth = Number( 1 ); -- @property [number] -- The thickness of the outline\
\9fillColour = Graphics.colours.TRANSPARENT; -- @property [Graphics.colours] -- The fill colour of the object\
\9isVisible = true;\
\9fill = false;\
\9outline = false;\
\9drawsShadow = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a graphics object\
\9@param [number] x -- the x coordinate of the graphics object\
\9@param [number] y -- the y coordinate of the graphics object\
\9@param [number] width -- the width of the graphics object\
\9@param [number] height -- the height of the graphics object\
]]\
function GraphicsObject:initialise( x, y, width, height )\
\9self.x = x\
\9self.y = y\
\9self.width = width\
\9self.height = height\
end\
\
--[[\
\9@instance\
\9@desc Sets the x coordinate of the graphics object\
\9@param [number] x -- the x coordinate of the graphics object\
]]\
function GraphicsObject.x:set( x )\
\9if self.parent then\
\9\9self.parent.hasChanged = true\
\9end\
\9self.x = x\
end\
\
--[[\
\9@instance\
\9@desc Sets the y coordinate of the graphics object\
\9@param [number] y -- the y coordinate of the graphics object\
]]\
function GraphicsObject.y:set( y )\
\9if self.parent then\
\9\9self.parent.hasChanged = true\
\9end\
\9self.y = y\
end\
\
--[[\
\9@instance\
\9@desc Sets the width of the graphics object\
\9@param [number] width -- the width of the graphics object\
]]\
function GraphicsObject.width:set( width )\
\9if self.width ~= width then\
\9\9self.hasChanged = true\
\9\9self.width = width\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Sets the height of the graphics object\
\9@param [number] height -- the height of the graphics object\
]]\
function GraphicsObject.height:set( height )\
\9if self.height ~= height then\
\9\9self.hasChanged = true\
\9\9self.height = height\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject.outlineWidth:set( outlineWidth )\
\9self.leftOutlineWidth = outlineWidth\
\9self.topOutlineWidth = outlineWidth\
\9self.rightOutlineWidth = outlineWidth\
\9self.bottomOutlineWidth = outlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject.leftOutlineWidth:set( leftOutlineWidth )\
\9self.hasChanged = true\
\9self.leftOutlineWidth = leftOutlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject.topOutlineWidth:set( topOutlineWidth )\
\9self.hasChanged = true\
\9self.topOutlineWidth = topOutlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject.rightOutlineWidth:set( rightOutlineWidth )\
\9self.hasChanged = true\
\9self.rightOutlineWidth = rightOutlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject.bottomOutlineWidth:set( bottomOutlineWidth )\
\9self.hasChanged = true\
\9self.bottomOutlineWidth = bottomOutlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the fillColour of the graphics object\
\9@param [number] fillColour -- the fillColour of the graphics object\
]]\
function GraphicsObject.fillColour:set( fillColour )\
\9-- assert( type( fillColour ) == \"number\", \"fillColour must be a valid colour.\")\
\9self.hasChanged = true\
\9self.fillColour = fillColour\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineColour of the graphics object\
\9@param [number] outlineColour -- the outlineColour of the graphics object\
]]\
function GraphicsObject.outlineColour:set( outlineColour )\
\9-- assert( type( outlineColour ) == \"number\", \"outlineColour must be a valid colour.\")\
\9self.hasChanged = true\
\9self.outlineColour = outlineColour\
end\
\
--[[\
\9@instance\
\9@desc Sets the visibility of the graphics object\
\9@param [boolean] isVisible -- whether the graphics object is visible\
]]\
function GraphicsObject.isVisible:set( isVisible )\
\9self.hasChanged = true\
\9self.isVisible = isVisible\
end\
\
--[[\
\9@instance\
\9@desc Sets the changed state of the graphics object, applying it to the parent too\
\9@param [boolean] hasChanged -- the changed state\
]]\
function GraphicsObject.hasChanged:set( hasChanged )\
\9if hasChanged then\
\9\9local parent = self.parent\
\9\9if parent then\
\9\9\9parent.hasChanged = true\
\9\9end\
\9\9if self.raw.fill then\
\9\9\9self.fill = false\
\9\9end\
\9end\
\9self.hasChanged = hasChanged\
end\
\
--[[\
\9@instance\
\9@desc Sets the parent of the graphics object, removing the old one if it exists\
\9@param [boolean] hasChanged -- the parent\
]]\
function GraphicsObject.parent:set( parent )\
\9if self.parent then\
\9\9self.parent:remove( self )\
\9end\
\9self.parent = parent\
\9if parent then\
\9\9parent:insert( self )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Generates the outline pixels from the given fill\
\9@param [table] fill -- the fill returned from self.getFill\
\9@return [table] outline -- the outline\
]]\
function GraphicsObject:getOutline( fill )\
\9local outline = {}\
\
\9local function xScanline( min, max, inc, outlineWidth )\
\9\9for y = 1, self.height do\
\9\9\9local lastX = 0\
\9\9\9local xPixels = 0\
\9\9\9for x = min, max, inc do\
\9\9\9\9outline[x] = outline[x] or {}\
\9\9\9\9if fill[x] and fill[x][y] then\
\9\9\9\9\9if xPixels < outlineWidth then\
\9\9\9\9\9\9xPixels = xPixels + 1\
\9\9\9\9\9\9outline[x][y] = true\
\9\9\9\9\9end\
\9\9\9\9\9lastX = x\
\9\9\9\9else\
\9\9\9\9\9xPixels = 0\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9local function yScanline( min, max, inc, outlineWidth )\
\9\9for x = 1, self.width do\
\9\9\9local lastY = 0\
\9\9\9local yPixels = 0\
\9\9\9for y = min, max, inc do\
\9\9\9\9if fill[x] and fill[x][y] then\
\9\9\9\9\9if yPixels < outlineWidth then\
\9\9\9\9\9\9yPixels = yPixels + 1\
\9\9\9\9\9\9outline[x][y] = true\
\9\9\9\9\9end\
\9\9\9\9\9lastX = x\
\9\9\9\9else\
\9\9\9\9\9yPixels = 0\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9xScanline( 1, self.width, 1, self.leftOutlineWidth )\
\9xScanline( self.width, 1, -1, self.rightOutlineWidth )\
\9yScanline( 1, self.height, 1, self.topOutlineWidth )\
\9yScanline( self.height, 1, -1, self.bottomOutlineWidth )\
\
\9return outline\
end\
\
--[[\
\9@instance\
\9@desc Draws a the graphics object to the canvas\
\9@param [Canvas] canvas -- the canvas to draw to\
\9@return self\
]]\
function GraphicsObject:drawTo( canvas, isShadow )\
\9if self.isVisible and ( not isShadow or ( isShadow and self.drawsShadow ) ) then\
\9\9local fill = self.fill\
\9\9local outline\
\9\9local outlineColour = self.outlineColour\
\9\9if outlineColour ~= Graphics.colours.TRANSPARENT then\
\9\9\9outline = self:getOutline( fill )\
\9\9end\
\
\9\9local fillColour = self.fillColour\
\9\9local _x = self.x - 1\
\9\9local _y = self.y - 1\
\
\9\9local buffer = canvas.buffer\
\9\9local width, height = canvas.width, canvas.height\
\9\9local TRANSPARENT = Graphics.colours.TRANSPARENT\
\9\9local function setPixel( x, y, colour )\
\9\9\9if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= width and y <= height then\
\9\9\9\9buffer[ ( y - 1 ) * width + x ] = colour\
\9\9\9end\
\9\9end\
\
\9\9if fill then\
\9\9\9for x, row in pairs( fill ) do\
\9\9\9\9local outlineX = outline and outline[x]\
\9\9\9\9for y, isFilled in pairs( row ) do\
                    if isFilled and (not outline or not outlineX or not outlineX[y]) then\
                        setPixel( _x + x, _y + y, fillColour )\
                    end\
                end\
\9\9\9end\
\9\9end\
\
\9\9if outline then\
\9\9\9for x, row in pairs( outline ) do\
\9\9\9\9for y, _ in pairs( row ) do\
\9\9\9\9\9setPixel( _x + x, _y + y, outlineColour )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9\
\9return self\
end\
\
--[[\
    @instance\
    @desc Draws a graphics object to an image\
\9@param [boolean] isShadow -- whether just the shadow should be drawn\
    @return [Image] image -- the image of the graphics object\
]]\
function GraphicsObject:toImage( isShadow )\
\9local parent = self.parent or self\
    local canvasWidth, canvasHeight = parent.width, parent.height\
    local width, height = self.width, self.height\
    local fakeCanvas = { width = canvasWidth; height = canvasHeight; buffer = {} }\
\
    self:drawTo( fakeCanvas, isShadow )\
\
    local _x = self.x - 1\
    local _y = self.y\
    local pixels, canvasBuffer = {}, fakeCanvas.buffer\
\9local TRANSPARENT = Graphics.colours.TRANSPARENT\
\
    for x = 1, width do\
    \9local pixelsX = {}\
        for y = 1, height do\
            local nx, ny = x + _x, y + _y - 1\
            pixelsX[y] = canvasBuffer[( ny - 1 ) * canvasWidth + nx] or TRANSPARENT\
        end\
        pixels[x] = pixelsX\
    end\
\
    return Image.fromPixels( pixels, width, height )\
end\
\
--[[\
    @instance\
    @desc Draws a graphics object's shadow to an image\
    @return [Image] image -- the image of the graphics object\
]]\
function GraphicsObject:toShadowImage()\
    return self:toImage( true )\
end",
  },
  ImageObject = {
    [ "text/lua" ] = "\
class \"ImageObject\" extends \"GraphicsObject\" {\
\
    image = false;\
\
}\
\
function ImageObject:initialise( x, y, width, height, image )\
    self:super( x, y, width, height )\
\
    if image then\
        self.image = image\
    end\
end\
\
function ImageObject.image:set( image )\
    self.hasChanged = true\
    if type( image ) == \"string\" then\
        self.image = Image.fromName( image ) or false\
    else\
        self.image = image\
    end\
end\
\
function ImageObject.fill:get()\
    if self.fill then return self.fill end\
\
    local fill, image = {}, self.image\
    if image then\
        local pixels, TRANSPARENT = image:getScaledPixels( self.width, self.height ), Graphics.colours.TRANSPARENT\
\
        for x, column in ipairs( pixels ) do\
            local fillX = {}\
            for y, pixel in ipairs( column ) do\
                fillX[y] = pixel ~= TRANSPARENT\
            end\
            fill[x] = fillX\
        end\
    end\
\
    return fill\
end\
\
function ImageObject:drawTo( canvas, isShadow )\
\9if self.isVisible and ( not isShadow or ( isShadow and self.drawsShadow ) ) then\
        local image = self.image\
        if not image then return end\
\
        local fillColour = self.fillColour\
        local outlineColour = self.outlineColour\
        local _x = self.x - 1\
        local _y = self.y - 1\
\
        local buffer = canvas.buffer\
        local width, height = canvas.width, canvas.height\
        local TRANSPARENT = Graphics.colours.TRANSPARENT\
        local function setPixel( x, y, colour )\
            if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= width and y <= height then\
                buffer[ ( y - 1 ) * width + x ] = colour\
            end\
            return canvas\
        end\
\
        local fill = {}\
        local pixels = image:getScaledPixels( self.width, self.height )\
        for x, column in ipairs( pixels ) do\
            local fillX = {}\
            for y, pixel in ipairs( column ) do\
                fillX[y] = pixel ~= TRANSPARENT\
            end\
            fill[x] = fillX\
        end\
\
        local outline\
        if self.outlineColour ~= Graphics.colours.TRANSPARENT then\
            outline = self:getOutline( fill )\
        end\
\
        for x, column in ipairs( pixels ) do\
            for y, pixel in ipairs( column ) do\
                if (not outline or not outlineX or not outlineX[y]) then\
                    setPixel( _x + x, _y + y, pixel )\
                end\
            end\
        end\
\
        if outline then\
            for x, row in pairs( outline ) do\
                for y, _ in pairs( row ) do\
                    setPixel( _x + x, _y + y, outlineColour )\
                end\
            end\
        end\
    end\
    \
    return self\
end",
  },
  ToolbarSymbolSegmentButton = {
    [ "text/lua" ] = "\
class \"ToolbarSymbolSegmentButton\" extends \"SymbolSegmentButton\" {}",
  },
  File = {
    [ "text/lua" ] = "\
class \"File\" extends \"FileSystemItem\" implements \"IEditableFileSystemItem\" {\
\
    contents = false; -- the string contents of the file\
    binaryContents = false; -- a table of bytes; the file contents, read and written using the rb/wb mode \
    serialisedContents = false; -- the texutils.(un)serialised contents of the file. automatically serialises/unserialises each time\
    \
}\
\
function File.metatable:__call( path, ... )\
    if fs.exists( path ) and not fs.isDir( path ) and not fs.isReadOnly( path ) then\
        local name = fs.getName( path )\
        if name ~= \".DS_Store\" and name ~= \".metadata\" then\
            return self.spawn( path, ... )\
        end\
    end\
    return false\
end\
\
function File.static:make( path, mime, overwrite, contents )\
    local exists = fs.exists( path )\
    if overwrite and exists then\
        fs.delete( path )\
        exists = false\
    end\
\
    if not exists then\
        local h = fs.open( path, \"w\" )\
        h.write( contents or \"\" )\
        h.close()\
        local file = self.class( path )\
        file.metadata.mime = mime\
        return file\
    end\
end\
\
function File.contents:set( contents )\
    local handle = fs.open( self.path, \"w\" )\
    if handle then\
        handle.write( contents )\
        handle.close()\
    else\
        -- TODO: file writting error handling\
    end\
end\
\
function File.serialisedContents:set( serialisedContents )\
    self.contents = textutils.serialize( serialisedContents )\
end\
\
function File.binaryContents:set( binaryContents )\
    if type( binaryContents ) ~= \"binaryContents\" then error( \"File.binaryContents must be set with a table of bytes.\", 2 ) end\
    local handle = fs.open( self.path, \"wb\" )\
    if handle then\
        for i, byte in ipairs( binaryContents ) do\
            handle.write( byte )\
        end\
        handle.close()\
    else\
        -- TODO: file writing error handling\
    end\
end\
\
function File.contents:get()\
    local handle = fs.open( self.path, \"r\" )\
    if handle then\
        local contents = handle.readAll( contents )\
        handle.close()\
        return contents\
    else\
        -- TODO: file reading error handling\
    end\
end\
\
function File.serialisedContents:get()\
    return textutils.unserialize( self.contents )\
end\
\
function File.binaryContents:get()\
    local handle = fs.open( self.path, \"rb\" )\
    if handle then\
        local contents = {}\
        local lastByte = handle.read()\
        local tinsert = table.insert\
        repeat\
            tinsert( contents, lastByte )\
            lastByte = handle.read()\
        until not lastByte\
        handle.close()\
        return contents\
    else\
        -- TODO: file writing error handling\
    end\
end",
  },
  SegmentContainer = {
    [ "text/lua" ] = "\
class \"SegmentContainer\" extends \"Container\" {\
\9needsLayoutUpdate = false;\9\
}\
\
--[[\
\9@instance\
\9@desc Updates the location and size of the menu as well as the location and size of the menu items\
]]\
function SegmentContainer:updateLayout()\
\9if self.isVisible then\
\9\9local width = 0\
\9\9local height = 0\
\9\9for i, childView in ipairs( self.children ) do\
\9\9\9height = math.max( height, childView.height )\
\9\9end\
\
\9\9for i, childView in ipairs( self.children ) do\
\9\9\9childView.x = width + 1\
\9\9\9childView.y = 1\
\9\9\9width = width + childView.width\
\9\9end\
\9\9self.width = width\
\9\9self.height = height\
\9end\
end\
\
function SegmentContainer:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function SegmentContainer:insert( ... )\
\9self:super( ... )\
\9self.needsLayoutUpdate = true\
end\
\
function SegmentContainer:removeChild( ... )\
\9self:super( ... )\
\9self.needsLayoutUpdate = true\
end",
  },
  RightSymbol = {
    [ "text/lua" ] = "\
class \"RightSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"right\";\
\
    serialisedPaths = {\
        {\
            x = 1;\
            y = 1;\
            lines = {\
                {\
                    y1 = 1;\
                    x1 = 4;\
                    x2 = 7;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 7;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 7;\
                };\
                {\
                    y1 = 7;\
                    x1 = 4;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 5;\
                };\
                {\
                    y1 = 5;\
                    x1 = 4;\
                    x2 = 1;\
                    mode = \"linear\";\
                    y2 = 5;\
                };\
                {\
                    y1 = 5;\
                    x1 = 1;\
                    x2 = 1;\
                    mode = \"linear\";\
                    y2 = 3;\
                };\
                {\
                    y1 = 3;\
                    x1 = 1;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 3;\
                };\
                {\
                    y1 = 3;\
                    x1 = 4;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 1;\
                };\
            };\
            height = 7;\
            width = 7;\
        }\
    }\
\
\
}",
  },
  IDraggableView = {
    [ "text/lua" ] = "\
interface \"IDraggableView\" {}",
  },
  ToolbarSymbolButton = {
    [ "text/lua" ] = "\
class \"ToolbarSymbolButton\" extends \"SymbolButton\" implements \"IToolbarItem\" implements \"IToolbarPressableItem\" {}",
  },
  UpSymbol = {
    [ "text/lua" ] = "\
class \"UpSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"up\";\
\
    serialisedPaths = {\
        {\
            x = 1;\
            y = 1;\
            lines = {\
                {\
                    y1 = 1;\
                    x1 = 4;\
                    x2 = 7;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 7;\
                    x2 = 5;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 5;\
                    x2 = 5;\
                    mode = \"linear\";\
                    y2 = 7;\
                };\
                {\
                    y1 = 7;\
                    x1 = 5;\
                    x2 = 3;\
                    mode = \"linear\";\
                    y2 = 7;\
                };\
                {\
                    y1 = 7;\
                    x1 = 3;\
                    x2 = 3;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 3;\
                    x2 = 1;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 1;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 1;\
                };\
            };\
            height = 7;\
            width = 7;\
        }\
\
    }\
\
\
}",
  },
  Container = {
    [ "text/lua" ] = "\
class \"Container\" extends \"View\" {\
\9children = {};\
\9interfaceOutlets = {};\
\9interfaceName = false;\
\9offsetX = 0;\
\9offsetY = 0;\
\9interfaceOutletActions = {};\
}\
\
--[[\
\9@constructor\
\9@desc Initialises the container, linking up any InterfaceOutlets\
\9@param ...\
]]\
function Container:initialise( ... )\
\9self:super( ... )\
\9self:loadInterface()\
\9self:event( InterfaceOutletChangedInterfaceEvent, self.onInterfaceOutletChanged )\
end\
\
--[[\
\9@static\
\9@desc Creates a container from interface file\
\9@param [string] interfaceName -- the name of the interface file\
\9@param [class] _class -- the class that the container must extend (e.g. ApplicationContainer). If this is being called on a subclass you MUST pass in the class.\
\9@return [Container or _class] container -- the container\
]]\
function Container.static:fromInterface( interfaceName, _class )\
\9local interface = Interface( interfaceName, _class or Container )\
\9if interface then\
\9\9local container = interface.container\
\9\9container.interface = interface\
\9\9return container\
\9end\
end\
\
--[[\
    @instance\
    @desc Loads the children and properties of the interface specified by the self.interfaceName interface name. Called automatically during Container:init, do not call this yourself.\
]]\
function Container:loadInterface()\
    local interfaceName = self.interfaceName\
    if interfaceName then\
        local interface = Interface( interfaceName, self.class )\
\
        local containerInterfaceProperties = self.interfaceProperties\
        for k, v in pairs( interface.containerProperties ) do\
        \9if not containerInterfaceProperties or not containerInterfaceProperties[k] then -- if the interface defining THIS container specified this property then don't set it\
        \9\9self[k] = v\
        \9end\
        end\
\
        for i, childView in ipairs( interface.children ) do\
        \9self:insert( childView )\
        end\
    end\
end\
\
function Container:onInterfaceOutletChanged( Event event, Event.phases phase )\
\9local interfaceOutlet = event.interfaceOutlet\
\9local oldView = false\
\9local newView = false\
\9local interfaceOutletActions = self.interfaceOutletActions\
\9local BEFORE = Event.phases.BEFORE\
\9local ACTION = ActionInterfaceEvent\
\
\9for k, outlet in pairs( self.interfaceOutlets ) do\
\9\9if interfaceOutlet == outlet then\
\9\9\9oldView = oldView == false and event.oldView or oldView\
\9\9\9newView = newView == false and event.newView or newView\
\9\9\9if oldView ~= newView then\
\9\9\9\9local func = interfaceOutletActions[k]\
\9\9\9\9if func then\
\9\9\9\9\9if oldView and #oldView == 0 then oldView.event:disconnect( ACTION, func, BEFORE, nil, self ) end\
\9\9\9\9\9if newView and #newView == 0 then newView:event( ACTION, func, BEFORE, nil, self ) end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
end\
\
--[[\
\9@instance\
\9@desc Called when a value is set. Connects InterfaceOutlets to the Container.\
\9@param [string] key -- the key of the set value\
    @param value -- the value\
]]\
-- function Container:set( key, value )\
-- \9if value and type( value ) == \"table\" and value.typeOf and value:typeOf( InterfaceOutlet ) then\
-- \9\9value:connect( key, self )\
-- \9elseif self.interfaceOutlets[key] and not value then\
-- \9\9self.interfaceOutlets[key]:disconnect()\
-- \9end\
-- end\
\
--[[\
\9@instance\
\9@desc Initialises the custom container event manger\
]]\
function Container:initialiseEventManager()\
\9self.event = ContainerEventManager( self )\
end\
\
--[[\
\9@instance\
\9@desc Updates the view and it's children When overriding this self.super:update must be called AFTER the custom drawing code.\
\9@param [number] deltaTime -- the time since last update\
]]\
function Container:update( deltaTime )\
\9self:super( deltaTime )\
\9for i, childView in ipairs( self.children ) do\
\9\9childView:update( deltaTime )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Fired after\
\9@param [type] arg1 -- description\
\9@param [type] arg2 -- description\
\9@param [type] arg3 -- description\
\9@return [type] returnedValue -- description\
]]\
function Container:onParentResizedConstraintUpdateAfter( arg1, arg2, arg3 )\
\9return returnedValue\
end\
\
function Container.width:set( width )\
\9self:super( width )\
    width = self.width\
\9local event = self.event\
\9if event then\
\9\9event:handleEvent( ParentResizedInterfaceEvent( true, false, self ) )\
\9end\
end\
\
function Container.height:set( height )\
\9self:super( height )\
    height = self.height\
\9local event = self.event\
\9if event then\
\9\9event:handleEvent( ParentResizedInterfaceEvent( false, true, self ) )\
\9end\
end\
\
function Container.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    for i, childView in ipairs( self.children ) do\
    \9-- we need to update the isEnabled value for all children, the best way is just to send the current value\
    \9childView.isEnabled = childView.raw.isEnabled\
    end\
end\
\
--[[\
\9@instance\
\9@desc Moves the view to be the top of it's siblings\
\9@param [View] childView -- the view to make front most\
]]\
function Container:sendToFront( frontView, position )\
\9local children = self.children\
\9for i, childView in ipairs( children ) do\
\9\9if childView == frontView then\
\9\9\9table.remove( children, i )\
\9\9\9if position then table.insert( children, position, childView )\
\9\9\9else table.insert( children, childView ) end\
\9\9end\
\9end\
\9local frontCanvas = frontView.canvas\
\9local canvasChildren = self.canvas.children\
\9for i, childCanvas in ipairs( canvasChildren ) do\
\9\9if childCanvas == frontCanvas then\
\9\9\9table.remove( canvasChildren, i )\
\9\9\9if position then table.insert( canvasChildren, position, childCanvas )\
\9\9\9else table.insert( canvasChildren, childCanvas ) end\
\9\9end\
\9end\
\9\
\9-- TODO: screen order changed events?\
\9-- for i, childView in ipairs( self.children ) do\
\9-- \9local onSiblingsChanged = childView.onSiblingsChanged\
\9-- \9if onSiblingsChanged then onSiblingsChanged( childView ) end\
\9-- end\
\
\9self.canvas.hasChanged = true\
\9frontView.canvas.hasChanged = true\
end\
\
--[[\
\9@instance\
\9@desc Moves the view to be the bottom of it's siblings\
\9@param [View] childView -- the view to make botom most\
]]\
function Container:sendToBack( childView )\
\9self:sendToFront( childView, 1 )\
end\
\
--[[\
\9@instance\
\9@desc Adds a child view to the container (on the top by default)\
\9@param [View] childView -- the view to add to the container\
\9@param [number] position -- the z-position of the child (top by default). higher number means further back\
\9@return [View] childView -- the sent child view\
]]\
function Container:insert( childView, position )\
\9if not childView:typeOf( View ) then\
\9\9error( \"Attempted to insert non-View to Container\", 4 )\
\9end\
\
\9log(\"insert \"..tostring(childView))\
\
\9local children = self.children\
\9if position then\
\9\9table.insert( children, position, childView )\
\9else\
\9\9children[#children + 1] = childView\
\9end\
\
\9local oldParent = childView.parent \
\9childView.parent = self\
\9self.canvas:insert( childView.canvas )\
\9-- we need to update the isEnabled value\
\9childView.isEnabled = childView.raw.isEnabled\
\
\9for i, _childView in ipairs( children ) do\
\9\9if _childView == childView then\
\9\9\9_childView.event:handleEvent( ParentChangedInterfaceEvent( self, oldParent ) )\
\9\9else\
\9\9\9_childView.event:handleEvent( SiblingAddedInterfaceEvent( childView ) )\
\9\9end\
\9end\
\
\9local view = self\
\9while view do\
\9\9for key, interfaceOutlet in pairs( view.interfaceOutlets ) do\
\9\9\9if interfaceOutlet:childAdded( childView, view == self ) then\
\9\9\9\9view = false\
\9\9\9\9break\
\9\9\9end\
\9\9end\
\9\9view = view and view.parent\
\9end\
\
\9self.event:handleEvent( ChildAddedInterfaceEvent( childView ) )\
\
\9return childView\
end\
\
--[[\
\9@instance\
\9@desc Removes the first instance of the child view from the container\
\9@param [View] childView -- the view to add to the container\
\9@return [boolean] didRemove -- whether a child was removed\
]]\
function Container:remove( removingView )\
\9local didRemove = false\
\
\9local children, canvas = self.children, self.canvas\
\9for i, childView in ipairs( children ) do\
\9\9if childView == removingView then\
\9\9\9canvas:remove( removingView.canvas )\
\9\9\9table.remove( children, i )\
\9\9\9didRemove = true\
\9\9\9break\
\9\9end\
\9end\
\
\9removingView.parent = false\
\
\9if didRemove then\
\9\9local view = self\
\9\9while view do\
\9\9\9for key, interfaceOutlet in pairs( view.interfaceOutlets ) do\
\9\9\9\9interfaceOutlet:childRemoved( removingView )\
\9\9\9end\
\9\9\9view = view.parent\
\9\9end\
\9end\
\
\9self.event:handleEvent( ChildRemovedInterfaceEvent( removingView ) )\
\
\9return didRemove\
end\
\
--[[\
\9@instance\
\9@desc Returns the ( first ) child with the given identifier\
\9@param [string] identifier -- the identifier of the child view\
\9@param [boolean] descendTree -- true by default. whether child Containers should be looked through\
\9@return [View] childView -- the found child view\
]]\
function Container:findChild( identifier, descendTree )\
\9descendTree = (descendTree == nil and true or descendTree)\
\9for i, childView in ipairs( self.children ) do\
\9\9if childView.identifier == identifier then\
\9\9\9return childView\
\9\9end\
\
\9\9-- look in child Containers \
\9\9if descendTree and childView:typeOf( Container ) then\
\9\9\9local child = childView:findChild( identifier )\
\9\9\9if child then\
\9\9\9\9return child\
\9\9\9end\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns all children with the given identifier\
\9@param [string] identifier -- the identifier of the child view\
\9@param [boolean] descendTree -- true by default. whether child Containers should be looked through\
\9@return [table] childrenViews -- the table of the found found children views\
]]\
function Container:findChildren( identifier, descendTree )\
\9descendTree = (descendTree == nil and true or descendTree)\
\9\
\9local children = {}\
\9for i, childView in ipairs( self.children ) do\
\9\9if childView.identifier == identifier then\
\9\9\9table.insert( children, childView )\
\9\9end\
\
\9\9-- look in child Containers \
\9\9if descendTree and childView:typeOf( Container ) then\
\9\9\9local childChildren = childView:findChildren( identifier )\
\9\9\9for i2, childChild in ipairs( childChildren ) do\
\9\9\9\9table.insert( children, childChild )\
\9\9\9end\
\9\9end\
\9end\
\9return children\
end\
\
function Container:dispose()\
\9self:super()\
\9for i, childView in ipairs( self.children ) do\
\9\9childView:dispose()\
\9end\
end",
  },
  WindowCanvas = {
    [ "text/lua" ] = "\
class \"WindowCanvas\" extends \"Canvas\" { }\
\
-- function WindowCanvas:drawTo( ... )\
--     if self.isVisible then\
--         local hasChanged = self.hasChanged\
--         self:super( ... )\
--         if hasChanged then\
--         \9self.\
--         end\
--     end\
--     return self\
-- end\
\
\
\
function WindowCanvas:draw( ... )\
    if self.isVisible then\
    \9self:super( ... )\
       \
    \9local y = self.height - 1\
    \9local width = self.width\
    \9local buffer = self.buffer\
    \9local transparent = Graphics.colours.TRANSPARENT\
    \9buffer[y * width + 1] = transparent\
    \9buffer[y * width + width] = transparent\
    end\
    return self\
end",
  },
  DownSymbol = {
    [ "text/lua" ] = "\
class \"DownSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"down\";\
\
    serialisedPaths = {\
        {\
            x = 1;\
            y = 1;\
            lines = {\
                {\
                    y1 = 1;\
                    x1 = 5;\
                    x2 = 5;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 5;\
                    x2 = 7;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 7;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 7;\
                };\
                {\
                    y1 = 7;\
                    x1 = 4;\
                    x2 = 1;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 1;\
                    x2 = 3;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 3;\
                    x2 = 3;\
                    mode = \"linear\";\
                    y2 = 1;\
                };\
                {\
                    y1 = 1;\
                    x1 = 3;\
                    x2 = 5;\
                    mode = \"linear\";\
                    y2 = 1;\
                };\
            };\
            height = 7;\
            width = 7;\
        }\
    }\
\
\
}",
  },
  IEditableFileSystemItem = {
    [ "text/lua" ] = "\
interface \"IEditableFileSystemItem\" {\
    \
    contents = false; -- the contents of the file\
\
}",
  },
  ProgressBar = {
    [ "text/lua" ] = "\
class \"ProgressBar\" extends \"View\" {\
    \
    height = 7;\
    width = 100;\
\
    isEnabled = true;\
    isIndeterminate = true;\
    cornerRadius = 4;\
    stripeWidth = 8;\
\
    value = 0.3;\
    maximum = 1;\
\
    backgroundObject = false;\
    stripesObject = false;\
\
}\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function ProgressBar:initialiseCanvas()\
    self:super()\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height, self.theme.fillColour, self.theme.outlineColour, self.theme.cornerRadius ) )\
    local stripesObject = self.canvas:insert( ProgressBarStripes( 1, 1, math.floor( ( self.value/self.maximum ) * self.width + 0.5 ), self.height, self.theme.barColour, self.theme.barColour, self.theme.stripeColour, self.theme.cornerRadius ) )\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( stripesObject, \"fillColour\", \"barColour\" )\
    self.theme:connect( stripesObject, \"outlineColour\", \"barColour\" )\
    self.theme:connect( stripesObject, \"stripeColour\" )\
    self.theme:connect( stripesObject, \"radiusLeft\", \"cornerRadius\" )\
\
    self.backgroundObject = backgroundObject\
    self.stripesObject = stripesObject\
end\
\
function ProgressBar:updateWidth( width )\
    self.backgroundObject.width = width\
    self.stripesObject.width = math.floor( ( self.value/self.maximum ) * width + 0.5 )\
end\
\
function ProgressBar:updateHeight( height )\
    self.backgroundObject.height = height\
    self.stripesObject.height = height\
end\
\
function ProgressBar.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
--[[\
    @instance\
    @desc Set the value of the progress bar\
    @param [number] value -- the value\
]]\
function ProgressBar.value:set( value )\
    self.value = math.min( math.max( value, 0 ), self.maximum )\
    self.stripesObject.width = math.floor( ( self.value / self.maximum ) * self.width + 0.5 )\
end\
\
--[[\
    @instance\
    @desc Set the maximum value of the progress bar\
    @param [number] maximum -- the maximum value\
]]\
function ProgressBar.maximum:set( maximum )\
    self.maximum = math.max( maximum, 0 )\
    self.stripesObject.width = math.floor( ( self.value / self.maximum ) * self.width + 0.5 )\
end\
\
--[[\
    @instance\
    @desc Fired on a screen update. Animates the stripes\
    @param [number] deltaTime -- the time since last update\
]]\
function ProgressBar:update( deltaTime )\
    if self.value > 0 or self.isIndeterminate then\
        self.stripesObject.animationStep = self.stripesObject.animationStep + deltaTime * 20\
    end\
end",
  },
  ActionInterfaceEvent = {
    [ "text/lua" ] = "\
class \"ActionInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_action\";\
    };\
\9sender = false; -- the view whose action it is\
}\
\
--[[\
\9@constructor\
\9@desc Creates a focus event from the arguments\
\9@param [View] sender -- the view whose action it is\
]]\
function ActionInterfaceEvent:initialise( sender )\
\9self.sender = sender\
end\
",
  },
  IDragDropDestination = {
    [ "text/lua" ] = "\
interface \"IDragDropDestination\" {\
    \
    dropStyle = false; -- [DragDropManager.dropStyles] the desired style for what should occur on drop (i.e. instantly disappear, animated shrink, etc.)\
\
}\
\
--[[\
    @instance\
    @desc Returns true if the destination is able to accept the given ClipboardData (if this returns true you MUST be able to accept it)\
    @param [ClipboardData] data -- the clipboard data\
    @return [boolean] canAccept\
]]\
function IDragDropDestination:canAcceptDragDrop( data )\
\
--[[\
    @instance\
    @desc Fired when a drag and drop view is dragged over your view. Update the view's apperance if desired\
    @param [ClipboardData] data -- the clipboard data\
]]\
function IDragDropDestination:dragDropEntered( data, dragView )\
\
--[[\
    @instance\
    @desc Fired when a drag and drop view is moved over your view (this is also fired after immediately :dragDropEntered). Update the view's apperance if desired\
    @param [ClipboardData] data -- the clipboard data\
]]\
function IDragDropDestination:dragDropMoved( data, dragView )\
\
--[[\
    @instance\
    @desc Fired when a drag and drop view is dragged over your view. Update the view's apperance if desired\
    @param [ClipboardData] data -- the clipboard data\
]]\
function IDragDropDestination:dragDropExited( data, dragView )\
\
--[[\
    @instance\
    @desc Fired when a drag and drop view is dropped on your view. Do NOT remove the drop apperance here, :dragDropExited is called immediately after.\
    @param [ClipboardData] data -- the incomming clipboard data\
]]\
function IDragDropDestination:dragDropDropped( data )",
  },
  Graphics = {
    [ "text/lua" ] = "\
class \"Graphics\" {\
\9\
\9colours = Enum( Number, {\
\9\9TRANSPARENT = 0;\
\9\9WHITE = colours.white;\
\9\9ORANGE = colours.orange;\
\9\9MAGENTA = colours.magenta;\
\9\9LIGHT_BLUE = colours.lightBlue;\
\9\9YELLOW = colours.yellow;\
\9\9LIME = colours.lime;\
\9\9PINK = colours.pink;\
\9\9GREY = colours.grey;\
\9\9LIGHT_GREY = colours.lightGrey;\
\9\9CYAN = colours.cyan;\
\9\9PURPLE = colours.purple;\
\9\9BLUE = colours.blue;\
\9\9BROWN = colours.brown;\
\9\9GREEN = colours.green;\
\9\9RED = colours.red;\
\9\9BLACK = colours.black;\
\
\9\9-- For those who can't spell.\
\9\9GRAY = colours.grey;\
\9\9LIGHT_GRAY = colours.lightGrey;\
\9} );\
\
}\
\
-- TODO: alias\
-- Graphics:alias( Graphics.colours, \"colors\" )",
  },
  MouseDragEvent = {
    [ "text/lua" ] = "\
class \"MouseDragEvent\" extends \"MouseEvent\" {\
    static = {\
        eventType = \"mouse_drag\";\
    };\
\9mouseButton = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseDragEvent:initialise( mouseButton, x, y )\
\9self.mouseButton = mouseButton\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end\
",
  },
  ToolbarButton = {
    [ "text/lua" ] = "\
class \"ToolbarButton\" extends \"Button\" implements \"IToolbarItem\" implements \"IToolbarPressableItem\" {}",
  },
  ParentChangedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"ParentChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_parent_changed\";\
    };\
\9newParent = false; -- the new parent\
\9oldParent = false; -- the old parent\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a siblings changed event from the arguments\
\9@param [Container] newParent -- the new parent view\
\9@param [Container] oldParent -- the old parent view\
]]\
function ParentChangedInterfaceEvent:initialise( newParent, oldParent )\
\9self.newParent = newParent\
\9self.oldParent = oldParent\
end",
  },
  InterfaceOutletChangedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"InterfaceOutletChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_outlet_changed\";\
    };\
\9interfaceOutlet = false;\
\9oldView = false;\
\9newView = false;\
\9isSentToChildren = false;\
\9isSentToSender = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a focus event from the arguments\
\9@param interfaceOutlet -- the interface outlet that changed\
\9@param newView -- the new view the outlet is bound to\
\9@param oldView -- the old view the outlet was bound to\
]]\
function InterfaceOutletChangedInterfaceEvent:initialise( interfaceOutlet, newView, oldView )\
\9self.interfaceOutlet = interfaceOutlet\
\9self.newView = newView\
\9self.oldView = oldView\
end",
  },
  DragDropManager = {
    [ "text/lua" ] = "\
local SHADOW_RATIO = 2/3\
local MAX_SHADOW_SIZE = 3\
\
class \"DragDropManager\" {\
    \
    owner = false;\
    dragView = false;\
    data = false;\
    relativeX = false;\
    relativeY = false;\
    destination = false;\
    didHideSource = false;\
    sourceViews = false;\
    completion = false;\
\
    dropStyles = Enum( Number, {\
        DISAPPEAR = 0;\
        SHRINK = 1;\
        RETURN = 2;\
    } )\
\
}\
\
--[[\
    @instance\
    @desc Creates a drag and drop manager\
    @param [Application] owner -- the manager owner\
]]\
function DragDropManager:initialise( owner )\
    self.owner = owner\
    owner:event( MouseDragEvent, self.onMouseDrag, nil, nil, self )\
    owner:event( MouseUpEvent, self.onMouseUp, nil, nil, self )\
end\
\
--[[\
    @instance\
    @desc Starts a drag and drop proccess\
    @param [Table{View}] views -- the view being dragged\
    @param [ClipboardData] data -- the data that will be given to the destination\
    @param [number] relativeX -- the x coordinate relative to view the mouse is located\
    @param [number] relativeY -- the x coordinate relative to view the mouse is located\
    @param [boolean] hideSource -- whether the source view should be hidden during dragging\
    @param [function] completion -- called when the drag and drop is cancelled or successful (destination view passed if dropped, nil if cancelled)\
]]\
function DragDropManager:start( views, data, relativeX, relativeY, hideSource, completion )\
    if not data or not data:typeOf( ClipboardData ) then\
        error( \"Drag and drop must provide a valid ClipboardData source.\", 4 )\
    end\
\
    local x, y, x2, y2 = self.owner.container.width, self.owner.container.height, 1, 1\
    local images = {}\
    for i, view in ipairs( views ) do\
        if not view:typeOf( IDraggableView ) then\
            error( \"Drag and drop can only be used on Views the implement IDraggableView.\", 4 )\
        end\
\
        local viewX, viewY = view:position()\
        local viewWidth, viewHeight = view.width, view.height\
        x = math.min( x, viewX )\
        y = math.min( y, viewY )\
        x2 = math.max( x2, viewX + viewWidth - 1 )\
        y2 = math.max( y2, viewY + viewHeight - 1 )\
        table.insert( images, { viewX, viewY, view.canvas:toImage(), view.canvas:toShadowImage() } )\
\
        if hideSource then\
            view.isVisible = false\
        end\
    end\
    local width, height = x2 - x + 1, y2 - y + 1\
\
    local image = Image.blank( width, height )\
    local shadowImage = Image.blank( width, height )\
    for i, imageData in ipairs( images ) do\
        local _x, _y = imageData[1] - x + 1, imageData[2] - y + 1\
        image:appendImage( imageData[3], _x, _y )\
        shadowImage:appendImage( imageData[4], _x, _y )\
    end\
\
    self:cancel()\
    local dragView = DragView( {\
            width = width + SHADOW_RATIO * MAX_SHADOW_SIZE;\
            height = height + MAX_SHADOW_SIZE;\
            x = x;\
            y = y;\
            image = image;\
            shadowImage = shadowImage;\
        } )\
    self.owner.container:insert( dragView )\
    self.dragView = dragView\
    self.data = data\
    self.relativeX = relativeX - x + 1\
    self.relativeY = relativeY - y + 1\
    self.didHideSource = hideSource or false\
    self.completion = completion or false\
    self.sourceViews = views\
\
    dragView:animate( \"shadowSize\", MAX_SHADOW_SIZE, 0.2, nil, Animation.easings.IN_SINE )\
end\
\
--[[\
    @instance\
    @desc Cancels the current drag and drop proccess, if one exists\
    @return [boolean] didCancel -- whether a proccess was canceled (i.e. returns true if one existed)\
]]\
function DragDropManager:cancel()\
    local dragView = self.dragView\
    if dragView then\
        local time, easing = 0.7, Animation.easings.OUT_SINE\
        local didHideSource, completion = self.didHideSource, self.completion\
\
        local sourceViews = self.sourceViews\
        local originalX, originalY = self.owner.container.width, self.owner.container.height\
        for i, view in ipairs( sourceViews ) do\
            local viewX, viewY = view:position()\
            originalX = math.min( originalX, viewX )\
            originalY = math.min( originalY, viewY )\
        end\
\
        dragView:animateX( originalX, time, function()\
            for i, view in ipairs( sourceViews ) do\
                if didHideSource then\
                    view.isVisible = true\
                end\
            end\
            dragView.parent:remove( dragView )\
            if completion then completion() end\
        end, easing )\
        dragView:animateY( originalY, time, nil, easing )\
        dragView:animate( \"shadowSize\", 0, time, nil, easing )\
        self.dragView = false\
    end\
end\
\
--[[\
    @instance\
    @desc Sets the destination, informing the new and old destinations if they've changed\
    @param [IDragDropDestination] destination\
]]\
function DragDropManager.destination:set( destination )\
    local oldDestination = self.destination\
    if oldDestination ~= destination then\
        if oldDestination then\
            oldDestination:dragDropExited( self.data, self.dragView )\
        end\
        if destination then\
            destination:dragDropEntered( self.data, self.dragView )\
        end\
        self.destination = destination\
    end\
    if destination then\
        destination:dragDropMoved( self.data, self.dragView )\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is dragged in the application\
    @param [MouseDragEvent] event -- the mouse dragged event\
    @return [boolean] shouldCancel -- whether other events handlers should not recieve this event\
]]\
function DragDropManager:onMouseDrag( Event event, Event.phases phase )\
    local dragView = self.dragView\
    if dragView then\
        dragView.x = event.x - self.relativeX + 1\
        dragView.y = event.y - self.relativeY + 1\
        self:updateDestination()\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released in the application\
    @param [MouseUpEvent] event -- the mouse up event\
    @return [boolean] shouldCancel -- whether other events handlers should not recieve this event\
]]\
function DragDropManager:onMouseUp( Event event, Event.phases phase )\
    local dragView = self.dragView\
    if dragView then\
        local destination = self.destination\
        if not destination then\
            self:cancel()\
            dragView.x = event.globalX - self.relativeX + 1\
            dragView.y = event.globalY - self.relativeY + 1\
        else\
            destination:dragDropDropped( self.data )\
            local dropStyle = destination.dropStyle\
            local dropStyles = self.dropStyles\
            local function done()\
                if self.didHideSource then\
                    for i, view in ipairs( self.sourceViews ) do\
                        view.isVisible = true\
                    end\
                end\
                dragView.parent:remove( dragView )\
                local completion = self.completion\
                if completion then completion( destination ) end\
            end\
            if dropStyle == dropStyles.SHRINK then\
                local time, easing = 0.5, Animation.easings.OUT_SINE\
                local x, y, width, height = dragView.x, dragView.y, dragView.width, dragView.height\
                dragView:animateWidth( 1, time, done, easing )\
                dragView:animateHeight( 1, time, nil, easing )\
                dragView:animateX( math.ceil( x + self.relativeX - 1 ), time, nil, easing )\
                dragView:animateY( math.ceil( y + self.relativeY - 1), time, nil, easing )\
                dragView.shadowObject.isVisible = false\
            elseif dropStyle == dropStyles.RETURN then\
                local time, easing = 0.5, Animation.easings.OUT_SINE\
                local originalX, originalY = self.owner.container.width, self.owner.container.height\
                for i, view in ipairs( self.sourceViews ) do\
                    local viewX, viewY = view:position()\
                    originalX = math.min( originalX, viewX )\
                    originalY = math.min( originalY, viewY )\
                end\
                dragView:animateX( originalX, time, done, easing )\
                dragView:animateY( originalY, time, nil, easing )\
                dragView:animate( \"shadowSize\", 0, time, nil, easing )\
            else\
                done()\
            end\
            self.dragView = false\
            self.destination = false\
        end\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Finds the lowest level (i.e. the view with most parents above it) view at the current view coordinates that accepts the drag\
]]\
function DragDropManager:updateDestination()\
    local dragView = self.dragView\
    if dragView then\
        local ownerContainer = self.owner.container\
        local data = self.data\
\
        local function lookInView( view, x, y )\
            if view:typeOf( Container ) then\
                local children = view.children\
                for i = #children, 1, -1 do\
                    local childView = children[i]\
                    if childView:hitTest( x, y ) then\
                        local destination = lookInView( childView, x - childView.x + 1, y - childView.y + 1 )\
                        if destination then\
                            return destination\
                        end\
                    end\
                end\
            end\
\
            if view:typeOf( IDragDropDestination ) and view:canAcceptDragDrop( data ) then\
                return view\
            end\
\
            return false\
        end\
\
        self.destination = lookInView( ownerContainer, dragView.x + self.relativeX - 1, dragView.y + self.relativeY - 1 )\
    else\
        self.destination = false\
    end\
end",
  },
  FileSystemItem = {
    [ "text/lua" ] = "\
local function tidy( path )\
    if type(path)==\"boolean\" then logtraceback() end\
    path = \"/\" .. path\
    return path\
        :gsub( \"/.-/%.%./\", \"/\" )\
        :gsub( \"^.-/%.%./\", \"\" )\
        :gsub( \"/%./\", \"/\" )\
        :gsub( \"^%.%./\", \"\" )\
        :gsub( \"^%.%.$\", \"\" )\
        :gsub( \"//+\", \"/\" )\
        -- :gsub( \"^[^/]\", \"/\" )\
        :gsub( \"/$\", \"\" )\
end\
\
class \"FileSystemItem\" {\
    \
    path = false;\
    name = false;\
    fullName = false;\
    extension = false;\
    icon = false;\
    size = false;\
    sizeString = false;\
    parent = false;\
    parentPath = false;\
    metadata = false;\
    metadataPath = false;\
\
}\
\
function FileSystemItem.metatable:__call( path, ... )\
    if fs.isDir( path ) then\
        return Folder( path, ... )\
    else\
        return File( path, ... )\
    end\
end\
\
function FileSystemItem:initialise( path, parent )\
    self.path = path\
    if parent then\
        self.raw.parent = parent\
    end\
end\
\
function FileSystemItem.path:set( path )\
    path = tidy( path )\
    if not fs.exists( path ) then error( \"Attempted to set FileSystemItem.path to non-existant path '\" .. path .. \"'.\", 2 ) end\
    self.path = path\
\
    local parentPath, fullName = path:match( \"(.*)/(.+)\" )\
    fullName = fullName or \"\"\
    self.fullName = fullName\
    self.raw.parentPath = parentPath\
    local name, extension = fullName:match( \"^(.+)%.(%w-)$\" )\
    self.name = name or fullName\
    self.extension = extension or false\
end\
\
function FileSystemItem.size:get()\
    return fs.getSize( self.path )\
end\
\
function FileSystemItem.size:set( size )\
    error( \"FileSystemItem.size is a read-only property.\", 2 )\
end\
\
function FileSystemItem.sizeString:get()\
    local size = fs.getSize( self.path )\
    if size == 0 then return \"0 B\" end\
    local prefixes = { [0] = \"\"; \"k\"; \"M\"; \"G\"; \"T\"; \"P\"; }\
    local order = math.floor( math.log( size ) / math.log( 1024 ) )\
    local bytes = math.ceil( (size / ( 1024 ^ order) ) * 100 )\
    return bytes / 100 .. \" \" .. prefixes[order] .. \"B\"\
end\
\
function FileSystemItem.sizeString:set( sizeString )\
    error( \"FileSystemItem.sizeString is a read-only property.\", 2 )\
end\
\
-- function FileSystemItem:{ Number, String }:doSomething( x, label )\
-- end\
\
function FileSystemItem.parent:get()\
    local parent = self.parent\
    if parent then return parent end\
    if self.path == \"\" then return false end\
\
    local parentPath = self.parentPath\
    return Folder( parentPath )\
end\
\
function FileSystemItem.parent:set( parent )\
    error( \"FileSystemItem.parent is a read-only property. To move a FileSystemItem use :moveTo\", 2 )\
end\
\
function FileSystemItem.parentPath:set( parentPath )\
    error( \"FileSystemItem.parentPath is a read-only property. To move a FileSystemItem use :moveTo\", 2 )\
end\
\
function FileSystemItem:delete()\
    fs.delete( self.path )\
    self.metadata:delete( folder )\
    self:dispose()\
end\
\
function FileSystemItem:moveTo( folder )\
    local folderPath = folder.path\
    if folderPath == self.parentPath then return end\
\
    local newPath = folderPath .. \"/\" .. self.fullName\
    fs.move( self.path, newPath )\
    self.metadata:moveTo( folder )\
    self.raw.parentPath = folderPath\
    self.raw.parent = false -- delete the cache of the old parent\
end\
\
function FileSystemItem:copyTo( folder )\
    local folderPath = folder.path\
    if folderPath == self.parentPath then return end\
    \
    local newPath = folderPath .. \"/\" .. self.fullName\
    fs.copy( self.path, newPath )\
    local newFile = FileSystemItem( newPath )\
    self.metadata:copyTo( folder, newFile )\
end\
\
function FileSystemItem:rename( fullName )\
    local newPath = self.parentPath .. \"/\" .. fullName\
    fs.move( self.path, newPath )\
    self.metadata:rename( fullName )\
end\
\
function FileSystemItem.metadataPath:get()\
    return self.parentPath .. \"/.metadata/\" ..self.fullName\
end\
\
function FileSystemItem.metadata:get()\
    local metadata = self.metadata\
    if metadata then return metadata end\
\
    metadata = Metadata( self )\
    self.raw.metadata = metadata\
    return metadata\
end\
\
function FileSystemItem.metadata:set( metadata )\
    error( \"FileSystemItem.metadata is a read-only property.\", 2 )\
end",
  },
  Metadata = {
    [ "text/lua" ] = "\
local DEFAULT_TIMESTAMP = 1417305600; -- default date 1/1/2015\
\
local SAVED_PROPERTIES = { t = \"mime\"; c = \"createdTimestamp\"; o = \"openedTimestamp\"; m = \"modifiedTimestamp\"; i = \"icon\"; }\
\
local g_tLuaKeywords = {\
    [ \"and\" ] = true,\
    [ \"break\" ] = true,\
    [ \"do\" ] = true,\
    [ \"else\" ] = true,\
    [ \"elseif\" ] = true,\
    [ \"end\" ] = true,\
    [ \"false\" ] = true,\
    [ \"for\" ] = true,\
    [ \"function\" ] = true,\
    [ \"if\" ] = true,\
    [ \"in\" ] = true,\
    [ \"local\" ] = true,\
    [ \"nil\" ] = true,\
    [ \"not\" ] = true,\
    [ \"or\" ] = true,\
    [ \"repeat\" ] = true,\
    [ \"return\" ] = true,\
    [ \"then\" ] = true,\
    [ \"true\" ] = true,\
    [ \"until\" ] = true,\
    [ \"while\" ] = true,\
}\
\
local function serialise( t, tTracking )\
    local sType = type(t)\
    if sType == \"table\" then\
        if tTracking[t] ~= nil then\
            error( \"Cannot serialize table with recursive entries\", 0 )\
        end\
        tTracking[t] = true\
\
        if next(t) == nil then\
            return \"{}\"\
        else\
            local sResult = \"{\"\
            local tSeen = {}\
            for k,v in ipairs(t) do\
                tSeen[k] = true\
                sResult = sResult .. serialise( v, tTracking ) .. \";\"\
            end\
            for k,v in pairs(t) do\
                if not tSeen[k] then\
                    local sEntry\
                    if type(k) == \"string\" and not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\
                        sEntry = k .. \"=\" .. serialise( v, tTracking ) .. \";\"\
                    else\
                        sEntry = \"[\" .. serialise( k, tTracking ) .. \"]=\" .. serialise( v, tTracking ) .. \";\"\
                    end\
                    sResult = sResult .. sEntry\
                end\
            end\
            sResult = sResult:sub( 1, #sResult - 1 ) .. \"}\"\
            return sResult\
        end\
    elseif sType == \"string\" then\
        return string.format( \"%q\", t )\
    elseif sType == \"number\" or sType == \"boolean\" or sType == \"nil\" then\
        return tostring(t)\
    else\
        error( \"Cannot serialize type \"..sType, 0 )\
    end\
end\
\
local EXTENSION_MIMES = {\
    LUA = \"text/lua\";\
    TXT = \"text/plain\";\
    TEXT = \"text/plain\";\
    IMAGE = \"image/paint\";\
    NFP = \"image/paint\";\
    NFT = \"image/nft\";\
    SKCH = \"image/sketch\";\
    SINTERFACE = \"silica/interface\";\
    STHEME = \"silica/theme\";\
    SCFG = \"silica/config\";\
    SFONT = \"silica/font\";\
    RESOURCEPKG = \"package/resource\";\
    PACKAGE = \"package/plain\";\
    APPLICATION = \"silica/application\";\
}\
\
class \"Metadata\" {\
    \
    file = false;\
    metadataPath = false;\
\
    mime = false; -- MIME mime of the file (e.g. image/nft)\
    createdTimestamp = DEFAULT_TIMESTAMP;\
    openedTimestamp = DEFAULT_TIMESTAMP;\
    modifiedTimestamp = DEFAULT_TIMESTAMP;\
    icon = false; -- by default, if this is empty it will get the default system icon for it. it allows for custom icons\
\
    mimes = Enum( String, EXTENSION_MIMES );\
\
}\
\
function Metadata:initialise( file )\
    self.file = file\
    self.metadataPath = file.metadataPath\
    self:load()\
end\
\
function Metadata:load()\
    local metadataPath = self.metadataPath\
    if fs.exists( metadataPath ) then\
        local h = fs.open( metadataPath, \"r\" )\
        if h then\
            local properties = textutils.unserialize( h.readAll() )\
            h.close()\
            local raw = self.raw\
            for key, value in pairs( properties ) do\
                local propertyName = SAVED_PROPERTIES[key]\
                if SAVED_PROPERTIES[key] then\
                    raw[propertyName] = value\
                end\
            end\
        end\
    else\
        local metadataFolderPath = self.file.parentPath .. \"/.metadata\"\
        if fs.exists( metadataFolderPath ) then\
            if not fs.isDir( metadataFolderPath ) then\
                fs.delete( metadataFolderPath )\
            end\
        else\
            log(\"make \"..metadataFolderPath)\
            fs.makeDir( metadataFolderPath )\
        end\
        self:create()\
    end\
end\
\
function Metadata:save()\
    local h = fs.open( self.metadataPath, \"w\" )\
    if h then\
        local properties = {}\
        for shortKey, key in pairs( SAVED_PROPERTIES ) do\
            local value = self[key]\
            if value then\
                properties[shortKey] = value\
            end\
        end\
        h.write( serialise( properties, {} ) )\
        h.close()\
    end\
end\
\
function Metadata:serialise( allowedProperties )\
    local properties = {}\
    for shortKey, key in pairs( SAVED_PROPERTIES ) do\
        local value = self[key]\
        if value and ( not allowedProperties or allowedProperties[key] ) then\
            properties[shortKey] = value\
        end\
    end\
    return properties\
end\
\
-- TODO: do function aliases work?\
Metadata:alias( Metadata.serialise, \"serialize\" )\
\
-- create metadata for the file based on it's content\
function Metadata:create()\
    self:updateCreatedTimestamp()\
    self:updateOpenedTimestamp()\
    self:updateModifiedTimestamp()\
    local file = self.file\
    local path = file.path\
    local extension = file.extension\
    if extension then\
        -- try to guess the MIME based on the extension\
        if not EXTENSION_MIMES[ extension:upper() ] then\
            error(extension:upper())\
        end\
        self.mime = EXTENSION_MIMES[ extension:upper() ] or \"unknown\"\
    elseif fs.isDir( path ) then\
        self.mime = \"folder\"\
    end\
    self:save()\
end\
\
function Metadata:delete()\
    fs.delete( self.metadataPath )\
    local oldParentMetadataPath = self.file.parentPath .. \"/.metadata\"\
    if #fs.list( oldParentMetadataPath ) == 0 then\
        fs.delete( oldParentMetadataPath )\
    end\
end\
\
function Metadata:moveTo( folder )\
    local folderMetadataFolderPath = folder.path .. \"/.metadata\"\
    if not fs.exists( folderMetadataFolderPath ) then\
        fs.makeDir( folderMetadataFolderPath )\
    elseif fs.isDir( folderMetadataFolderPath ) then\
        fs.delete( folderMetadataFolderPath )\
        fs.makeDir( folderMetadataFolderPath )\
    end\
    local newMetadataPath = folderMetadataFolderPath .. \"/\" .. self.file.fullName\
    fs.move( self.metadataPath, newMetadataPath )\
    self.metadataPath = newMetadataPath\
    local oldParentMetadataPath = self.file.parentPath .. \"/.metadata\"\
    if #fs.list( oldParentMetadataPath ) == 0 then\
        fs.delete( oldParentMetadataPath )\
    end\
end\
\
function Metadata:copyTo( folder, newFile )\
    local copyMetadataPath = folder.path .. \"/.metadata/\" .. self.file.fullName\
    fs.copy( self.metadataPath, copyMetadataPath )\
    newFile.metadata:updateModifiedTimestamp()\
end\
\
function Metadata:rename( fullName )\
    local newMetadataPath = self.file.parentPath .. \"/.metadata/\" .. fullName\
    fs.move( self.metadataPath, newMetadataPath )\
    self.metadataPath = newMetadataPath\
    self:updateModifiedTimestamp()\
end\
\
function Metadata:updateCreatedTimestamp()\
    self.createdTimestamp = os.time()\
end\
\
function Metadata:updateOpenedTimestamp()\
    self.openedTimestamp = os.time()\
end\
\
function Metadata:updateModifiedTimestamp()\
    self.modifiedTimestamp = os.time()\
end\
\
function Metadata.createdTimestamp:set( createdTimestamp )\
    self.createdTimestamp = createdTimestamp\
    self:save()\
end\
\
function Metadata.openedTimestamp:set( openedTimestamp )\
    self.openedTimestamp = openedTimestamp\
    self:save()\
end\
\
function Metadata.modifiedTimestamp:set( modifiedTimestamp )\
    self.modifiedTimestamp = modifiedTimestamp\
    self:save()\
end",
  },
  IFlowItem = {
    [ "text/lua" ] = "\
interface \"IFlowItem\" {\
\
    idealWidth = false;\
    minWidth = false;\
    maxWidth = false;\
    \
}",
  },
  ScrollContainer = {
    [ "text/lua" ] = "\
class \"ScrollContainer\" extends \"Container\" {\
\9\
}\
\
function ScrollContainer:updateHeight( height )\
    self.parent:updateContainerSize()\
end\
\
function ScrollContainer:updateWidth( width )\
    self.parent:updateContainerSize()\
end",
  },
  MenuChangedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"MenuChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_menu_changed\";\
    };\
\9isSentToChildren = false;\
}",
  },
  KeyboardShortcutManager = {
    [ "text/lua" ] = "\
local keyStrings = {\
\9nil,\9\"1\", \9\"2\", \9\"3\",\9\"4\",\
\9\"5\", \9\"6\", \9\"7\", \9\"8\", \9\"9\",\
\9\"0\", \9\"-\", \9\"=\", \9\"backspace\",\"tab\",\
\9\"q\", \9\"w\", \9\"e\", \9\"r\",\9\"t\",\
\9\"y\",\9\"u\",\9\"i\",\9\"o\",\9\"p\",\
\9\"(\",\9\")\",\9\"enter\",\"ctrl\",\"a\",\
\9\"s\",\9\"d\",\9\"f\",\9\"g\",\9\"h\",\
\9\"j\",\9\"k\",\9\"l\",\9\";\",\9\"'\",\
\9\"`\",\9\"shift\",\"\\\\\",\9\"z\",\9\"x\",\
\9\"c\",\9\"v\",\9\"b\",\9\"n\",\9\"m\",\
\9\",\",\9\".\",\9\"/\",\9\"shift\",nil,\
\9\"alt\",\9nil,\9nil,\9\"f1\",\9\"f2\",\
\9\"f3\",\9\"f4\",\9\"f5\",\9\"f6\",\9\"f7\",\
\9\"f8\",\9\"f9\",\9\"f10\",\9[87] = \"f11\",\
\9[88] = \"f12\",\9[153] = \"ctrl\",\
\9[199] = \"home\",\9[207] = \"end\",\
\9[184] = \"alt\",\9[200] = \"up\",\
\9[203] = \"left\",\9[205] = \"right\",\
\9[208] = \"down\",\9[211] = \"delete\",\9\9\9\9\
\9[219] = \"ctrl\",\9[220] = \"ctrl\",\9\9\9\9\
}\
\
local keySymbols = {\
\9-- TODO: tab, left, right, up down, delete\
\9backspace = string.char( 144 );\
\9enter = string.char( 157 );\
\9ctrl = string.char( 141 );\
\9shift = string.char( 129 );\
\9alt = string.char( 143 );\
}\
\
class \"KeyboardShortcutManager\" {\
\9keysDown = {};\
\9keysUpdates = {};\
\9owner = false;\
\9event = false;\
}\
\
function KeyboardShortcutManager:initialise( owner )\
\9self.owner = owner\
\9-- self.event = EventManager( self )\
\9-- self.event:connectGlobal( KeyDownEvent, self.onGlobalKeyDown )\
\9-- self.event:connectGlobal( KeyUpEvent, self.onGlobalKeyUp )\
end\
\
function KeyboardShortcutManager:onGlobalKeyDown( Event event, Event.phases phase )\
\9local keyString = event.keyString\
\9if keyString then\
\9\9self.keysDown[keyString] = true\
\9\9self.keysUpdates[keyString] = os.clock()\
\9\9self.owner:schedule( self.onKeyTimeout, 10, self, keyString )\
\9\9return self:sendEvent()\
\9end\
end\
\
function KeyboardShortcutManager:onGlobalKeyUp( Event event, Event.phases phase )\
\9local keyString = event.keyString\
\9self.keysDown[keyString] = nil\
\9self.keysUpdates[keyString] = os.clock()\
end\
\
function KeyboardShortcutManager:isKeyDown( keyString )\
\9return self.keysDown[keyString] == true\
end\
\
--[[\
\9@static\
\9@desc Returns the symbol for a keyString for places such as menus\
\9@return [string] keyString -- the string value of the key\
\9@return [string] symbol -- the symbol\
]]\
function KeyboardShortcutManager.static:symbol( keyString )\
\9return ( not keyString and \"\" or keySymbols[keyString] or keyString:upper() )\
end\
\
--[[\
\9@instance\
\9@desc Converts a keys API code to the common string value used throughout Silica\
\9@param [number] keyCode -- the numerical value of the key\
\9@return [string] keyString -- the string value of the key\
]]\
function KeyboardShortcutManager.static:convert( keyCode )\
\9return keyStrings[keyCode]\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the given key string is valid\
\9@param [string] keyString -- the string value of the key\
\9@return [boolean] isValid -- whether the key string is valid\
]]\
function KeyboardShortcutManager.static:isValid( keyString )\
\9if not keyString then return false end\
\9for i, _keyString in pairs( keyStrings ) do\
\9\9if _keyString == keyString then\
\9\9\9return true\
\9\9end\
\9end\
\9return false\
end\
\
--[[\
\9@instance\
\9@desc Send the keyboard shortcut event of the currently held keys\
]]\
function KeyboardShortcutManager:sendEvent()\
\9return self.owner.event:handleEvent( KeyboardShortcutEvent( self.keysDown ) )\
end\
\
--[[\
\9@instance\
\9@desc Fires 10 seconds after a key was pressed. If the key status hasn't changed it sets it to not be pressed.\
\9@param [string] keyString -- the key string\
]]\
function KeyboardShortcutManager:onKeyTimeout( keyString )\
\9if os.clock() - self.keysUpdates[keyString] >= 10 then\
\9\9self.keysDown[keyString] = nil\
\9\9self.keysUpdates[keyString] = os.clock()\
\9end\
end",
  },
  MinimiseWindowButton = {
    [ "text/lua" ] = "\
class \"MinimiseWindowButton\" extends \"WindowButton\" {}\
\
function MinimiseWindowButton:initialiseCanvas()\
\9self:super()\
\
\9local symbolObject = Path( 4, 4, 3, 1, 1, 1 )\
    symbolObject:lineTo( 3, 1 )\
    symbolObject:close( false )\
    self.theme:connect( symbolObject, \"outlineColour\", \"symbolColour\" )\
    self.symbolObject = self.canvas:insert( symbolObject )\
end\
\
function MinimiseWindowButton:onMouseUp( Event event, Event.phases phase )    \
    if self.window then\
        self.window:close()\
        return true\
    end\
end",
  },
  IToolbarItem = {
    [ "text/lua" ] = "\
interface \"IToolbarItem\" {}",
  },
  SymbolSegmentButton = {
    [ "text/lua" ] = "\
class \"SymbolSegmentButton\" extends \"SegmentButton\" {\
    \
    symbol = false;\
    symbolObject = false;\
\
}\
\
function SymbolSegmentButton:initialiseCanvas()\
    self:super()\
    local canvas = self.canvas\
    canvas:remove( self.textObject )\
    self.textObject = false\
    local symbolObject = canvas:insert( SymbolObject( 1 + self.leftMargin, 5, self.symbol ) )\
    self.theme:connect( symbolObject, \"fillColour\", \"symbolColour\" )\
    self.symbolObject = symbolObject\
end\
\
function SymbolSegmentButton.symbol:set( symbol )\
    if type( symbol ) == \"string\" then\
        symbol = Symbol.fromName( symbol )\
    end\
    self.symbol = symbol\
    self.symbolObject.symbol = symbol\
    self.needsAutosize = true\
end\
\
function SymbolSegmentButton:updateWidth( width )\
    self:super( width )\
    local leftMargin, rightMargin = self.leftMargin, self.rightMargin\
    self.symbolObject.x = self.isPressed and leftMargin + 2 or leftMargin + 1\
end\
\
function SymbolSegmentButton:onSiblingOrParentChanged( Event event, Event.phases phase )\
    self:super( event )\
    local isFirst = self.isFirst\
    local isLast = self.isLast \
    local symbolObject = self.symbolObject\
\
    -- symbolObject.x = \
end\
\
function SymbolSegmentButton:autosize()\
    local symbol = self.symbol\
    if symbol then\
        self.width = symbol.width + self.leftMargin + self.rightMargin + 1\
        self.height = symbol.height + 9\
    end\
    self.needsAutosize = false\
end\
\
function SymbolSegmentButton.isPressed:set( isPressed )\
    self:super( isPressed )\
    local symbolObject = self.symbolObject\
    symbolObject.x = isPressed and self.leftMargin + 2 or self.leftMargin + 1\
    symbolObject.y = isPressed and 6 or 5\
end",
  },
  ToolbarContainer = {
    [ "text/lua" ] = "\
local SIDE_MARGIN = 6\
local TOP_MARGIN = 5\
\
class \"ToolbarContainer\" extends \"Container\" {\
\
    needsLayoutUpdate = false;\
    separatorObject = false;\
\
}\
\
function ToolbarContainer:initialise( ... )\
    self:super( ... )\
\
    self:event( ChildAddedInterfaceEvent, self.onChildAdded )\
    self:event( ChildRemovedInterfaceEvent, self.onChildRemoved )\
end\
\
function ToolbarContainer:initialiseCanvas()\
    self:super()\
    local width, height, theme, canvas = self.width, self.height, self.theme, self.canvas\
    local separatorObject = canvas:insert( Separator( 1, 1, width, height ) )\
\
    theme:connect( separatorObject, \"fillColour\", \"separatorFillColour\" )\
    theme:connect( separatorObject, \"isDashed\", \"separatorIsDashed\" )\
    theme:connect( canvas, \"fillColour\" )\
\
    self.separatorObject = separatorObject\
end\
\
function ToolbarContainer:updateWidth( width )\
    -- self:updateLayout( true )\
    self.separatorObject.width = width\
end\
\
function ToolbarContainer:updateHeight( height )\
    self.separatorObject.y = height\
end\
\
function ToolbarContainer:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function ToolbarContainer:onChildAdded( Event event, Event.phases phase )\
    if not event.childView:typeOf( IToolbarItem ) then\
        error( \"Attempted to add view '\" .. tostring( event.childView ) .. \"' that does not implement IToolbarItem to '\" .. tostring( self ) .. \"'\", 0 )\
    end\
    self.needsLayoutUpdate = true\
end\
\
function ToolbarContainer:onChildRemoved( Event event, Event.phases phase )\
    self.needsLayoutUpdate = true\
end\
\
function ToolbarContainer:updateLayout( )\
    local children, width = self.children, self.width\
    local remainingWidth = width - 2 * SIDE_MARGIN + 1\
    local x = 1 + SIDE_MARGIN\
    local dynamicItems = 0\
    local items = {}\
\
    local contentHeight = 0\
\
    for i, childView in ipairs( children ) do\
        local isPressable = childView:typeOf( IToolbarPressableItem )\
        childView.y = 1 + TOP_MARGIN\
        contentHeight = math.max( childView.height - (isPressable and 1 or 0), contentHeight )\
\
        if childView:typeOf( ToolbarStaticSpace ) then\
            local childWidth = childView.width\
            remainingWidth = remainingWidth - childWidth\
            items[i] = { nil, childWidth }\
        elseif childView:typeOf( IToolbarDynamicItem ) then\
            dynamicItems = dynamicItems + 1\
            items[i] = { childView, nil, isPressable }\
            remainingWidth = remainingWidth - SIDE_MARGIN\
        else\
            local childWidth = childView.width\
            remainingWidth = remainingWidth - childWidth - SIDE_MARGIN\
            items[i] = { childView, childWidth, isPressable }\
        end\
    end\
\
    local dynamicWidth = (remainingWidth + SIDE_MARGIN) / dynamicItems\
    local passedFirstDynamic = false\
    for i, item in ipairs( items ) do\
        local childView, childWidth, isPressable = item[1], item[2], item[3]\
        if not childWidth then\
            if passedFirstDynamic then\
                childWidth = math.floor( dynamicWidth )\
            else\
                childWidth = math.ceil( dynamicWidth )\
                passedFirstDynamic = true\
            end\
        end\
        if childView then\
            childView.x = x\
            childView.width = childWidth\
        end\
        x = x + childWidth - (isPressable and 1 or 0) + ((not childView or (i < #items and not items[i + 1][1]) ) and 0 or SIDE_MARGIN)\
    end\
\
    self.height = contentHeight + 2 * TOP_MARGIN + 1 -- + 1 for separator\
\
    self.needsLayoutUpdate = false\
end",
  },
  SeparatorMenuItem = {
    [ "text/lua" ] = "\
class \"SeparatorMenuItem\" extends \"MenuItem\" {\
\9text = false;\
\
\9height = 3;\
\9width = 51;\
\
\9textColour = Graphics.colours.LIGHT_GREY;\
\
    pressedTextColour = Graphics.colours.WHITE;\
\
    disabledTextColour = Graphics.colours.LIGHT_GREY;\
\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function SeparatorMenuItem:initialise( ... )\
\9self.super:super( ... )\
end\
\
function SeparatorMenuItem:initialiseCanvas()\
\9self.super:super()\
    self.backgroundObject = self.canvas:insert( Separator( 5, 2, self.width - 8, 1 ) )\
end\
\
function SeparatorMenuItem.isPressed:set( isPressed )\
    self.isPressed = false\
end\
\
function SeparatorMenuItem:updateWidth( width )\
\9self.backgroundObject.width = width - 8\
end\
\
function SeparatorMenuItem:updateHeight( height )\
\9self.backgroundObject.height = 1\
end",
  },
  SymbolObject = {
    [ "text/lua" ] = "\
class \"SymbolObject\" extends \"Canvas\" {\
\
    symbol = false;\
    paths = {};\
\
}\
\
function SymbolObject:initialise( x, y, symbol )\
    if not symbol then\
        self:super( x, y, 1, 1 )\
        return\
    end\
    \
    if not symbol:typeOf( Symbol ) then\
        error( \"SymbolObject must be given a class that extends Symbol.\", 4 )\
    end\
    self:super( x, y, symbol.width, symbol.height )\
    self.symbol = symbol\
end\
\
function SymbolObject.symbol:set( symbol )\
    self.symbol = symbol\
    for i, child in ipairs( self.children ) do\
        self:remove( child )\
    end\
\
    self.width = symbol.width\
    self.height = symbol.height\
\
    local paths = self.paths\
    for i, serialisedPath in ipairs( symbol.serialisedPaths ) do\
        local path = Path.fromSerialisedPath( serialisedPath )\
        self:insert( path )\
        table.insert( paths, path )\
    end\
end\
\
function SymbolObject.fillColour:set( fillColour )\
    for i, path in ipairs( self.paths ) do\
        path.fillColour = fillColour\
    end\
end\
\
function SymbolObject.outlineColour:set( outlineColour )\
    for i, path in ipairs( self.paths ) do\
        path.outlineColour = outlineColour\
    end\
end\
\
function SymbolObject.outlineWidth:set( outlineWidth )\
    for i, path in ipairs( self.paths ) do\
        path.outlineWidth = outlineWidth\
    end\
end\
\
function SymbolObject.leftOutlineWidth:set( leftOutlineWidth )\
    for i, path in ipairs( self.paths ) do\
        path.leftOutlineWidth = leftOutlineWidth\
    end\
end\
\
function SymbolObject.rightOutlineWidth:set( rightOutlineWidth )\
    for i, path in ipairs( self.paths ) do\
        path.rightOutlineWidth = rightOutlineWidth\
    end\
end\
\
function SymbolObject.topOutlineWidth:set( topOutlineWidth )\
    for i, path in ipairs( self.paths ) do\
        path.topOutlineWidth = topOutlineWidth\
    end\
end\
\
function SymbolObject.bottomOutlineWidth:set( bottomOutlineWidth )\
    for i, path in ipairs( self.paths ) do\
        path.bottomOutlineWidth = bottomOutlineWidth\
    end\
end",
  },
  LoadedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"LoadedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_loaded\";\
    };\
}",
  },
  Menu = {
    [ "text/lua" ] = "\
local MENU_OWNER_LEFT_OFFSET = 5\
local MENU_OWNER_TOP_OFFSET = 9\
local MENU_CONTEXT_OFFSET = 5\
\
class \"Menu\" extends \"Container\" {\
-- TODO: prevent menu going out of the screen\
\9targetX = 1; -- the desired location of the menu. this is the originally set x value, the actual x value can change to prevent overflowing with the screen\
\9targetY = 1;\
\
\9isPressed = false;\
    isEnabled = true;\
    -- isVisible acts as the boolans of whether the menu is open or closed.\
\
\9isSingleShot = false; -- true if the menu should be removed and unlinked when closed (as opposed to simply hiding for reuse only)\
\9hitTestOwner = false; -- true if clicks should first be sent to the owner if they hit test (and it has one)\
\
\9topMargin = 3;\
\9bottomMargin = 5;\
\9shadowRightMargin = 1;\
\9shadowTopMargin = 2;\
\
    cornerRadius = 4;\
    isOpen = Boolean;\
\
    shadowObject = false;\
    backgroundObject = false;\
\
    width = 40;\
    height = 40;\
\
\9needsLayoutUpdate = false;\9\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function Menu:initialise( ... )\
\9self:super( ... )\
\
    self.event:connectGlobal( MouseDownEvent, self.onGlobalMouseDown, Event.phases.BEFORE )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Menu:initialiseCanvas()\
\9self:super()\
    local cornerRadius = self.cornerRadius\
    local shadowObject = self.canvas:insert( RoundedRectangle( 1 + self.shadowRightMargin, 1 + self.shadowTopMargin, self.width - 1, self.height - 2 ) )\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width - 1, self.height - 2 ) )\
\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( shadowObject, \"fillColour\", \"shadowColour\" )\
    self.theme:connect( shadowObject, \"radius\", \"cornerRadius\" )\
\
\9self.shadowObject = shadowObject\
\9self.backgroundObject = backgroundObject\
end\
\
--[[\
\9@instance\
\9@desc Show the menu as a context menu (sets it as a single shot)\
\9@param [View] owner -- the object that invoked the context menu (usually the thing right clicked)\
\9@param [number] x -- the x coordinate of the click (from event.x)\
\9@param [number] y -- the y coordinate of the click (from event.y)\
]]\
function Menu:showContext( owner, x, y )\
\9self.owner = owner\
\9self.isSingleShot = true\
\9self.x = x + owner.x - 1 - MENU_CONTEXT_OFFSET\
\9self.y = y + owner.y - 1 - MENU_CONTEXT_OFFSET\
\9if self.parent then\
        self.parent:removeChild( self )\
    end\
\9owner.parent:insert( self )\
\9self.isVisible = true\
end\
\
function Menu:updateHeight( height )\
    self.backgroundObject.height = height - self.shadowTopMargin\
    self.shadowObject.height = height - self.shadowTopMargin\
end\
\
function Menu:updateWidth( width )\
\9local _width = width - self.shadowRightMargin\
    self.backgroundObject.width = _width\
    self.shadowObject.width = _width\
\
\9local height = self.topMargin\
\9for i, childView in ipairs( self.children ) do\
\9\9childView.width = _width\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Updates the location and size of the menu as well as the location and size of the menu items\
]]\
function Menu:updateLayout()\
\9local width = self.owner and ( self.owner.menuMargin and self.owner.width + 2 * self.owner.menuMargin or 1 ) or 1\
\9local height = self.topMargin\
\9for i, childView in ipairs( self.children ) do\
\9\9width = math.max( width, childView.width )\
\9end\
\9width = width + (1 - width % 2) -- it must be an odd number (for the separators)\
\9-- TODO: target position\
\9\
\9local height = self.topMargin\
\9for i, childView in ipairs( self.children ) do\
\9\9childView.x = 1\
\9\9childView.y = height + 1\
\9\9height = height + childView.height\
\9end\
\9self.width = width + self.shadowRightMargin\
\9self.height = height + self.bottomMargin\
\9self.needsLayoutUpdate = false\
end\
\
function Menu:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function Menu.isVisible:set( isVisible )\
\9self:super( isVisible )\
\9if isVisible then\
\9\9self.needsLayoutUpdate = true\
\9end\
end\
\
function Menu:insert( ... )\
\9self:super( ... )\
\9self.needsLayoutUpdate = true\
end\
\
function Menu:removeChild( ... )\
\9self:super( ... )\
\9self.needsLayoutUpdate = true\
end\
\
--[[\
\9@instance\
\9@param [Event] -- the mouse down event\
\9@desc Closes the menu when somewhere other than the menu is clicked, otherwise handles the event\
]]\
function Menu:onGlobalMouseDown( Event event, Event.phases phase )\
\9if self.isVisible then\
\9\9if self.hitTestOwner and self.owner and self.owner:hitTestEvent( event ) then\
\9\9\9self.owner.event:handleEvent( event )\
\9\9\9return true\
\9\9elseif self:hitTestEvent( event ) then\
\9\9\9self.event:handleEvent( event )\
\9\9\9return true\
\9\9else\
\9\9\9self:close()\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Sets the open state of the menu\
\9@param [boolean] isOpen -- whether the menu should be open\
]]\
function Menu.isOpen:set( isOpen )\
\9if isOpen then\
\9\9self:open()\
\9else\
\9\9self:close()\
\9end\
end\
\
--[[\
\9@instance\
\9@desc The open state of the menu\
]]\
function Menu.isOpen:get()\
\9return self.isVisible\
end\
\
--[[\
\9@instance\
\9@desc Opens the menu if closed, or closes the menu if open\
]]\
function Menu:toggle()\
\9self.isOpen = not self.isOpen\
end\
\
--[[\
\9@instance\
\9@desc Open the menu, hiding it from the screen\
]]\
function Menu:open()\
\9self.isVisible = true\
\9if self.owner then\
\9\9self.owner.event:handleEvent( MenuChangedInterfaceEvent( self ) )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Closes the menu, hiding it from the screen\
]]\
function Menu:close()\
\9self.isVisible = false\
\9if self.owner then\
\9\9self.owner.event:handleEvent( MenuChangedInterfaceEvent( self ) )\
\9end\
\9if self.isSingleShot then\
\9\9self:dispose()\
\9end\
end",
  },
  Scrollbar = {
    [ "text/lua" ] = "\
class \"Scrollbar\" extends \"View\" {\
\9width = 7;\
    isHorizontal = false;\
\9scrollerObject = false;\
\9grabberObject = false;\
    dragPoint = false;\
    direction = false;\
    isPressed = false;\
}\
\
function Scrollbar:initialise( ... )\
\9self:super( ... )\
    -- self:event( MouseScrollEvent, self.onMouseScroll )\
    self:event( MouseDownEvent, self.onMouseDown )\
    self.event:connectGlobal( MouseDragEvent, self.onGlobalMouseDrag )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Scrollbar:initialiseCanvas()\
    self:super()\
\
    self.theme:connect( self.canvas, \"fillColour\" )\
\
    local scrollerObject = self.canvas:insert( RoundedRectangle( 2, 3, self.width - 2, 30 ) )\
    local grabberObject = self.canvas:insert( ScrollbarGrabber( 3, 3, self.width - 4, 30 ) )\
\
    self.theme:connect( scrollerObject, \"fillColour\", \"scrollerColour\" )\
    self.theme:connect( scrollerObject, \"outlineColour\" )\
    self.theme:connect( scrollerObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( grabberObject, \"fillColour\", \"grabberColour\" )\
\
    local position, size = self.scroller\
    -- local position, size = self:getScroller()\
    self.scrollerObject = scrollerObject\
    self.grabberObject = grabberObject\
end\
\
function Scrollbar:updateHeight( height )\
    self:getScroller()\
end\
\
function Scrollbar:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function Scrollbar.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function Scrollbar.isPressed:set( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Gets and updates the size and location of the scroller\
    @return [number] position -- the position of the scroller\
    @return [number] size -- the size of the scroller\
]]\
function Scrollbar:getScroller( dontSetPosition )\
    local parent = self.parent\
    if not parent then\
        return 0, self.direction == \"vertical\" and self.height or self.width\
    end\
\
    local trayMargin = 2\
    local traySize = self.height - 2 * trayMargin\
\
    local frameSize, contentSize, contentScroll\
    frameSize = parent.height\
    local container = parent.container\
    contentSize = container.height\
    contentScroll = - parent.offsetY\
\
\
    local barSize = math.max( math.floor( traySize * frameSize / contentSize ), 1 )\
    local barPosition = math.ceil( traySize * contentScroll / contentSize )\
\
    local scrollerObject = self.scrollerObject\
    local grabberObject = self.grabberObject\
    scrollerObject.height = barSize\
    grabberObject.height = barSize\
    if not dontSetPosition then\
        local y = 1 + trayMargin - barPosition\
        scrollerObject.y = y\
        grabberObject.y = y\
    end\
\
    return barPosition, barSize\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Scrollbar:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Scrollbar:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
        local position, size = self:getScroller( true )\
        self.dragPoint = event.y + position - 1\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is dragged anywhere on screen. Moves the window if dragging\
    @param [Event] event -- the mouse drag event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Scrollbar:onGlobalMouseDrag( Event event, Event.phases phase )\
    if self.isPressed and self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        local oldRelative = event.relativeView\
        event:makeRelative( self )\
\
        local position, size = self:getScroller( true )\
        local traySize\
        position = event.y - self.dragPoint\
        traySize = self.height\
\
        position = math.max( math.min( position, traySize - size ), 0 )\
        local parent = self.parent\
        -- parent.offsetY = math.floor( position / traySize * parent.container.height )\
        -- scrollTo\
        parent:scrollTo( math.floor( position / traySize * parent.container.height ) )\
      \
        event:makeRelative( oldRelative )\
    end\
end",
  },
  ApplicationContainer = {
    [ "text/lua" ] = "\
class \"ApplicationContainer\" extends \"Container\" {\
\9-- TODO: make this use a Constraint\
\9x = 1;\
\9y = 1;\
\9width = 320;\
\9height = 200;\
\9themeName = false;\
}\
\
--[[\
\9@constructo\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function ApplicationContainer:initialise( ... )\
\9if not self.themeName then\
\9\9self.themeName = \"default\"\
\9end\
\
\9self:super( ... )\
\
    self:event( MouseDownEvent, self.onMouseDownAfter, Event.phases.AFTER )\
end\
\
function ApplicationContainer:initialiseCanvas()\
\9local canvas = ScreenCanvas( self.x, self.y, self.width, self.height )\
    self.canvas = canvas\
    -- self.theme:connect( self.canvas, \"fillColour\" )\
end\
\
function ApplicationContainer.theme:set( theme )\
\9if type( theme ) == \"string\" then error( \"To the set the theme of an ApplicationContainer using a string, use the property 'themeName', rather than 'theme'. Most likely cause: you have use theme=\\\"\" .. theme .. \"\\\" in an interface file, rather than themeName=\\\"\" .. theme .. \"\\\"\", 0 ) end\
\9self.theme = theme\
end\
\
--[[\
\9@instance\
\9@desc Sets the container's theme based upon it's name\
\9@return [string] themeName -- the name of the theme\
]]\
function ApplicationContainer.themeName:set( themeName )\
\9local oldThemeName = self.themeName\
\9self.themeName = themeName\
\9Theme.static.active = Theme.static:named( themeName )\
\9self.application.event:handleEvent( ThemeChangedInterfaceEvent( themeName, oldThemeName ) )\
end\
\
function ApplicationContainer:draw()\
\9self.canvas:drawToTerminal()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released and doesn't hit anything else. Unfocuses the focused view, if any.\
    @param [MouseDownEvent] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function ApplicationContainer:onMouseDownAfter( Event event, Event.phases phase )\
\9local application = self.application\
\9\
\9if application:hasFocus() then\
\9\9for focus, v in pairs( application.focuses ) do\
\9\9\9 if focus.isFocusDismissable then\
\9\9\9 \9application:unfocus( focus )\
\9\9\9 end\
\9\9end\
\9end\
end\
\
function ApplicationContainer:dispose()\
\9self:super()\
\9self.application:clearFocus()\
end",
  },
  ToolbarDynamicSpace = {
    [ "text/lua" ] = "\
class \"ToolbarDynamicSpace\" extends \"View\" implements \"IToolbarItem\" implements \"IToolbarDynamicItem\" {}",
  },
  Resource = {
    [ "text/lua" ] = "\
-- TODO: thrown an error when there is an identically named file in a resource folder\
\
class \"Resource\" {\
\
\9file = false;\
\9contents = false;\
\
}\
\
--[[\
\9@constructor\
\9@desc Creates a resource class, allowing ease resolving and loading of files\
\9@param [string] match -- the name of the file without the extension\
    @param [Metatable.mimes/table{Metatable.mimes}] mimes -- a mime or table of mimes\
\9@param [string] category -- the category (folder, such as classes, interfaces) to look in\
\9@param [boolean] allowDirectories -- default false, whether directories are able to be matched\
]]\
function Resource:initialise( name, mimes, category, allowDirectories )\
\9if not name then error( \"Resource() requires a file name (without extension)\", 5 ) end\
\9if not mimes then error( \"Resource() requires a mime type (e.g. text/lua)\", 5 ) end\
\9if type( mimes ) == \"string\" then mimes = { mimes } end\
\9category = category or \"resources\"\
\9-- TODO: path tidying\
\9-- TODO: maybe do this backwards? so you can override files in other libraries\
\9-- search the resource tables\
\9local resourceTables = Application.static.resourceTables\
\9if #resourceTables > 0 then\
\9\9for i = 1, #resourceTables do\
\9\9\9local categoryFiles = resourceTables[i][category]\
\9\9\9if categoryFiles then\
\9\9\9\9local nameCategoryFiles = categoryFiles[name]\
\9\9\9\9if nameCategoryFiles then\
\9\9\9\9\9for i, mime in ipairs( mimes ) do\
\9\9\9\9\9\9local contents = nameCategoryFiles[mime]\
\9\9\9\9\9\9if contents and ( allowDirectories or type( contents ) ~= \"table\" ) then\
\9\9\9\9\9\9\9self.contents = contents\
\9\9\9\9\9\9\9return\
\9\9\9\9\9\9end\
\9\9\9\9\9end\
\9\9\9\9else\
\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9\
\9local file\
\9for i, folder in ipairs( Application.static.resourceFolders ) do\
\9\9file = folder:find( name, mimes )\
\9\9break\
\9end\
\9\
\9self.file = file or false\
\9if file then\
\9\9self.contents = file.contents\
\9else\
\9\9error('File not found: '..name..\" of mime \"..serialise(mimes))\
\9\9-- TODO: error, file not found\
\9end\
end",
  },
  TerminateEvent = {
    [ "text/lua" ] = "\
class \"TerminateEvent\" extends \"Event\" {\
    static = {\
        eventType = \"terminate\";\
    };\
}",
  },
  ListContainer = {
    [ "text/lua" ] = "\
local SIDE_MARGIN = 6\
local TOP_MARGIN = 5\
local BOTTOM_MARGIN = TOP_MARGIN\
\
class \"ListContainer\" extends \"ScrollContainer\" implements \"IDragDropDestination\" {\
    \
    needsLayoutUpdate = false;\
    isCanvasHitTested = false;\
    canRearrange = true;\
    dropStyle = DragDropManager.dropStyles.RETURN;\
    canTransferItems = false;\
\
}\
\
function ListContainer:initialise( ... )\
    self:super( ... )\
    self:event( ChildAddedInterfaceEvent, self.onChildAdded )\
    self:event( ChildRemovedInterfaceEvent, self.onChildRemoved )\
    self:event( ReadyInterfaceEvent, self.onReady )\
end\
\
function ListContainer:onReady( Event event, Event.phases phase )\
    self:updateLayout( true )\
end\
\
function ListContainer:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function ListContainer:onChildAdded( Event event, Event.phases phase )\
    if not event.childView:typeOf( ListItem ) then\
        error( \"Attempted to add view '\" .. tostring( event.childView ) .. \"' that does not extend ListItem to '\" .. tostring( self ) .. \"'\", 0 )\
    end\
    self.needsLayoutUpdate = true\
end\
\
function ListContainer:onChildRemoved( Event event, Event.phases phase )\
    self.needsLayoutUpdate = true\
end\
\
function ListContainer:updateLayout( dontAnimate )\
    local children, width = self.children, self.width\
    local y = TOP_MARGIN + 1\
\
    local time, easing = 0.5, Animation.easings.SINE_IN_OUT\
\
    for i, childView in ipairs( children ) do\
        if dontAnimate then\
            childView.y = y\
        else\
            childView:animateY( y, time, nil, easing )\
        end\
        childView.x = 1\
        childView.width = width\
        y = y + childView.height\
    end\
\
    self.height = y + BOTTOM_MARGIN\
\
    self.needsLayoutUpdate = false\
end\
\
function ListContainer:canAcceptDragDrop( data )\
    return data:typeOf( ListClipboardData ) and (self.canTransferItems or data.listItem.parent == self)\
end\
\
function ListContainer:dragDropMoved( data, dragView )\
    local _, selfY = self:position()\
    local listItem = data.listItem\
    local children = self.children\
    local index = math.max( math.min( math.floor( ( dragView.y - selfY - TOP_MARGIN - 1 ) / listItem.height + 1.5 ), #children), 1 )\
    if listItem.index ~= index then\
        listItem.index = index\
        self.needsLayoutUpdate = true\
    end\
end\
\
function ListContainer:dragDropEntered( data, dragView )\
end\
\
function ListContainer:dragDropExited( data, dragView )\
    -- self:animate( \"row\", 0, 0.3 )\
end\
\
function ListContainer:dragDropDropped( data )\
\
end\
",
  },
  InterfaceEvent = {
    [ "text/lua" ] = "\
class \"InterfaceEvent\" extends \"Event\" {\
\9owner = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates an interface event from the arguments\
\9@param [class] owner -- the owner view\
]]\
function InterfaceEvent:initialise( owner )\
\9self.owner = owner\
end",
  },
  MouseDownEvent = {
    [ "text/lua" ] = "\
class \"MouseDownEvent\" extends \"MouseEvent\" {\
    static = {\
        eventType = \"mouse_click\";\
    };\
\9mouseButton = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseDownEvent:initialise( mouseButton, x, y )\
\9self.mouseButton = mouseButton\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end",
  },
  KeyDownEvent = {
    [ "text/lua" ] = "\
class \"KeyDownEvent\" extends \"KeyEvent\" {\
    \
    isRepeat = Boolean;\
    \
    static = {\
        eventType = \"key\"\
    };\
\
}\
\
function KeyDownEvent:initialise( Number keyCode, Boolean isRepeat )\
    self:super( keyCode )\
    self.isRepeat = isRepeat\
end",
  },
  SearchSymbol = {
    [ "text/lua" ] = "\
class \"SearchSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"search\";\
\
    serialisedPaths = {\
        {\
            x = 1,\
            y = 1,\
            lines = {\
                {\
                    y1 = 9,\
                    x1 = 9,\
                    x2 = 6,\
                    mode = \"linear\",\
                    y2 = 6,\
                },\
                {\
                    y1 = 6,\
                    x1 = 6,\
                    x2 = 7,\
                    mode = \"linear\",\
                    y2 = 5,\
                },\
                {\
                    y1 = 5,\
                    x1 = 7,\
                    x2 = 7,\
                    mode = \"linear\",\
                    y2 = 3,\
                },\
                {\
                    y1 = 3,\
                    x1 = 7,\
                    x2 = 5,\
                    mode = \"linear\",\
                    y2 = 1,\
                },\
                {\
                    y1 = 1,\
                    x1 = 5,\
                    x2 = 3,\
                    mode = \"linear\",\
                    y2 = 1,\
                },\
                {\
                    y1 = 1,\
                    x1 = 3,\
                    x2 = 1,\
                    mode = \"linear\",\
                    y2 = 3,\
                },\
                {\
                    y1 = 3,\
                    x1 = 1,\
                    x2 = 1,\
                    mode = \"linear\",\
                    y2 = 5,\
                },\
                {\
                    y1 = 5,\
                    x1 = 1,\
                    x2 = 3,\
                    mode = \"linear\",\
                    y2 = 7,\
                },\
                {\
                    y1 = 7,\
                    x1 = 3,\
                    x2 = 5,\
                    mode = \"linear\",\
                    y2 = 7,\
                },\
                {\
                    y1 = 7,\
                    x1 = 5,\
                    x2 = 6,\
                    mode = \"linear\",\
                    y2 = 6,\
                },\
                {\
                    y1 = 6,\
                    x1 = 6,\
                    x2 = 9,\
                    mode = \"linear\",\
                    y2 = 9,\
                },\
            },\
            height = 9,\
            width = 9,\
        }\
    }\
\
\
}",
  },
  MaximiseWindowButton = {
    [ "text/lua" ] = "\
class \"MaximiseWindowButton\" extends \"WindowButton\" {}\
\
function MaximiseWindowButton:initialiseCanvas()\
\9self:super()\
\
\9local symbolObject = Path( 4, 3, 3, 3, 2, 1 )\
    symbolObject:lineTo( 2, 3 )\
    symbolObject:moveTo( 1, 2 )\
    symbolObject:lineTo( 3, 2 )\
    symbolObject:close( false )\
    self.theme:connect( symbolObject, \"outlineColour\", \"symbolColour\" )\
    self.symbolObject = self.canvas:insert( symbolObject )\
end\
\
function MaximiseWindowButton:onMouseUp( Event event, Event.phases phase )    \
    if self.window then\
        self.window:close()\
        return true\
    end\
end",
  },
  SymbolButton = {
    [ "text/lua" ] = "\
class \"SymbolButton\" extends \"Button\" {\
    \
    symbol = false;\
    symbolObject = false;\
\
}\
\
function SymbolButton:initialiseCanvas()\
    self:super()\
    local canvas = self.canvas\
    self.textObject.isVisible = false\
    local symbolObject = canvas:insert( SymbolObject( 1 + self.leftMargin, 5, self.symbol ) )\
    self.theme:connect( symbolObject, \"fillColour\", \"symbolColour\" )\
    self.symbolObject = symbolObject\
end\
\
function SymbolButton.symbol:set( symbol )\
    if type( symbol ) == \"string\" then\
        symbol = Symbol.fromName( symbol )\
    end\
    self.symbol = symbol\
    self.symbolObject.symbol = symbol\
    self.needsAutosize = true\
end\
\
function SymbolButton:autosize()\
    local symbol = self.symbol\
    if symbol then\
        self.width = symbol.width + self.leftMargin + self.rightMargin + 1\
        self.height = symbol.height + 9\
    end\
    self.needsAutosize = false\
end\
\
function SymbolButton.isPressed:set( isPressed )\
    self:super( isPressed )\
    local symbolObject = self.symbolObject\
    symbolObject.x = isPressed and self.leftMargin + 2 or self.leftMargin + 1\
    symbolObject.y = isPressed and 6 or 5\
end",
  },
  ToolbarSegmentContainer = {
    [ "text/lua" ] = "\
class \"ToolbarSegmentContainer\" extends \"SegmentContainer\" implements \"IToolbarItem\" implements \"IToolbarPressableItem\" {}",
  },
  FontWindowContainer = {
    [ "text/lua" ] = "\
class \"FontWindowContainer\" extends \"WindowContainer\" {\
\9backgroundObject = false;\
}\
\
function FontWindowContainer:initialiseCanvas()\
\9self.canvas = FontWindowCanvas( self.x, self.y, self.width, self.height )\
\9self.backgroundObject = self.canvas:insert( Rectangle( 1, 1, self.width, self.height, Graphics.colours.WHITE ) )\
end",
  },
  RoundedRectangle = {
    [ "text/lua" ] = "\
-- draws a corner with the given radius for the corner given\
local function corner( fill, width, height, radius, position ) -- position is a byte. first bit is 0 if top, second bit is 0 if left\
\9if radius <= 0 then return end\
\9\
\9local minDistance = radius\
\9radius = radius + 0.5 -- doing this seems to magically make them look much better\
\
\9local centerX = (bit.band( position, 2 ) == 0) and radius or width - radius + 1\
\9local centerY = (bit.band( position, 1 ) == 0) and radius or height - radius + 1\
\9local minX = (bit.band( position, 2 ) == 0) and 1 or width - minDistance + 1\
\9local minY = (bit.band( position, 1 ) == 0) and 1 or height - minDistance + 1\
\
\9for x = minX, minX + radius - 1 do\
\9\9fill[x] = fill[x] or {}\
\9\9local xDistance = ( x - centerX ) ^ 2\
\9\9for y = minY, minY + radius - 1 do\
\9\9\9local distance = ( xDistance + ( y - centerY) ^ 2 ) ^ 0.5\
\9\9\9if distance <= minDistance then\
\9\9\9\9fill[x][y] = true\
\9\9\9end\
\9\9end\
\9end\
end\
\
class \"RoundedRectangle\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.RED;\
\9radius = false;\
\9leftRadius = false;\
\9rightRadius = false;\
\9topRadius = false;\
\9bottomRadius = false;\
\9topLeftRadius = 1;\
\9topRightRadius = 1;\
\9bottomLeftRadius = 1;\
\9bottomRightRadius = 1;\
}\
\
--[[\
\9@static\
\9@desc Creates a rounded rectangle\
\9@param [number] x -- the x coordinate of the rectangle\
\9@param [number] y -- the y coordinate of the rectangle\
\9@param [number] width -- the width of the rectangle\
\9@param [number] height -- the height of the rectangle\
\9@param [number] topLeftRadius -- the radius of the corners. of the top of the next parameter is defined, or top left if all 4 are\
\9@param [number] topRightRadius -- the radius of the bottom corners or top right if all 4 are\
\9@param [number] bottomLeftRadius -- the radius of the bottom left corner\
\9@param [number] bottomRightRadius -- the radius of the bottom right corner\
]]\
function RoundedRectangle:initialise( x, y, width, height, fillColour, outlineColour, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius )\
\9self:super( x, y, width, height )\
\9self.fillColour = fillColour or Graphics.colours.TRANSPARENT\
\9self.outlineColour = outlineColour or Graphics.colours.TRANSPARENT\
\9topLeftRadius = topLeftRadius or 0\
\9self.topLeftRadius = topLeftRadius\
\9self.topRightRadius = topRightRadius or topLeftRadius\
\9self.bottomLeftRadius = bottomLeftRadius or topRightRadius or topLeftRadius\
\9self.bottomRightRadius = bottomRightRadius or bottomLeftRadius or topRightRadius or topLeftRadius\
end\
\
--[[\
\9@instance\
\9@desc Sets the radius of both sides\
\9@param [number] radius -- the new radius\
\9@return [type] returnedValue -- description\
]]\
function RoundedRectangle.radius:set( radius )\
\9self.topLeftRadius = radius\
\9self.topRightRadius = radius\
\9self.bottomLeftRadius = radius\
\9self.bottomRightRadius = radius\
end\
\
function RoundedRectangle.topLeftRadius:set( topLeftRadius )\
\9if topLeftRadius then self.topLeftRadius = math.floor( topLeftRadius ) end\
end\
\
function RoundedRectangle.topRightRadius:set( topRightRadius )\
\9if topRightRadius then self.topRightRadius = math.floor( topRightRadius ) end\
end\
\
function RoundedRectangle.bottomLeftRadius:set( bottomLeftRadius )\
\9if bottomLeftRadius then self.bottomLeftRadius = math.floor( bottomLeftRadius ) end\
end\
\
function RoundedRectangle.bottomRightRadius:set( bottomRightRadius )\
\9if bottomRightRadius then self.bottomRightRadius = math.floor( bottomRightRadius ) end\
end\
\
function RoundedRectangle.leftRadius:set( leftRadius )\
\9if leftRadius then\
\9\9self.bottomLeftRadius = math.floor( leftRadius )\
\9\9self.topLeftRadius = math.floor( leftRadius )\
\9end\
end\
\
function RoundedRectangle.rightRadius:set( rightRadius )\
\9if rightRadius then\
\9\9self.bottomRightRadius = math.floor( rightRadius )\
\9\9self.topRightRadius = math.floor( rightRadius )\
\9end\
end\
\
function RoundedRectangle.topRadius:set( topRadius )\
\9if topRadius then\
\9\9self.topLeftRadius = math.floor( topRadius )\
\9\9self.topRightRadius = math.floor( topRadius )\
\9end\
end\
\
function RoundedRectangle.bottomRadius:set( bottomRadius )\
\9if bottomRadius then\
\9\9self.bottomLeftRadius = math.floor( bottomRadius )\
\9\9self.bottomRightRadius = math.floor( bottomRadius )\
\9end\
end\
\
function RoundedRectangle.radius:get()\
\9return math.max( self.topLeftRadius, self.topRightRadius, self.bottomLeftRadius, self.bottomRightRadius )\
end\
\
function RoundedRectangle.leftRadius:get()\
\9return math.max( self.topLeftRadius, self.bottomLeftRadius )\
end\
\
function RoundedRectangle.rightRadius:get()\
\9return math.max( self.topRightRadius, self.bottomRightRadius )\
end\
\
function RoundedRectangle.topRadius:get()\
\9return math.max( self.topLeftRadius, self.topRightRadius )\
end\
\
function RoundedRectangle.bottomRadius:get()\
\9return math.max( self.bottomLeftRadius, self.bottomRightRadius )\
end\
\
\
--[[\
    @instance\
    @desc Gets the pixels to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function RoundedRectangle.fill:get()\
\9if self.fill then return self.fill end\
\9local fill = {}\
\
\9local topLeftRadius = self.topLeftRadius\
\9local topRightRadius = self.topRightRadius\
\9local bottomLeftRadius = self.bottomLeftRadius\
\9local bottomRightRadius = self.bottomRightRadius\
\
\9local width, height = self.width, self.height\
\
\9corner( fill, width, height, topLeftRadius, 0 )\
\9corner( fill, width, height, topRightRadius, 2 )\
\9corner( fill, width, height, bottomLeftRadius, 1 )\
\9corner( fill, width, height, bottomRightRadius, 3 )\
\
\9local maxTopRadius = math.max( topLeftRadius, topRightRadius )\
\9for x = topLeftRadius, self.width - topRightRadius do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = 1, maxTopRadius do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9local maxBottomRadius = math.max( bottomLeftRadius, bottomRightRadius )\
\9for x = bottomLeftRadius, self.width - bottomRightRadius do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = self.height - maxBottomRadius + 1, self.height do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9for x = 1, self.width do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = maxTopRadius + 1, self.height - maxBottomRadius do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9self.fill = fill\
\9return fill\
end",
  },
  SeparatorView = {
    [ "text/lua" ] = "\
class \"SeparatorView\" extends \"View\" {\
\
    separatorObject = false;\
\
}\
\
function SeparatorView:initialiseCanvas()\
    self:super()\
    local theme = self.theme\
    local separatorObject = self.canvas:insert( Separator( 1, 1, self.width, self.height ) )\
\
    theme:connect( separatorObject, \"fillColour\", \"fillColour\" )\
    theme:connect( separatorObject, \"isDashed\" )\
\
    self.separatorObject = separatorObject\
end\
\
function SeparatorView:updateWidth( width )\
    self.separatorObject.width = width\
end\
\
function SeparatorView:updateHeight( height )\
    self.separatorObject.height = height\
end",
  },
  Rectangle = {
    [ "text/lua" ] = "\
class \"Rectangle\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.LIGHT_GREY;\
}\
\
 -- @constructor( number x, number y, number width, number height, graphics.fillColour fillColour )\
function Rectangle:initialise( x, y, width, height, fillColour )\
\9self:super( x, y, width, height )\
\9self.fillColour = fillColour or false\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Rectangle.fill:get()\
\9if self.fill then return self.fill end\
\
\9local fill = {}\
\9local height = self.height\
\9for x = 1, self.width do\
\9\9local fillX = {}\
\9\9for y = 1, height do\
\9\9\9fillX[y] = true\
\9\9end\
\9\9fill[x] = fillX\
\9end\
\
\9self.fill = fill\
\9return fill\
end",
  },
  SettingsSymbol = {
    [ "text/lua" ] = "\
class \"SettingsSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"settings\";\
\
    width = 6;\
\
    serialisedPaths = {\
        {\
            x = 1,\
            y = 1,\
            lines = {\
                {\
                    y1 = 1,\
                    x1 = 2,\
                    x2 = 2,\
                    mode = \"linear\",\
                    y2 = 4,\
                },\
                {\
                    y1 = 4,\
                    x1 = 2,\
                    x2 = 5,\
                    mode = \"linear\",\
                    y2 = 4,\
                },\
                {\
                    y1 = 4,\
                    x1 = 5,\
                    x2 = 5,\
                    mode = \"linear\",\
                    y2 = 1,\
                },\
                {\
                    y1 = 1,\
                    x1 = 5,\
                    x2 = 6,\
                    mode = \"linear\",\
                    y2 = 2,\
                },\
                {\
                    y1 = 2,\
                    x1 = 6,\
                    x2 = 6,\
                    mode = \"linear\",\
                    y2 = 3,\
                },\
                {\
                    y1 = 3,\
                    x1 = 6,\
                    x2 = 4,\
                    mode = \"linear\",\
                    y2 = 5,\
                },\
                {\
                    y1 = 5,\
                    x1 = 4,\
                    x2 = 4,\
                    mode = \"linear\",\
                    y2 = 7,\
                },\
                {\
                    y1 = 7,\
                    x1 = 4,\
                    x2 = 3,\
                    mode = \"linear\",\
                    y2 = 7,\
                },\
                {\
                    y1 = 7,\
                    x1 = 3,\
                    x2 = 3,\
                    mode = \"linear\",\
                    y2 = 5,\
                },\
                {\
                    y1 = 5,\
                    x1 = 3,\
                    x2 = 1,\
                    mode = \"linear\",\
                    y2 = 3,\
                },\
                {\
                    y1 = 3,\
                    x1 = 1,\
                    x2 = 1,\
                    mode = \"linear\",\
                    y2 = 2,\
                },\
                {\
                    y1 = 2,\
                    x1 = 1,\
                    x2 = 2,\
                    mode = \"linear\",\
                    y2 = 1,\
                },\
            },\
            height = 7,\
            width = 6,\
        }\
    }\
\
\
}",
  },
  ListItem = {
    [ "text/lua" ] = "\
local SIDE_MARGIN = 7\
local TOP_BOTTOM_PADDING = 2\
\
class \"ListItem\" extends \"View\" implements \"IDraggableView\" {\
    \
    height = 12;\
    isSelected = false;\
    isCanvasHitTested = false;\
\
    backgroundObject = false;\
    textObject = false;\
    text = false;\
\
}\
\
function ListItem:initialise( ... )\
    self:super( ... )\
\
    self:event( MouseDownEvent, self.onMouseDown )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
    self:event( MouseHeldEvent, self.onMouseHeld )\
end\
\
function ListItem:initialiseCanvas()\
    self:super()\
    local width, height, canvas = self.width, self.height, self.canvas\
    local backgroundObject = canvas:insert( RoundedRectangle( 2, 1, width - 2, height ) )\
    local textObject = canvas:insert( Text( 1 + SIDE_MARGIN, 1 + TOP_BOTTOM_PADDING, 8, width - 2 * SIDE_MARGIN, self.text ) )\
\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( textObject, \"textColour\" )\
\
    self.backgroundObject = backgroundObject\
    self.textObject = textObject\
end\
\
function ListItem:updateWidth( width )\
    self.backgroundObject.width = width - 2\
end\
\
function ListItem.text:set( text )\
    self.text = text\
    self.textObject.text = text\
end\
\
function ListItem:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isSelected and \"selected\" or \"default\" ) or \"disabled\"\
end\
\
function ListItem.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function ListItem.isSelected:set( isSelected )\
    self.isSelected = isSelected\
    self:updateThemeStyle()\
end\
\
function ListItem:onMouseHeld( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT and self.parent.canRearrange then\
        self.isSelected = true\
        self:startDragDrop( event, ListClipboardData( self ), true, function()self.isSelected = false end )\
    end\
    return true\
end\
\
function ListItem:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isSelected and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isSelected = false\
        if self.isEnabled and self:hitTestEvent( event ) then\
            self.event:handleEvent( ActionInterfaceEvent( self ) )\
            local result = self.event:handleEvent( event )\
            return result == nil and true or result\
        end\
        return true\
    end\
end\
\
function ListItem:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isSelected = not self.isSelected\
    end\
    return true\
end",
  },
  ScrollbarGrabber = {
    [ "text/lua" ] = "\
class \"ScrollbarGrabber\" extends \"GraphicsObject\" {\
\9lines = 4;\
}\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function ScrollbarGrabber.fill:get()\
\9local height = self.height\
\9local width = self.width\
\9local lines = self.lines\
\
\9local fill = {}\
\9local startY = math.ceil( ( height - 2 * lines + 1 ) / 2 )\
\9for x = 1, width do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = startY, startY + 2 * lines - 1, 2 do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9return fill\
end",
  },
  Circle = {
    [ "text/lua" ] = "\
class \"Circle\" extends \"GraphicsObject\" {\
\9diameter = Number( 1 );\
}\
\
--[[\
\9@static\
\9@desc Creates a cricle \
\9@param [number] x -- the x coordinate of the circle\
\9@param [number] y -- the y coordinate of the circle\
\9@param [number] diameter -- the diameter of the circle\
]]\
function Circle:initialise( x, y, diameter )\
\9self:super( x, y, diameter, diameter )\
end\
\
--[[\
\9@instance\
\9@desc Sets the diamater of the circle\
\9@param [number] diameter -- the diameter of the circle\
]]\
function Circle.diameter:set( diameter )\
\9self.width = diameter\
\9self.height = diameter\
end\
\
--[[\
\9@instance\
\9@desc Gets the diameter of the circle\
\9@return [number] diameter -- the diameter\
]]\
function Circle.diameter:get()\
\9return self.height\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Circle.fill:get()\
\9-- TODO: why was this commented out?\
\9if self.fill then return self.fill end\
\
\9local fill = {}\
\9local r = math.min( self.width, self.height ) / 2\
\9if r % 1 ~= 0 then\
\9\9r = r - 0.25\
\9end\
\9local radius = ( math.min( self.width, self.height ) + 1 ) / 2\
\9for y = 1, self.height do\
\9\9local ySqrd = ( y - radius )^2\
\9\9for x = 1, self.width do\
\9\9\9-- TODO: could probably make this faster by only square rooting once per y\
     \9\9local distance = ( ySqrd + ( x - radius )^2 )^0.5\
\9\9\9if distance <= r then\
\9\9\9\9fill[x] = fill[x] or {}\
\9\9\9\9fill[x][y] = true\
\9\9\9end\
\9\9end\
\9end\
\9return fill\
end",
  },
  MenuBarItem = {
    [ "text/lua" ] = "\
local TEXT_MARGIN = 12\
\
class \"MenuBarItem\" extends \"View\" {\
\
\9height = 12;\
    isPressed = false;\
    isEnabled = true;\
\9isCanvasHitTested = false;\
    text = false;\
    font = false;\
    backgroundObject = false;\
    menu = false;\
    menuName = false;\
    isFlashing = false;\
    isActive = Boolean; -- TODO: readonly\
\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a menu item instance\
\9@param [table] properties -- the properties for the view\
]]\
function MenuBarItem:initialise( ... )\
\9self:super( ... )\
\
    local menuName = self.menuName\
    if not menuName then error( \"MenuBarItems must specify the property menuName (the name of the interface file to use).\", 0 ) end\
    menu = Menu.fromInterface( menuName, Menu )\
    menu.owner = self\
    menu.isSingleShot = false\
    menu.isVisible = false\
    menu.hitTestOwner = true\
    menu.topMargin = Menu.topMargin + 4\
    self.menu = menu\
    self:event( MenuChangedInterfaceEvent, self.onMenuChanged )\
    self:event( MouseDownEvent, self.onMouseDown )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
    self:event( ReadyInterfaceEvent, self.onInterfaceReady )\
end\
\
function MenuBarItem:onInterfaceReady( Event event, Event.phases phase )\
    local menu = self.menu\
    if menu then\
        menu = self.menu\
        if menu.parent then\
            menu.parent:removeChild( menu )\
        end\
        local parent = self.parent\
        if parent then\
            menu.x = self.x + parent.x - 6\
            menu.y = self.y + parent.y + 7\
            local parentParent = parent.parent\
            if parentParent then\
                parentParent:insert( menu )\
            end\
        end\
    end\
end\
\
function MenuBarItem:initialiseCanvas()\
    self:super()\
    local backgroundObject = self.canvas:insert( Rectangle( 1, 1, self.width, self.height, self.fillColour ) )\
    local textObject = self.canvas:insert( Text( TEXT_MARGIN / 2 + 1, 3, self.height, self.width - TEXT_MARGIN, self.text ) )\
\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( textObject, \"textColour\" )\
\
    self.backgroundObject = backgroundObject\
    self.textObject = textObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
function MenuBarItem.font:set( font )\
    self.font = font\
    local textObject = self.textObject\
    if textObject then\
        local fontWidth = self.font:getWidth( text )\
        self.width = fontWidth + TEXT_MARGIN\
        self.textObject.font = font\
        local parent = self.parent\
        if parent then\
            parent.needsLayoutUpdate = true\
        end\
    end\
end\
\
function MenuBarItem.text:set( text )\
    self.text = text\
    local textObject = self.textObject\
    if textObject then\
        local fontWidth = self.font:getWidth( text )\
        self.width = fontWidth + TEXT_MARGIN\
        self.textObject.text = text\
        local parent = self.parent\
        if parent then\
            parent.needsLayoutUpdate = true\
        end\
    end\
end\
\
function MenuBarItem:updateX( x )\
    local menu = self.menu\
    if menu then\
        menu.x = self.x + ( parent and parent.x or 0 ) -- 4\
    end\
end\
\
function MenuBarItem:updateY( y )\
    local menu = self.menu\
    if menu then\
        menu.y = self.y + ( parent and parent.y or 0 ) + 7\
    end\
end\
\
function MenuBarItem:updateWidth( width )\
    self.backgroundObject.width = width\
    self.textObject.width = width - TEXT_MARGIN\
end\
\
function MenuBarItem:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function MenuBarItem:update( deltaTime )\
    self:super( deltaTime )\
    local isFlashing = self.isFlashing\
    if isFlashing then\
        if isFlashing <= 0 then\
            self.isFlashing = false\
        else\
            self.isFlashing = isFlashing - deltaTime\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Make the menu bar item flash for a brief period of time\
]]\
function MenuBarItem:flash()\
    self.isFlashing = 0.2\
end\
\
function MenuBarItem.isFlashing:set( isFlashing )\
    self.isFlashing = isFlashing\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Whether the button is pressed or open\
    @return [boolean] isActive -- whether the button is active\
]]\
function MenuBarItem.isActive:get()\
    return self.isPressed or self.isFlashing or self.menu.isOpen\
end\
\
function MenuBarItem:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isActive and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function MenuBarItem.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function MenuBarItem.isPressed:set( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Toggles the menu if it hit tests.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuBarItem:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isEnabled and self.isPressed then\
        self.isPressed = false\
        if self:hitTestEvent( event ) then\
            self.menu:toggle()\
            return self.event:handleEvent( event )\
        end\
    end\
end\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuBarItem:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the owned menu opens or closes\
    @param [Event] event -- the menu changed event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuBarItem:onMenuChanged( Event event, Event.phases phase )\
    self:updateThemeStyle()\
    \
    local menu = self.menu\
    if menu.isOpen then\
        menu.parent:sendToFront( menu )\
        menu.parent:sendToFront( self.parent )\
    end\
    return true\
end",
  },
  ReadyInterfaceEvent = {
    [ "text/lua" ] = "\
class \"ReadyInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_ready\";\
    };\
\9isInit = false; -- whether the event is the first one called in Application:initialise\
}\
\
--[[\
\9@constructor\
\9@desc Creates a ready event from the arguments\
\9@param isInit -- whether the event is the first one called in Application:initialise\
]]\
function ReadyInterfaceEvent:initialise( isInit )\
\9self.isInit = isInit or false\
end\
",
  },
  VectorFont = {
    [ "text/lua" ] = "\
class \"VectorFont\" extends \"Font\" {\
\9\
}",
  },
  Event = {
    [ "text/lua" ] = "\
local eventClasses = {}\
\
class \"Event\" {\
\9\
\9eventType = false;\
\
\9static = {\
\9\9eventType = false;\
\9};\
\
\9relativeView = false; -- the view that the event is relative of\
    sender = false;\
\
\9isSentToChildren = true; -- whether the event will be passed to children\
\9isSentToSender = true; -- whether the event will be handled by the sender\
\
\9-- functions can be called either before or after tickle down\
\9phases = Enum( Number, {\
\9\9BEFORE = 1;\
\9\9AFTER = 2;\
\9} );\
}\
\
--[[\
\9@static\
\9@desc Registers an Event subclass to a event type name (e.g. MouseDownEvent links with \"mouse_down\")\
\9@param [class] _class -- the class that was constructed\
]]\
function Event.static:register( eventType, subclass )\
\9eventClasses[eventType] = subclass\
end\
\
--[[\
\9@static\
\9@desc Registers an Event subclass after it has just been constructed\
]]\
function Event.static:initialise()\
\9local eventType = self.eventType\
\9if eventType then\
\9\9Event.static:register( self.eventType, self.class )\
\9end\
end\
\
--[[\
\9@static\
\9@desc Creates an event with the arguments in a table from os.pullEvent or similar function\
\9@param [Event.eventTypes] eventType -- the event type\
\9@param ... -- the event arguments\
\9@return [Event] event\
]]\
function Event.static:create( eventType, ... )\
\9if not eventType then error( \"No event type given to Event.create!\", 0 ) end\
\
\9local eventClass = eventClasses[eventType]\
\9local event\
\9if eventClass then\
\9\9event = eventClass( ... )\
\9else\
\9\9event = Event()\
\9end\
\9event.eventType = eventType\
\9return event\
end\
\
--[[\
\9@instance\
\9@desc Make the event relative to the supplied view\
\9@param [View] view -- the view to be relative to\
]]\
function Event:makeRelative( view )\
\9self.relativeView = view\
end",
  },
  TimerEvent = {
    [ "text/lua" ] = "\
class \"TimerEvent\" extends \"Event\" {\
    static = {\
        eventType = \"timer\";\
    };\
\9timer = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a timer event from the arguments\
\9@param [number] time -- the ID of the timer\
]]\
function TimerEvent:initialise( timer )\
\9self.timer = timer\
end",
  },
  class = {
    [ "text/lua" ] = "\
-- Class Construction --\
\
class = {\
    folders = {};\
    tables = {};\
}\
\
local classes, interfaces = {}, {}\
local valueTypes = {}\
local compiledClassDetails, compiledInstances, compiledStatics = {}, {}, {}\
local currentlyConstructing, expectedName -- the class that is currently being constructed\
local constructingEnvironment, constructorProxy, constructingFunctionArguments, currentCompiledClass\
local stripFunctionArguments, loadProperties, compileClass, loadPropertiesTableSection, checkValue, constructSuper, isInterface\
local allLockedGetters, allLockedSetters = {}, {}\
local isLoadingProperties\
local interface\
\
local application -- the running application\
\
local TYPETABLE_NAME, TYPETABLE_TYPE, TYPETABLE_CLASS, TYPETABLE_ALLOWS_NIL, TYPETABLE_IS_VAR_ARG, TYPETABLE_IS_ENUM, TYPETABLE_ENUM_ITEM_TYPE, TYPETABLE_HAS_DEFAULT_VALUE, TYPETABLE_DEFAULT_VALUE = 1, 2, 3, 4, 5, 6, 7, 8, 9\
local FUNCTIONTABLE_FUNCTION = 1\
\
local RESERVED_NAMES = { super = true, static = true, metatable = true, class = true, raw = true, application = true, className = true, typeOf = true, isDefined = true, isDefinedProperty = true, isDefinedFunction = true }\
\
-- Create the value types --\
\
local valueTypeUID = {} -- just a unique identifier to indicate that this is a valueType\
function createValueType( name, typeStr, classType, destinationKey, destination )\
    destination = destination or valueTypes\
    destinationKey = destinationKey or name\
    classType = classType or false\
    local valueType = {\
        valueTypeUID;\
        [TYPETABLE_TYPE] = typeStr;\
        [TYPETABLE_CLASS] = classType;\
        [TYPETABLE_ALLOWS_NIL] = false;\
        [TYPETABLE_IS_VAR_ARG] = false;\
        [TYPETABLE_IS_ENUM] = false;\
        [TYPETABLE_ENUM_ITEM_TYPE] = false;\
        [TYPETABLE_HAS_DEFAULT_VALUE] = false;\
    }\
\
    local metatable = {}\
    function metatable:__call( ... )\
        local valueInstance = {\
            valueTypeUID;\
            [TYPETABLE_TYPE] = typeStr;\
            [TYPETABLE_CLASS] = classType;\
            [TYPETABLE_ALLOWS_NIL] = false;\
            [TYPETABLE_IS_VAR_ARG] = false;\
            [TYPETABLE_IS_ENUM] = false;\
            [TYPETABLE_ENUM_ITEM_TYPE] = false;\
            [TYPETABLE_HAS_DEFAULT_VALUE] = true;\
        }\
        local args = { ... }\
        if not classType then\
            if #args >= 2 then\
                error( \"non-class types are only allowed 1 argument, the default value\" , 2 )\
            end\
            valueInstance[TYPETABLE_DEFAULT_VALUE] = checkValue( args[1], valueInstance ) -- check the default value actually complies with the type if it's not a class (class default values are parsed as arguments)\
        else\
            for i, v in ipairs( args ) do\
                valueInstance[TYPETABLE_DEFAULT_VALUE + i - 1] = v\
            end\
        end\
\
        local metatable = {}\
        function metatable:__index( k )\
            if k == \"allowsNil\" then\
                valueInstance[TYPETABLE_ALLOWS_NIL] = true\
                return valueInstance\
            elseif type( k ) ~= \"number\" then -- if it's a number it would've been trying to get a default value, don't error\
                error( \"tried to index '\" .. k .. \"', types only support .allowsNil\" , 2 )\
            end\
        end\
\
        function metatable:__newindex( k )\
            error(\"attempt to set property of valueType\", 2 )\
        end\
\
        local __tostring = \"value type instance (w. default) '\" .. name .. \"': \" ..  tostring( valueInstance ):sub( 8 )\
        function metatable:__tostring() return __tostring end\
        setmetatable( valueInstance, metatable )\
\
        return valueInstance\
    end\
\
    function metatable:__index( k )\
        if k == \"allowsNil\" then\
            valueType[TYPETABLE_ALLOWS_NIL] = true -- this sets it for the type everywhere, we then MUST reset it once we've accessed it\
            return valueType\
        elseif type( k ) ~= \"number\" then -- if it's a number it would've been trying to get a default value, don't error\
            error( \"tried to index '\" .. k .. \"', types only support .allowsNil\", 2 )\
        end\
    end\
\
    function metatable:__newindex( k )\
        error(\"attempt to set property of valueType\", 2 )\
    end\
\
    local __tostring = \"value type '\" .. name .. \"': \" ..  tostring( valueType ):sub( 8 )\
    function metatable:__tostring() return __tostring end\
    setmetatable( valueType, metatable )\
\
    rawset( destination, destinationKey, valueType ) -- if it's a enum of a class we need to set it on the class value type\
    return valueType\
end\
\
createValueType( \"Any\", false )\
createValueType( \"String\", \"string\" )\
createValueType( \"Boolean\", \"boolean\" )\
createValueType( \"Number\", \"number\" )\
createValueType( \"Table\", \"table\" )\
createValueType( \"Function\", \"function\" )\
createValueType( \"Thread\", \"thread\" )\
-- createValueType( \"Class\", \"table\" ) -- TODO: \
\
-- Create Enum Value type\
 \
local function createEnumType()\
    local metatable = {}\
    local valueType = {\
        valueTypeUID;\
        [TYPETABLE_TYPE] = \"table\";\
        [TYPETABLE_CLASS] = false;\
        [TYPETABLE_ALLOWS_NIL] = false;\
        [TYPETABLE_IS_VAR_ARG] = false;\
        [TYPETABLE_IS_ENUM] = true;\
        [TYPETABLE_ENUM_ITEM_TYPE] = false;\
        [TYPETABLE_HAS_DEFAULT_VALUE] = false;\
    }\
    function metatable:__call( ... )\
        local valueInstance = {\
            valueTypeUID;\
            [TYPETABLE_TYPE] = \"table\";\
            [TYPETABLE_CLASS] = false;\
            [TYPETABLE_ALLOWS_NIL] = false;\
            [TYPETABLE_IS_VAR_ARG] = false;\
            [TYPETABLE_IS_ENUM] = true;\
            [TYPETABLE_HAS_DEFAULT_VALUE] = true;\
        }\
        local args = { ... }\
        if #args ~= 2 then\
            error( \"enums only support 2 arguments: valueType, table\" , 2 )\
        end\
        local itemValueType = args[1]\
        if type( itemValueType ) ~= \"table\" or itemValueType[1] ~= valueTypeUID or itemValueType[TYPETABLE_HAS_DEFAULT_VALUE] then\
            error( \"1st argument must be ValueType without a default value\" , 2 )\
        end\
        local values = args[2]\
        if not type( value ) == \"table\" then\
            error( \"2nd argument must be table\" , 2 )\
        end\
        valueInstance[TYPETABLE_ENUM_ITEM_TYPE] = itemValueType\
\
        for k, v in pairs( values ) do\
            if type( func ) == \"function\" then\
                error( \"function enum values must not be defined in properties table\" , 2 )\
            end\
            if not type( k ) == \"string\" or not k:match( \"^[_%u]+$\" ) then\
                error( \"Enum keys must be all uppercase with _\" , 2 )\
            end\
\
            checkValue( v, itemValueType ) -- check that the default values comply with the required type\
        end\
\
        valueInstance[TYPETABLE_DEFAULT_VALUE] = values\
\
        local metatable = {}\
        function metatable:__index( k )\
            error( \"Enum does not support .allowsNil or indexing other properties\" , 2 )\
        end\
\
        function metatable:__newindex( k, v )\
            error( \"attempt to change enum valuetype\" , 2 )\
        end\
\
        local __tostring = \"value type instance (w. default & item type) 'Enum': \" ..  tostring( valueInstance ):sub( 8 )\
        function metatable:__tostring() return __tostring end\
        setmetatable( valueInstance, metatable )\
\
        return valueInstance\
    end\
\
    function metatable:__index( k )\
        error( \"Enum does not support .allowsNil or other properties\" , 2 )\
    end\
\
    function metatable:__newindex( k )\
        error(\"attempt to set property of Enum\", 2 )\
    end\
\
    local __tostring = \"value type 'Enum': \" ..  tostring( valueType ):sub( 8 )\
    function metatable:__tostring() return __tostring end\
    setmetatable( valueType, metatable )\
\
    valueTypes[\"Enum\"] = valueType\
end\
createEnumType()\
\
-- Create the class loading methods --\
\
function class.get( name )\
    return classes[name] or interfaces[name] or class.load( name )\
end\
\
function class.exists( name )\
    for i, tbl in ipairs( class.tables ) do\
        local f = tbl[name]\
        if f then\
            local g = f[\"text/lua\"]\
            if g then return g end\
        end\
    end\
\
    for i, folder in ipairs( class.folders ) do\
        local f = folder:find( name, Metadata.mimes.LUA )\
        if f then\
            return f.contents\
        end\
    end\
end\
\
function class.load( name, contents )\
    if classes[name] or interfaces[name] then\
        error( \"class already loaded: \"..name)\
    end\
    local oldConstructing, oldEnvironment, oldConstructorProxy, oldIsLoadingProperties, oldConstructingFunctionArguments, oldCurrentCompiled, oldIsInterface, oldExpectedName = currentlyConstructing, constructingEnvironment, constructorProxy, isLoadingProperties, constructingFunctionArguments, currentCompiledClass, isInterface, expectedName\
    isLoadingProperties = false\
    currentlyConstructing = nil\
\
    expectedName = name\
    constructingFunctionArguments = {}\
    constructingEnvironment = { class = class, extends = extends, interface = interface, implements = implements }\
\
    local compiledClass = {}\
    createValueType( name, \"table\", compiledClass ) -- generate the value type for this class. the future table for the compiled class is used, which will be filled later\
    currentCompiledClass = compiledClass\
\
    -- TODO: load classes if we index _G with their name and they return nil. only allow self if it is within the static table\
    local metatable = {}\
\
    function metatable:__index( key )\
        local globalValue = _G[key]\
        if globalValue then return globalValue end\
        -- if the value is nil see if we can find a class with that name and load it\
        if class.exists( key ) then\
            -- there should be a class with that name, load it\
            local _class = class.load( key )\
            -- if we're loading properties we want to return its valueType\
            if isLoadingProperties then\
                return valueTypes[key]\
            else\
                return _class\
            end\
        end\
    end\
\
    setmetatable( constructingEnvironment, metatable )\
\
    local func, err = loadstring( stripFunctionArguments( name, contents ), name )\
    if not func then\
        error( \"could not parse \" .. name .. \": \".. err )\
    else\
        setfenv( func, constructingEnvironment )\
        func()\
    end\
\
\
    if not currentlyConstructing then\
        error( \"expected a class/interface to be defined but it wasn't in file \"..name )\
    end\
\
    compileClass( compiledClass, name )\
    local wasInterface = isInterface\
    constructingEnvironment, currentlyConstructing, constructorProxy, isLoadingProperties, constructingFunctionArguments, currentCompiledClass, isInterface, expectedName = oldEnvironment, oldConstructing, oldConstructorProxy, oldIsLoadingProperties, oldConstructingFunctionArguments, oldCurrentCompiled, oldIsInterface, oldExpectedName\
    return wasInterface and interfaces[name] or classes[name]\
end\
\
function class.setApplication( newApplication )\
    application = newApplication\
end\
\
-- Start loading the class and get the argument types from the functions --\
\
function lines(str)\
  local t = {}\
  local function helper(line) table.insert(t, line) return \"\" end\
  helper((str:gsub(\"(.-)\\r?\\n\", helper)))\
  return t\
end\
\
local function loadClassLines( name, contents )\
    local file = contents or class.exists( name )\
    if not file then\
        error( \"Unable to find class \" .. name )\
    end\
    local lines = lines( file, \"\\n\" )\
    return lines\
end\
\
function stripFunctionArguments( name, contents )\
    local classString = \"\"\
    local foundTypeDeclaration = false\
    for n, line in ipairs( loadClassLines( name, contents ) ) do\
        if not foundTypeDeclaration then\
            if line:match( \"^%s*class%s*\\\"%w*\\\"\" ) then\
                isInterface = false\
                foundTypeDeclaration = true\
            elseif line:match( \"^%s*interface%s*\\\"%w*\\\"\" ) then\
                isInterface = true\
                foundTypeDeclaration = true\
            end\
        elseif line:sub( 1, 9 ) == \"function \" then\
            -- get the components from the function declaration\
            local isEnum = false\
            local firstLevel, secondLevel, functionName, arguments = line:match( \"^function \" .. name .. \"%.([_%w]+)%.([_%w]+):([_%w]+)%s*%((.*)%)%s*$\" )\
            if not firstLevel then\
                firstLevel, functionName, arguments = line:match( \"^function \" .. name .. \"%.([_%w]+):([_%w]+)%s*%((.*)%)%s*$\" )\
                if not firstLevel then\
                    firstLevel, functionName, arguments = line:match( \"^function \" .. name .. \"%.([_%w]+)%.([_%w]+)%s*%((.*)%)%s*$\" ) -- for enums function\
                    if not firstLevel then\
                        functionName, arguments = line:match( \"^function \" .. name .. \":([_%w]+)%s*%((.*)%)%s*$\" )\
                        if not functionName or not arguments then\
                            error(name..\": \"..n..\": function malformed\", 2 )\
                        end\
                    else\
                        isEnum = true\
                    end\
                end\
            end\
\
            local valueTypeExtractionEnvironment = {}\
            local metatable = {}\
            function metatable:__index( key )\
                local globalValue = valueTypes[key]\
                if globalValue then return globalValue end\
                -- if we're loading properties and the value is nil, see if we can find a class with that name and load it\
                if class.exists( key ) then\
                    -- there should be a class with that name, load it\
                    class.load( key )\
                    -- now we want to return its valueType\
                    return valueTypes[key]\
                else\
                    error( \"attempt to access undelcared value \" .. key .. \" in value type declaration \", 2 )\
                end\
            end\
            setmetatable( valueTypeExtractionEnvironment, metatable )\
\
            local previousI, i = 1, 1\
            local argumentsTable, argumentSubstringPoints = {}, {}\
            local argumentsString = \"\"\
            if not arguments:match(\"^%s*$\") then -- ignore empty brackets\
                -- get the arguments and types from the brackets\
                local openedBrackets = 0\
                for i = 1, #arguments do\
                    local char = arguments:sub( i, i )\
                    if char == \"(\" then\
                        openedBrackets = openedBrackets + 1\
                    elseif char == \")\" then\
                        openedBrackets = openedBrackets - 1\
                    elseif char == \",\" and openedBrackets == 0 then -- if this is a command separating \
                        table.insert( argumentSubstringPoints, { previousI, i - 1 } )\
                        previousI = i + 1\
                    end                \
                end\
                table.insert( argumentSubstringPoints, { previousI,} )\
                local argumentSubstringPointsLength = #argumentSubstringPoints\
                for i, points in ipairs( argumentSubstringPoints ) do\
                    local argument = arguments:sub( points[1], points[2] )\
                    local typeTable, type, argumentName\
                    local isVarArg = false\
                    if i == argumentSubstringPointsLength then\
                        type, argumentName = argument:match( \"^(.-)(%.%.%.)%s*$\" )\
                        if argumentName then\
                            isVarArg = true\
                        end\
                    end\
                    if not isVarArg then\
                        type, argumentName = argument:match( \"^(.-)([_%w]+)%s*$\" )\
                        if not type or not argumentName then\
                            error( name .. \": \" .. n .. \": argument formatting wrong\", 0 )\
                        end\
                    end\
\
                    -- extract the variable type from the argument declaration\
                    if not type or type:match(\"^%s*$\") then\
                        -- type wasn't given\
                        -- this is just a plain variable, we make it an Any( value ).allowsNil with the default being its default value. this acts identical to default Lua behaviour\
                        typeTable = {\
                            [TYPETABLE_NAME] = argumentName;\
                            [TYPETABLE_TYPE] = false;\
                            [TYPETABLE_CLASS] = false;\
                            [TYPETABLE_ALLOWS_NIL] = true;\
                            [TYPETABLE_IS_VAR_ARG] = isVarArg;\
                            [TYPETABLE_IS_ENUM] = false;\
                            [TYPETABLE_ENUM_ITEM_TYPE] = false;\
                            [TYPETABLE_HAS_DEFAULT_VALUE] = true;\
                            [TYPETABLE_DEFAULT_VALUE] = nil;\
                        }\
                    else\
                        local func = loadstring( \"return \" .. type, name )\
                        if not func then\
                            error(\"argument did bad: \" .. name .. \": \" .. n)\
                        end\
                        setfenv( func, valueTypeExtractionEnvironment )\
                        value = func()\
\
                        if not value then\
                            error( \"error extracting value type from \" .. type )\
                        elseif value[TYPETABLE_HAS_DEFAULT_VALUE] then -- this was created like String(), not String, so it created its own instance. hence we can use the value directly\
                            value[TYPETABLE_NAME] = argumentName\
                            typeTable = value\
                        else\
                            -- this is the actual valueType table, we can't use it. we need to make a copy AND set allowsNil back to false as it may have been changed\
                            typeTable = {\
                                [TYPETABLE_NAME] = argumentName;\
                            }\
\
                            for i = TYPETABLE_TYPE, #value do\
                                typeTable[i] = value[i]\
                            end\
\
                            rawset( value, \"allowsNil\", false )\
                        end\
                        typeTable[TYPETABLE_IS_VAR_ARG] = isVarArg;\
                    end\
                    table.insert( argumentsTable, typeTable )  \
                    argumentsString = argumentsString .. argumentName .. \",\"\
                end\
            end\
\
\
            argumentsString = argumentsString:sub(1, #argumentsString - 1) -- remove the trailing comma\
\
            local replacementLine = \"function \" .. name\
            -- store the types\
            if firstLevel then\
                replacementLine = replacementLine .. \".\" .. firstLevel\
                local firstLevelTable = constructingFunctionArguments[firstLevel]\
                if not firstLevelTable then\
                    firstLevelTable = {}\
                    constructingFunctionArguments[firstLevel] = firstLevelTable\
                end\
\
                if not isEnum and ( secondLevel or firstLevel ~= \"static\" ) then\
                    -- as this is a getter or a setter force the type and name of argument to match the property\
                    if functionName == \"get\" then\
                        if #argumentsTable ~= 0 then\
                            error( name .. \": \" .. n .. \": getters cannot have any arguments\" , 2 )\
                        end\
                    elseif functionName == \"set\" then\
                        if #argumentsTable ~= 1 then\
                            error( name .. \": \" .. n .. \": setters can only have one argument\" , 2 )\
                        end\
                        local tableItem = argumentsTable[1]\
                        if tableItem[TYPETABLE_NAME] ~= (secondLevel and secondLevel or firstLevel) then\
                            error( name .. \": \" .. n .. \": setters argument must be called the same name as the property\" , 2 )\
                        end\
                        if tableItem[TYPETABLE_TYPE] then\
                            error( name .. \": \" .. n .. \": setters argument should not indicate a type, it is automatically inferred\" , 2 )\
                        end\
                    end\
                end\
\
                if secondLevel then\
                    -- essentially a static getter/setter or enum function\
                    replacementLine = replacementLine .. \".\" .. secondLevel\
                    local secondLevelTable = firstLevelTable[firstLevel]\
                    if not secondLevelTable then\
                        secondLevelTable = {}\
                        firstLevelTable[secondLevel] = secondLevelTable\
                    end\
                    secondLevelTable[functionName] = argumentsTable\
                else                    \
                    firstLevelTable[functionName] = argumentsTable\
                end\
            else\
                constructingFunctionArguments[functionName] = argumentsTable\
            end\
            line = replacementLine .. \":\" .. functionName .. \"(\" .. argumentsString .. \")\" .. (isInterface and \" end\" or \"\")\
        elseif isInterface and line:match( \"^%s*end%s*$\" ) then\
            error( name .. \": \" .. \"interfaces mustnt use end with functions\" , 2 )\
        end\
        classString = classString .. line .. \"\\n\"\
    end\
    return classString\
end\
\
-- Being the creation of the class\
local function constructClass( _, name )\
    if name ~= expectedName then\
        error( \"wrong name, got \"..name..\" expected \"..tostring(expectedName) ) -- wrong name\
    end\
    isInterface = false\
    local constructing = {\
        name = name;\
        instanceProperties = {};\
        instanceFunctions = {};\
        prebuiltInstanceFunctions = {};\
        instanceGetters = {};\
        prebuiltInstanceGetters = {};\
        instanceSetters = {};\
        prebuiltInstanceSetters = {};\
        staticProperties = {};\
        staticFunctions = {};\
        prebuiltStaticFunctions = {};\
        staticGetters = {};\
        prebuiltStaticGetters = {};\
        staticSetters = {};\
        prebuiltStaticSetters = {};\
        metatableFunctions = {};\
        aliases = {};\
        enums = {};\
        enumTypes = {};\
        interfaces = {};\
        typeOfCache = {};\
    }\
\
    classes[name] = true\
    currentlyConstructing = constructing\
    isLoadingProperties = true\
\
    -- insert all the valueTypes in to the environment for property loading\
    for name, valueType in pairs( valueTypes ) do\
        constructingEnvironment[name] = valueType\
    end\
\
    return loadProperties\
end\
\
function interface( name )\
    if #name < 2 or name:sub( 1, 1) ~= \"I\" then\
        error('must start with I')\
    end\
    if name ~= expectedName then\
        error( \"wrong name\" , 2 ) -- wrong name\
    end\
    isInterface = true\
    local constructing = {\
        name = name;\
        instanceProperties = {};\
        instanceFunctions = {};\
        prebuiltInstanceFunctions = {};\
        instanceGetters = {};\
        prebuiltInstanceGetters = {};\
        instanceSetters = {};\
        prebuiltInstanceSetters = {};\
        staticProperties = {};\
        staticFunctions = {};\
        prebuiltStaticFunctions = {};\
        staticGetters = {};\
        prebuiltStaticGetters = {};\
        staticSetters = {};\
        prebuiltStaticSetters = {};\
        metatableFunctions = {};\
        enums = {};\
    }\
\
    interfaces[name] = constructing\
    currentlyConstructing = constructing\
    isLoadingProperties = true\
    return loadProperties\
end\
\
function extends( name )\
    if isInterface then\
        error(\"interfaces can't extend\", 2 ) -- TODO: maybe make possible\
    end\
    if name ~= currentlyConstructing.name then\
        local ext = class.get( name )\
        local typeOfCache = currentlyConstructing.typeOfCache\
        typeOfCache[ext] = true\
        for k, v in pairs( compiledClassDetails[name].typeOfCache ) do\
            typeOfCache[k] = v\
        end\
\
        currentlyConstructing.superName = name\
    else\
        error( \"can't extend self\" , 2 )\
    end\
    return loadProperties\
end\
\
function implements( name )\
    if isInterface then\
        error(\"interfaces can't implements\", 2 )\
    end\
    if name ~= currentlyConstructing.name then\
        local interface = class.get( name )\
        currentlyConstructing.interfaces[name] = interface\
        currentlyConstructing.typeOfCache[interface] = true\
    else\
        error( \"can't extend self\" , 2 )\
    end\
    return loadProperties\
end\
\
function loadProperties( propertiesTable )\
    -- take all the valueTypes back out of the environment\
    for name, valueType in pairs( valueTypes ) do\
        constructingEnvironment[name] = nil\
    end\
\
    isLoadingProperties = false\
    local staticPropertiesTable = propertiesTable.static\
    local metatableProxy = {}\
    local staticConstructorProxy = { }\
    local constructorProxy = { static = staticConstructorProxy, metatable = metatableProxy } -- injected in to the loading class' environment. acts to recieve function creations\
\
    local superName = currentlyConstructing.superName\
    local compiledSuperDetails = superName and compiledClassDetails[superName]\
    local enums = currentlyConstructing.enums\
    local superEnums = compiledSuperDetails and compiledSuperDetails.enums\
    loadPropertiesTableSection( propertiesTable, compiledSuperDetails and compiledSuperDetails.instanceProperties, currentlyConstructing.instanceProperties, constructorProxy, currentlyConstructing.instanceGetters, currentlyConstructing.instanceSetters, enums, \"static\", currentCompiledClass )\
    if staticPropertiesTable then\
        loadPropertiesTableSection( staticPropertiesTable, compiledSuperDetails and compiledSuperDetails.staticProperties, currentlyConstructing.staticProperties, staticConstructorProxy, currentlyConstructing.staticGetters, currentlyConstructing.staticSetters )\
    end\
\
    -- merge the super enums in to our enums\
    local superOnlyEnums = {} -- enums that were not declared or change by self class\
    if superEnums then\
        for enumName, enum in pairs( superEnums ) do\
            superOnlyEnums[enumName] = true\
            local selfEnum = enums[enumName]\
            if not selfEnum then\
                enums[enumName] = enum\
            else\
                superOnlyEnums[enumName] = false\
                if selfEnum[TYPETABLE_ENUM_ITEM_TYPE] ~= enum[TYPETABLE_ENUM_ITEM_TYPE] then\
                    error( \"cannot change type requirement of enum defined by super\" , 2 )\
                end\
                for key, value in pairs( enum ) do\
                    if selfEnum[key] then\
                        error( \"Cannot change value of enum value \"..key )\
                    else\
                        selfEnum[key] = value\
                    end\
                end\
            end\
        end\
    end\
\
    -- Begin loading functions\
    local enumTypes = currentlyConstructing.enumTypes\
    for k, enum in pairs( enums ) do\
        local selfTostring = \"enum '\" .. currentlyConstructing.name .. \".\" .. k .. \"': \" ..  tostring( enum ):match( \"[%w]+$\" )\
        local __tostring = superOnlyEnums[k] and tostring( enum ) or selfTostring\
        local enumValueType = propertiesTable[k] or superEnums[k]\
        local itemValueType = enumValueType[TYPETABLE_ENUM_ITEM_TYPE]\
        enumTypes[k] = itemValueType\
        setmetatable( enum, {\
            __newindex = function( _, key, func )\
                if type( func ) ~= \"function\" then\
                    error( \"non-function enum values must be defined in properties table\" , 2 )\
                end\
                if not type( key ) == \"string\" or not key:match( \"^[_%u]+$\" ) then\
                    error( \"Enum keys must be all uppercase with _\" , 2 )\
                end\
                checkValue( func, itemValueType )\
                if superOnlyEnums[k] then\
                    __tostring = selfTostring\
                    superOnlyEnums[k] = false\
                end\
                rawset( enum, key, func )\
            end,\
            __tostring = function() return __tostring end\
        } )\
        constructorProxy[k] = enum\
    end\
\
    local aliases = {}\
    currentlyConstructing.aliases = aliases\
\
    local aliasable = {\
        instance = {\
            \"instanceProperties\";\
            \"instanceFunctions\";\
        };\
        static = {\
            \"staticProperties\";\
            \"staticFunctions\";\
        };\
        enums = {\
            \"enums\";\
        };\
    }\
    local indexAliasTags = {}    \
    for mainKey, subkeys in pairs( aliasable ) do\
        aliases[mainKey] = {}\
        local proxy = mainKey == \"static\" and staticConstructorProxy or constructorProxy\
        for i, subkey in ipairs( subkeys ) do\
            for k, v in pairs( currentlyConstructing[subkey] ) do\
                indexAliasTags[proxy[k]] = { mainKey, k, subkey }\
            end\
        end\
    end\
\
    function constructorProxy:alias( value, newName )\
        if type( newName ) ~= \"string\" then\
            error( \"correct: :alias(table/function, string)\", 2 )\
        end\
        local aliasTag = indexAliasTags[value]\
        if not aliasTag then\
            error(\"can't alias undefined value\", 2 )\
        end\
        local oldName = aliasTag[2]\
        local mainTable = aliases[aliasTag[1]]\
\
        if currentlyConstructing[aliasTag[3]][newName] then\
            error( \"attempt to overwrite property/function with alias \"..newName)\
        else\
            mainTable[aliasTag[1]] = oldName\
        end\
\
        -- add the proxy item for the new alias\
        rawset( constructorProxy, newName, constructorProxy[oldName] )\
    end\
\
    local instanceFunctions = currentlyConstructing.instanceFunctions\
    setmetatable( constructorProxy, {\
        __index = function( _, key )\
            error( \"attempted to access undefined property or function '\" .. key .. \"'\", 2)\
        end,\
        __newindex = function( _, key, func )\
            if RESERVED_NAMES[key] then\
                error(\"reserved name \"..key)\
            end\
            local arguments, functionTable = constructingFunctionArguments[key], { func }\
            if not arguments then error(\"function decalared with invalid formatting\", 2 ) end\
            for i, argument in ipairs( arguments ) do\
                table.insert( functionTable, argument )\
            end\
            instanceFunctions[key] = functionTable\
            rawset( constructorProxy, key, func )\
            indexAliasTags[func] = { \"instance\", key, \"instanceFunctions\" }\
        end\
    } )\
\
    local metatableFunctions = currentlyConstructing.metatableFunctions\
    setmetatable( metatableProxy, {\
        __index = function( _, key )\
            error( \"attempted to access metatable property or function '\" .. key .. \"'\", 2)\
        end,\
        __newindex = function( _, key, func )\
            metatableFunctions[key] = func\
        end\
    } )\
\
    local staticFunctions = currentlyConstructing.staticFunctions\
    local staticFunctionArguments = constructingFunctionArguments.static\
    setmetatable( staticConstructorProxy, {\
        __index = function( _, key )\
            error( \"attempted to access undefined property or function '\" .. key .. \"'\", 2)\
        end,\
        __newindex = function( _, key, func )\
            if RESERVED_NAMES[key] then\
                error(\"reserved name \"..key)\
            end\
            local arguments, functionTable = staticFunctionArguments[key], { func }\
            if not arguments then error(\"function decalared with invalid formatting\", 2 ) end\
            for i, argument in ipairs( arguments ) do\
                table.insert( functionTable, argument )\
            end\
            staticFunctions[key] = functionTable\
            rawset( staticConstructorProxy, key, func )\
            indexAliasTags[func] = { \"static\", key, \"staticFunctions\" }\
        end\
    } )\
    constructingEnvironment[currentlyConstructing.name] = constructorProxy\
end\
\
function loadPropertiesTableSection( fromTable, fromSuper, toTable, proxyTable, gettersTable, settersTable, enumsTable, ignoreKey, compiledClass )\
    for propertyName, value in pairs( fromTable ) do\
        if propertyName ~= ignoreKey then\
            local isEnum = false\
            if type( value ) == \"table\" and value[1] == valueTypeUID then\
                -- this is a value type\
                if value[TYPETABLE_IS_ENUM] then\
                    if not enumsTable then\
                        error( \"cannot use enums in static\" , 2 )\
                    elseif not value[TYPETABLE_HAS_DEFAULT_VALUE] then\
                        error( \"enums must be initialised\" , 2 )\
                    end\
                    value[TYPETABLE_NAME] = propertyName\
                    local values = value[TYPETABLE_DEFAULT_VALUE]\
                    enumsTable[propertyName] = values -- we can use the value table directly\
                    isEnum = true\
                else\
                    if ignoreKey then\
                        local classType = value[TYPETABLE_CLASS]\
                        -- TODO: type of!\
                        if classType and classType == compiledClass then --classType:typeOf( \"self??\" ) then\
                            -- don't allow value types that is type of self or are subclasses of self for non-static properties, that would cause an infinite loop\
                            error( \"self refernce not in static\" , 2 )\
                        end\
                    end\
                    if value[TYPETABLE_HAS_DEFAULT_VALUE] then -- this was created like String(), not String. hence we can use the value table directly\
                        value[TYPETABLE_NAME] = propertyName\
                        toTable[propertyName] = value\
                    else\
                        -- this is the actual valueType table, we can't use it. we need to make a copy AND set allowsNil back to false as it may have been changed\
                        local uniqueValue = {\
                            [TYPETABLE_NAME] = propertyName;\
                        }\
\
                        for i = TYPETABLE_TYPE, #value do\
                            uniqueValue[i] = value[i]\
                        end\
                        toTable[propertyName] = uniqueValue\
\
                        rawset( value, \"allowsNil\", false )\
                    end\
                end\
            else\
                -- this is just a plain variable, we make it an Any( value ).allowsNil with the default being its default value. this acts identical to default Lua behaviour\
                toTable[propertyName] = {\
                    [TYPETABLE_NAME] = propertyName;\
                    [TYPETABLE_TYPE] = false;\
                    [TYPETABLE_CLASS] = false;\
                    [TYPETABLE_ALLOWS_NIL] = true;\
                    [TYPETABLE_IS_VAR_ARG] = false;\
                    [TYPETABLE_IS_ENUM] = false;\
                    [TYPETABLE_ENUM_ITEM_TYPE] = false;\
                    [TYPETABLE_HAS_DEFAULT_VALUE] = true;\
                    [TYPETABLE_DEFAULT_VALUE] = value;\
                }\
            end\
            if not isEnum then\
                proxyTable[propertyName] = setmetatable( {}, {\
                    __newindex = function( _, key, func )\
                        if key == \"get\" then\
                            if gettersTable[propertyName] then\
                                error( \"attempt to redefine getter for \" .. propertyName )\
                            else\
                                gettersTable[propertyName] = func\
                            end\
                        elseif key == \"set\" then\
                            if settersTable[propertyName] then\
                                error( \"attempt to redefine setter for \" .. propertyName )\
                            else\
                                settersTable[propertyName] = func\
                            end\
                        else\
                            error(\":get and :set only\", 2 )\
                        end\
                    end\
                } )\
            end\
        end\
    end\
\
    if fromSuper then\
        for propertyName, v in pairs( fromSuper ) do\
            if not RESERVED_NAMES[propertyName] and not proxyTable[propertyName] then\
                proxyTable[propertyName] = setmetatable( {}, {\
                    __newindex = function(_, key, func)\
                        if key == \"get\" then\
                            gettersTable[propertyName] = func\
                        elseif key == \"set\" then\
                            settersTable[propertyName] = func\
                        else\
                            error(\":get and :set only, not \"..key)\
                        end\
                    end\
                } )\
            end\
        end\
    end\
end\
\
-- We have collected all the information about the class now, compile it in to the static class --\
\
local function generateDefaultValue( typeTable )\
    -- this asumes TYPETABLE_HAS_DEFAULT_VALUE is true and TYPETABLE_TYPE is \"table\" and should only be called when that is true\
    local classType = typeTable[TYPETABLE_CLASS]\
    if classType then\
        return classType( unpack( typeTable, TYPETABLE_DEFAULT_VALUE ))\
    else\
        local defaultTable = typeTable[TYPETABLE_DEFAULT_VALUE]\
        -- if it's a plain table make a deep copy of it\
        local function uniqueTable( default )\
            local new = {}\
            for k, v in pairs( default ) do\
                if type( v ) == \"table\" then\
                    new[k] = uniqueTable( v )\
                else\
                    new[k] = v\
                end\
            end\
            return new\
        end\
        return uniqueTable( defaultTable )\
    end\
end\
\
function checkValue( value, typeTable, isSelf ) -- TODO: error level and message based on where it's called form\
    if value == nil  then\
        -- if the value is nil try loading the default value\
        local hasDefaultValue = typeTable[TYPETABLE_HAS_DEFAULT_VALUE]\
        if hasDefaultValue then\
            if typeTable[TYPETABLE_TYPE] ~= \"table\" then\
                return typeTable[TYPETABLE_DEFAULT_VALUE]\
            else\
                return generateDefaultValue( typeTable )                \
            end\
        end\
    end\
\
    if value == nil  then\
        -- if a default value couldn't be loaded and the argument doesn't accept nil then error\
        if not typeTable[TYPETABLE_ALLOWS_NIL] then\
            error(\"can't be nil\", 2 )\
        else\
            -- otherwise, if nil is okay, continue with nil\
            return nil\
        end\
    end\
\
    local expectedType = typeTable[TYPETABLE_TYPE]\
    if expectedType then\
        if type( value ) == expectedType then\
            local expectedClass = typeTable[TYPETABLE_CLASS]\
            if expectedClass then\
                if true or value.typeOf and value:typeOf( expectedClass ) then -- TODO: typeOf\
                    return value\
                end\
            else\
                return value\
            end\
        end\
        if isSelf then\
            error(\"self not passed to function, you probably used . instead of :\", 3)\
        else\
            error(typeTable[TYPETABLE_NAME] .. \" was wrong type, expected \"..expectedType .. \" got \" .. type( value ), 4)\
        end\
    end\
    return value\
end\
\
local function mergeProperties( classProperties, staticProperties )\
    for k, staticTypeTable in pairs( staticProperties ) do\
        if not classProperties[k] then\
            -- subclass doesn't define the property, copy it\
            classProperties[k] = staticTypeTable\
        else\
            -- subclass does define the property\
            local classTypeTable = classProperties[k]\
\
            -- ensure that the types and allows nil are the same\
            if classTypeTable[TYPETABLE_NAME] ~= staticTypeTable[TYPETABLE_NAME] or classTypeTable[TYPETABLE_TYPE] ~= staticTypeTable[TYPETABLE_TYPE] or classTypeTable[TYPETABLE_CLASS] ~= staticTypeTable[TYPETABLE_CLASS] or classTypeTable[TYPETABLE_ALLOWS_NIL] ~= staticTypeTable[TYPETABLE_ALLOWS_NIL] then\
                error(\"cannot change type or allows nil of super class' property\", 2 )\
            end\
        end\
    end\
end\
\
-- generate the actual class and flatten all super values\
function compileClass( compiledClass, name )\
    compiledClassDetails[name] = currentlyConstructing    \
    if isInterface then\
        interfaces[name] = compiledClass\
        for k, v in pairs( currentlyConstructing ) do\
            compiledClass[k] = v\
        end\
        local __tostring = \"interface '\" .. name .. \"': \" ..  tostring( compiledClass ):sub( 8 )\
        setmetatable( compiledClass, { __tostring = function()\
            return __tostring\
        end } )\
    else\
        currentlyConstructing.typeTable = { \"self\", \"table\", type, false, false, false }\
\
        local superName = currentlyConstructing.superName\
        local compiledSuperDetails = superName and compiledClassDetails[superName] \
\
        -- add super properties and ensure they don't conflict\
        if compiledSuperDetails then\
            mergeProperties( currentlyConstructing.instanceProperties, compiledSuperDetails.instanceProperties )\
            mergeProperties( currentlyConstructing.staticProperties, compiledSuperDetails.staticProperties )\
        end\
\
        -- all the properties and functions have been added now, check that the class complies with its interfaces\
        for interfaceName, interface in pairs( currentlyConstructing.interfaces ) do\
            local functionTables, propertyTables, getterSetterTables = { \"instanceFunctions\", \"staticFunctions\" }, { \"instanceProperties\", \"staticProperties\", \"enums\" }, { \"instanceGetters\", \"staticGetters\", \"staticSetters\", \"instanceSetters\" }\
            for i, tableName in ipairs( functionTables ) do\
                local classDefined = currentlyConstructing[tableName]\
                for functionName, functionTable in pairs( interface[tableName] ) do\
                    local classFunctionTable = classDefined[functionName]\
                    if not classFunctionTable then\
                        error( \"class does not define function \"..functionName )\
                    end\
                    for i, argument in ipairs( functionTable) do\
                        if i > FUNCTIONTABLE_FUNCTION then\
                            local classArgument = classFunctionTable[i]\
                            if not classArgument then\
                                error( \"function does not declare argument \"..argument[TYPETABLE_NAME])\
                            elseif argument[TYPETABLE_TYPE] ~= classArgument[TYPETABLE_TYPE] or argument[TYPETABLE_CLASS] ~= classArgument[TYPETABLE_CLASS] or argument[TYPETABLE_ALLOWS_NIL] ~= classArgument[TYPETABLE_ALLOWS_NIL] or argument[TYPETABLE_HAS_DEFAULT_VALUE] ~= classArgument[TYPETABLE_HAS_DEFAULT_VALUE] or argument[TYPETABLE_DEFAULT_VALUE] ~= classArgument[TYPETABLE_DEFAULT_VALUE] then\
                                error( \"argument does use declare same type as interface\", 2 )\
                            end\
                        end\
                    end\
                end\
            end\
            -- TODO: check properties and setters for interfaces too!!!\
        end\
\
        compiledClassDetails[name] = currentlyConstructing\
\
        local static = {}\
        local metatable = currentlyConstructing.metatableFunctions\
        compiledClass.static = static\
        compiledClass.metatable = metatable\
        compiledClass.className = name\
        compiledClass.super = classes[superName]\
\
        local enumTypes = currentlyConstructing.enumTypes \
        for k, enum in pairs( currentlyConstructing.enums  ) do\
            if not next( enum ) then\
                error( \"Enums must have at least one value\" , 2 )\
            end\
            local __tostring = tostring( enum ) -- we already set the __tostring\
            setmetatable( enum, {\
                __newindex = function( _, key, func )\
                    error(\"Attempt to alter immutable (enum) \"..__tostring)\
                end,\
                __tostring = function() return __tostring end\
            } )\
            compiledClass[k] = enum\
\
            -- create the value type for this enum\
            local ownerName, enumName = __tostring:match( \"enum '(%w*)%.(%w*)':\" )\
            if ownerName == name and enumName == k then -- only create the value type if we modified it. k should always == enumName but worth checking\
                local itemValueType = enumTypes[enumName]\
                local fullEnumName = ownerName .. \".\" .. enumName\
\
                itemValueType = createValueType( fullEnumName, itemValueType[TYPETABLE_TYPE], itemValueType[TYPETABLE_CLASS], enumName, valueTypes[ownerName] )\
\
                for k, v in pairs( enum ) do -- we need to add the enum's values so they can be used as default values\
                    rawset( itemValueType, k, v )\
                end\
                rawset( valueTypes[ownerName], enumName, itemValueType )\
            end\
        end\
\
        for newKey, oldKey in pairs( currentlyConstructing.aliases.enums) do\
            if compiledClass[newKey] then\
                error( \"attempt to overwrite existing value with alias\" , 2 )\
            end\
\
            compiledClass[newKey] = enums[oldKey]\
        end\
\
        local typeOfCache = currentlyConstructing.typeOfCache\
        function compiledClass:typeOf( object )\
            if not object then return false\
            elseif type( object ) ~= \"table\" then\
                return false\
            elseif typeOfCache[object] then\
                return true\
            elseif self == object then\
                return true\
            end\
            return false\
        end\
\
        if not metatable.__call then \
            function metatable:__call( ... )\
                return spawnInstance( name, ... )\
           end\
        end\
        compiledClass.spawn = function( ... ) return spawnInstance( name, ... ) end\
\
        if not metatable.__tostring then \
            local __tostring = \"class '\" .. name .. \"': \" ..  tostring( compiledClass ):sub( 8 )\
            function metatable:__tostring()\
               return __tostring\
            end\
        end\
\
        if not metatable.__newindex then \
            function metatable:__newindex( key, value )\
                error(\"attempt to set class property\", 2 )\
            end\
        end\
\
        if not metatable.__index then \
            function metatable:__index( key )\
                if key == \"application\" then\
                    return application\
                end\
                error(\"attempt to get undefined class property \"..key, 2)\
            end\
        end\
        setmetatable( compiledClass, metatable )\
\
\
        compileInstanceClass( name, compiledClass, static )\
        classes[name] = compiledClass\
        static = compileAndSpawnStatic( static, name, compiledClass )\
    end\
    currentlyConstructing = nil\
    _G[name] = compiledClass\
    constructingEnvironment[name] = compiledClass\
    return compiledClass\
end\
\
local function constructSuper( prebuiltFunctions )\
    if #prebuiltFunctions == 1 then return end\
    local lastSuper\
    for i = 1, #prebuiltFunctions - 1 do\
        local super, func = {}, prebuiltFunctions[i]( lastSuper )\
        local __tostring = \"super \" .. tostring(prebuiltFunctions[i])\
        setmetatable( super, {\
            __tostring = function() return __tostring end;\
            __call = function( self, ... ) return func( ... ) end\
        } )\
        super.super = lastSuper\
        lastSuper = super\
    end\
    return lastSuper\
end\
\
-- return the minimum and maximum number of arguments that can be usd on a function\
local function argumentLimits( functionTable )\
    local functionTableLength = #functionTable\
    local maxArgs = functionTableLength - FUNCTIONTABLE_FUNCTION\
    if maxArgs == 0 then return 0, 0, 0 end\
    if functionTable[functionTableLength][TYPETABLE_IS_VAR_ARG] then -- the last value is ..., so there is no maximum\
        maxArgs = math.huge\
    end\
    local minChecked = 0 -- the minimum number of arguments that need to be checkValued (so optionals can be loaded)\
    for i = functionTableLength, FUNCTIONTABLE_FUNCTION + 1, -1 do\
        local funcTbl = functionTable[i]\
        if funcTbl[TYPETABLE_IS_VAR_ARG] then -- varargs are always optional\
        elseif funcTbl[TYPETABLE_HAS_DEFAULT_VALUE] then\
            minChecked = math.max( minChecked, i - 1 ) -- this value has a default value, so it will ALWAYS need to be checked\
        elseif not funcTbl[TYPETABLE_ALLOWS_NIL] then\
            return i - 1, maxArgs, minChecked\
        end\
    end\
\
    return 0, maxArgs, minChecked\
end\
\
local function addPrebuilt( functionName, prebuiltFunction, prebuiltFunctions, superPrebuiltFunctions )\
    local prebuilts = {}\
    prebuiltFunctions[functionName] = prebuilts\
    if superPrebuiltFunctions then\
        local functions = superPrebuiltFunctions[functionName]\
        if functions then\
            for i, func in ipairs( functions ) do\
                prebuilts[i] = func\
            end\
        end\
    end\
    prebuilts[#prebuilts + 1] = prebuiltFunction\
    return prebuiltFunction( constructSuper( prebuilts ) )\
end\
\
local function addMissingSuper( superPrebuilt, prebuiltFunctions, outValues, definedIndexes )\
    if superPrebuilt then\
        for functionName, funcs in pairs( superPrebuilt ) do\
            if not prebuiltFunctions[functionName] then\
                prebuiltFunctions[functionName] = funcs -- TODO: check this doesn't cause issues due to using the same table\
                if definedIndexes then definedIndexes[functionName] = functionName end\
                outValues[functionName] = funcs[#funcs]( constructSuper( funcs ) )\
            end\
        end\
    end\
end\
\
local function addFunctions( classFunctions, definedIndexes, prebuiltFunctions, superPrebuiltFunctions, outValues, selfTypeTable )\
    for functionName, functionTable in pairs( classFunctions ) do\
        definedIndexes[functionName] = functionName\
        local func = functionTable[FUNCTIONTABLE_FUNCTION]\
        local minArgs, maxArgs, minChecked = argumentLimits( functionTable )\
        local varargTypeTable\
        local functionTableLength = #functionTable\
        if functionTableLength > FUNCTIONTABLE_FUNCTION and functionTable[functionTableLength][TYPETABLE_IS_VAR_ARG] then\
            varargTypeTable = functionTable[functionTableLength]\
        end\
        local function prebuiltFunction( super )\
            return function( self, ... )\
                local arguments = { ... }\
                local argumentsLength = #arguments\
                if argumentsLength < minArgs or argumentsLength > maxArgs then\
                    for i, v in ipairs(arguments) do\
                        print(i .. \": \"..tostring(v))\
                    end\
                    error( functionName .. \": wrong number of arguments, got \"..argumentsLength..\" expected between \".. minArgs .. \" and \" .. maxArgs, 2 )\
                end\
\
                local values = { checkValue( self, selfTypeTable, true ) }\
\
                local argumentCount = (argumentsLength > minChecked and argumentsLength or minChecked)\
                for i = 1 + FUNCTIONTABLE_FUNCTION, argumentCount + FUNCTIONTABLE_FUNCTION do\
                    values[i] = checkValue( arguments[i - FUNCTIONTABLE_FUNCTION], (i > functionTableLength) and varargTypeTable or functionTable[i] )\
                end\
\
                local oldSuper = rawget( self, \"super\" )\
                rawset( self, \"super\", super )\
                local response = { func( unpack( values, 1, argumentCount + 1 ) ) }\
                rawset( self, \"super\", oldSuper )\
              \
                return unpack( response )\
            end\
        end\
        outValues[functionName] = addPrebuilt( functionName, prebuiltFunction, prebuiltFunctions, superPrebuiltFunctions )\
    end\
    addMissingSuper( superPrebuiltFunctions, prebuiltFunctions, outValues, definedIndexes )\
end\
\
local function addGetter( getters, properties, outGetters, prebuiltGetters, superPrebuiltGetters )\
    for propertyName, getterFunction in pairs( getters ) do\
        local propertyTypeTable = properties[propertyName]\
        local function prebuiltGetter( super )\
            return function( self )\
                local oldSuper = rawget( self, \"super\" )\
                rawset( self, \"super\", super )\
                local lockedGetters = allLockedGetters[self]\
                lockedGetters[propertyName] = true\
                value = checkValue( getterFunction( self ), propertyTypeTable ) -- we know that this is defintely self as it's only called by the class system\
                lockedGetters[propertyName] = false\
                rawset( self, \"super\", oldSuper )\
                return value\
            end\
        end\
        outGetters[propertyName] = addPrebuilt( propertyName, prebuiltGetter, prebuiltGetters, superPrebuiltGetters )\
    end\
    addMissingSuper( superPrebuiltGetters, prebuiltGetters, outGetters )\
end\
\
local function addSetter( setters, properties, outSetters, prebuiltSetters, superPrebuiltSetters )\
    for propertyName, setterFunction in pairs( setters ) do\
        local propertyTypeTable = properties[propertyName]\
        local function prebuiltSetter( super )\
            return function( self, value )\
                local oldSuper = rawget( self, \"super\" )\
                rawset( self, \"super\", super )\
                local lockedSetters = allLockedSetters[self]\
                lockedSetters[propertyName] = true\
                setterFunction( self, checkValue( value, propertyTypeTable ) ) -- we know that this is defintely self as it's only called by the class system\
                lockedSetters[propertyName] = false\
                rawset( self, \"super\", oldSuper )\
                return value\
            end\
        end\
        outSetters[propertyName] = addPrebuilt( propertyName, prebuiltSetter, prebuiltSetters, superPrebuiltSetters )\
    end\
    addMissingSuper( superPrebuiltSetters, prebuiltSetters, outSetters )\
end\
\
function compileInstanceClass( name, compiledClass, static )\
    local initialValues, prebuiltGetters, prebuiltSetters, requireDefaultGeneration, definedIndexes, definedProperties = { static = static, class = compiledClass, }, {}, {}, {}, { static = \"static\", class = \"class\", typeOf = \"typeOf\", isDefined = \"isDefined\", isDefinedProperty = \"isDefinedProperty\", isDefinedFunction = \"isDefinedFunction\" }, { static = \"static\", class = \"class\" }\
    local classDetails = compiledClassDetails[name]\
    local superName = classDetails.superName\
    local compiledSuperDetails = superName and compiledClassDetails[superName]\
    local instanceProperties = classDetails.instanceProperties\
    local selfTypeTable = classDetails.typeTable\
\
\
    -- add default property values if they have them\
    for propertyName, typeTable in pairs( instanceProperties ) do\
        definedIndexes[propertyName] = propertyName\
        definedProperties[propertyName] = propertyName\
\
        if typeTable[TYPETABLE_HAS_DEFAULT_VALUE] then\
            local defaultValue = typeTable[TYPETABLE_DEFAULT_VALUE]\
            if ( typeTable[TYPETABLE_TYPE] or type( defaultValue ) ) ~= \"table\" then\
                if typeTable[TYPETABLE_ALLOWS_NIL] and defaultValue ~= nil then -- there isn't a value here yet. don't assign the value yet, but if after initialisation there isn't a value an error will be thrown if it doesn't allow nil\
                    initialValues[propertyName] = defaultValue\
                end\
            else\
                requireDefaultGeneration[propertyName] = typeTable\
            end\
        end\
    end\
\
    local aliases = classDetails.aliases.instance\
    for k, v in pairs( aliases ) do -- copy the aliases to definedIndexes\
        definedIndexes[k] = v\
        if definedProperties[v] then\
            definedProperties[k] = v\
        end\
    end\
\
    -- add the instance functions\
    addFunctions( classDetails.instanceFunctions, definedIndexes, currentlyConstructing.prebuiltInstanceFunctions, compiledSuperDetails and compiledSuperDetails.prebuiltInstanceFunctions, initialValues, selfTypeTable )\
\
    addGetter( classDetails.instanceGetters, instanceProperties, prebuiltGetters, currentlyConstructing.prebuiltInstanceGetters, compiledSuperDetails and compiledSuperDetails.prebuiltInstanceGetters )\
    addSetter( classDetails.instanceSetters, instanceProperties, prebuiltSetters, currentlyConstructing.prebuiltInstanceSetters, compiledSuperDetails and compiledSuperDetails.prebuiltInstanceSetters )\
\
    local typeOfCache = classDetails.typeOfCache\
    function initialValues:typeOf( object )\
        if not object then return false\
        elseif type( object ) ~= \"table\" then\
            return false\
        elseif object == compiledClass then\
            return true\
        elseif typeOfCache[object] then\
            return true\
        elseif self == object then\
            return true\
        end\
        return false\
    end\
\
    function initialValues:isDefined( key )\
        return definedIndexes[key] ~= nil\
    end\
\
    function initialValues:isDefinedProperty( key )\
        return definedProperties[key] ~= nil\
    end\
\
    function initialValues:isDefinedFunction( key )\
        return definedProperties[key] ~= nil and definedIndexes[key] ~= nil\
    end\
\
    compiledInstances[name] = {\
        initialValues = initialValues;\
        prebuiltFunctions = prebuiltFunctions;\
        prebuiltGetters = prebuiltGetters;\
        prebuiltSetters = prebuiltSetters;\
        requireDefaultGeneration = requireDefaultGeneration;\
        definedIndexes = definedIndexes;\
        definedProperties = definedProperties;\
    }\
end\
\
function compileAndSpawnStatic( static, name, compiledClass )\
    local classDetails = compiledClassDetails[name]\
    local staticProperties = classDetails.staticProperties\
    local selfTypeTable = classDetails.typeTable\
    local superName = classDetails.superName\
    local compiledSuperDetails = superName and compiledClassDetails[superName]\
\
    local values, getters, setters = { class = compiledClass }, {}, {}\
\
    local definedIndexes, definedProperties = { typeOf = \"typeOf\", class = \"class\", isDefinedProperty = \"isDefinedProperty\", isDefinedFunction = \"isDefinedFunction\" }, { class = \"class\" }\
    for propertyName, typeTable in pairs( staticProperties ) do\
        definedIndexes[propertyName] = propertyName\
        definedProperties[propertyName] = propertyName\
        if typeTable[TYPETABLE_HAS_DEFAULT_VALUE] then\
            local defaultValue = typeTable[TYPETABLE_DEFAULT_VALUE]\
            if ( typeTable[TYPETABLE_TYPE] or type( defaultValue ) ) ~= \"table\" then\
                values[propertyName] = typeTable[TYPETABLE_DEFAULT_VALUE]\
            else\
                values[propertyName] = generateDefaultValue( typeTable )\
            end\
        end\
    end\
\
    local aliases = classDetails.aliases.static\
    for k, v in pairs( aliases ) do -- copy the aliases to definedIndexes\
        definedIndexes[k] = v\
        if definedProperties[v] then\
            definedProperties[k] = v\
        end\
    end\
\
    addFunctions( classDetails.staticFunctions, definedIndexes, classDetails.prebuiltStaticFunctions, compiledSuperDetails and compiledSuperDetails.prebuiltStaticFunctions, values, selfTypeTable )\
\
    local lockedGetters, lockedSetters = {}, {}\
    allLockedGetters[static] = lockedGetters\
    allLockedSetters[static] = lockedSetters\
\
    addGetter( classDetails.staticGetters, staticProperties, getters, currentlyConstructing.prebuiltInstanceGetters, compiledSuperDetails and compiledSuperDetails.prebuiltStaticGetters )\
    addSetter( classDetails.staticSetters, staticProperties, setters, currentlyConstructing.prebuiltInstanceSetters, compiledSuperDetails and compiledSuperDetails.prebuiltStaticSetters )\
\
    local typeOfCache = classDetails.typeOfCache\
    function static:typeOf( object )\
        if not object then return false\
        elseif type( object ) ~= \"table\" then\
            return false\
        elseif object == compiledClass then\
            return true\
        elseif typeOfCache[object] then\
            return true\
        elseif self == object then\
            return true\
        end\
        return false\
    end\
\
    function static:isDefined( key )\
        return definedIndexes[key] ~= nil\
    end\
\
    function static:isDefinedProperty( key )\
        return definedProperties[key] ~= nil\
    end\
\
    function static:isDefinedFunction( key )\
        return definedProperties[key] ~= nil and definedIndexes[key] ~= nil\
    end\
\
    local metatable = {}\
    function metatable:__newindex( key, value )\
        if RESERVED_NAMES[key] then error( \"reserved name\" , 2 ) end\
\
        local locatedKey = definedProperties[key]\
        if locatedKey then\
            local setter = setters[locatedKey]\
            if setter and not lockedSetters[locatedKey] then\
                setter( self, value )\
            else\
                values[locatedKey] = checkValue( value, staticProperties[locatedKey] )\
            end\
        else\
            error(\"attempt to set undefined property or function\", 2 )\
        end\
    end\
\
    function metatable:__index( key )\
        local locatedKey = definedIndexes[key]\
        if locatedKey then\
            local getter = getters[locatedKey]\
            if getter and not lockedGetters[locatedKey] then\
                return getter( self )\
            else\
                return values[locatedKey]\
            end\
        elseif key == \"application\" then\
            return application\
        elseif key == \"super\" then\
            error(\"function does not have super function\", 2 )\
        else\
            error(\"attempt to get undefined property '\"..key..\"' from \"..tostring( self ), 2)\
        end\
    end\
\
    local __tostring = \"static of '\" .. name .. \"': \" ..  tostring( static ):sub( 8 )\
    function metatable:__tostring ()\
        return __tostring\
    end\
\
    static.metatable = metatable\
    setmetatable( static, metatable )\
\
    -- run the initialiser\
    for i, key in ipairs( { \"initialise\", \"intialize\" } ) do\
        if definedIndexes[key] then\
            if definedProperties[key] then\
                error( \"initialise must be function, not property\", 2 )\
            end\
            static[key]( static )\
            break\
        end\
    end\
\
    -- TODO: check for any nil values that aren't allowed to be nil\
\
    return static\
end\
\
\
function spawnInstance( name, ... )\
    local compiledInstance = compiledInstances[name]\
    local classDetails = compiledClassDetails[name]\
    local instanceProperties = classDetails.instanceProperties\
\
    local values, getters, setters = {}, {}, {}\
\
    for key, value in pairs( compiledInstance.initialValues ) do\
        values[key] = value\
    end\
\
    -- for default values that are tables make them unique or create class instances\
    for propertyName, typeTable in pairs( compiledInstance.requireDefaultGeneration ) do\
        if propertyName == \"handles\" then log \"Generating\" end\
        values[propertyName] = generateDefaultValue( typeTable )\
    end\
\
    local lockedGetters, lockedSetters = {}, {}\
\
    -- unwrap the prebuilt getter/setter functions so we can use our unique locking tables\
    for propertyName, func in pairs( compiledInstance.prebuiltGetters ) do\
        getters[propertyName] = func\
    end\
\
    for propertyName, func in pairs( compiledInstance.prebuiltSetters ) do\
        setters[propertyName] = func\
    end\
\
    local aliases = classDetails.aliases.instance\
\
    local definedIndexes, definedProperties = compiledInstance.definedIndexes, compiledInstance.definedProperties\
    local instance = {}\
    allLockedGetters[instance] = lockedGetters\
    allLockedSetters[instance] = lockedSetters\
    local metatable = {}\
    function metatable:__newindex( key, value )\
        if RESERVED_NAMES[key] then error( \"reserved name\" , 2 ) end\
\
        local locatedKey = definedProperties[key]\
        if locatedKey then\
            local setter = setters[locatedKey]\
            if setter and not lockedSetters[locatedKey] then\
                setter( self, value )\
            else\
                values[locatedKey] = checkValue( value, instanceProperties[locatedKey] )\
            end\
        else\
            error(\"attempt to set undefined property or function\", 2 )\
        end\
    end\
\
    function metatable:__index( key )\
        local locatedKey = definedIndexes[key]\
        if locatedKey then\
            local getter = getters[locatedKey]\
            if getter and not lockedGetters[locatedKey] then\
                return getter( self )\
            else\
                return values[locatedKey]\
            end\
        elseif key == \"application\" then\
            return application\
        elseif key == \"super\" then\
            error(\"function does not have super function\", 2 )\
        else\
            error(\"attempt to get undefined property '\"..key..\"' from \"..tostring( self ), 2)\
        end\
    end\
\
    local __tostring = \"instance of '\" .. name .. \"': \" ..  tostring( instance ):sub( 8 )\
    function metatable:__tostring ()\
        return __tostring\
    end\
\
    instance.metatable = metatable\
    instance.raw = values\
    setmetatable( instance, metatable )\
\
    -- run the initialiser\
    for i, key in ipairs( { \"initialise\", \"intialize\" } ) do\
        if definedIndexes[key] then\
            if definedProperties[key] then\
                error( \"initialise must be function, not property\", 2 )\
            end\
            instance[key]( instance, ... )\
            break\
        end\
    end\
\
    -- TODO: check for any nil values that aren't allowed to be nil\
\
    return instance\
end\
\
setmetatable( class, {\
    __call = constructClass\
} )",
  },
  MaskedTextBox = {
    [ "text/lua" ] = "\
class \"MaskedTextBox\" extends \"TextBox\" {\
    \
    isMasked = true;\
\
}",
  },
  ToolbarSegmentButton = {
    [ "text/lua" ] = "\
class \"ToolbarSegmentButton\" extends \"SegmentButton\" {}",
  },
  Path = {
    [ "text/lua" ] = "\
local sin, cos, floor, min, max, abs, acos, PI = math.sin, math.cos, math.floor, math.min, math.max, math.abs, math.acos, math.pi\
\
local function round( num )\
\9return floor( num + 0.5 )\
end\
\
-- the next few functions are just taken from a site for bezier intersection, hence the terribly named variables. don't hate.\
local function sgn( n )\
\9return n < 0 and -1 or 1\
end\
\
local function sortSpecial( a )\
    local flip;\
    local temp;\
    \
    repeat\
        flip = false\
        for i = 1, #a - 1 do\
            if ( a[i+1] >= 0 and a[i] > a[i+1] ) or ( a[i] < 0 and a[i+1] >= 0 ) then\
\9\9\9\9flip = true\
\9\9\9\9temp = a[i]\
\9\9\9\9a[i] = a[i+1]\
\9\9\9\9a[i+1] = temp\
\9\9\9end\
\9\9end\
    until not flip\
\
\9return a\
end\
\
local function bezierCoeffs( P0, P1, P2, P3 )\
\9local Z = {};\
\9Z[1] = -P0 + 3 * P1 + -3 * P2 + P3; \
    Z[2] = 3 * P0 - 6 * P1 + 3 * P2;\
    Z[3] = -3 * P0 + 3 * P1;\
    Z[4] = P0;\
\9return Z;\
end\
\
local function cubicRoots( P )\
\
\9local a = P[1]\
\9local b = P[2]\
\9local c = P[3]\
\9local d = P[4]\
\9\
\9local A = b / a\
\9local B = c / a\
\9local C = d / a\
\
    local Q, R, D, S, T, Im -- ehm?\
\
    local Q = ( 3 * B - A ^ 2 )/9;\
    local R = ( 9 * A * B - 27 * C - 2 * A ^ 3 ) / 54;\
    local D = Q ^ 3 + R ^ 2;    -- polynomial discriminant\
\
    local t = {}\
\9\
    if D >= 0 then -- complex or duplicate roots\
    \9local v1, v2, third = R + D^.5, R - D^.5, 1 / 3\
        local T = sgn( v1 ) * abs( v1 ) ^ third\
        local S = sgn( v2 ) * abs( v2 ) ^ third\
\
        t[1] = A / -3 + ( S + T ) -- real root\
        t[2] = A / -3 - ( S + T ) / 2 -- real part of complex root\
        t[3] = A / -3 - ( S + T ) / 2 -- real part of complex root\
        local Im = abs( 3^.5 * ( S - T ) / 2 ) -- complex part of root pair   \
        \
        if Im ~= 0 then\
            t[2]=-1\
            t[3]=-1\
        end\
    else -- distinct real roots\
        local th = acos( R / (-( Q^3) )^.5 )\
        \
        t[1] = 2 * ( -Q )^.5 * cos( th / 3 ) - A / 3\
        t[2] = 2 * ( -Q )^.5 * cos( ( th + 2 * PI ) / 3 ) - A / 3\
        t[3] = 2 * ( -Q )^.5 * cos( ( th + 4 * PI ) / 3 ) - A / 3\
        local Im = 0.0\
    end\
    \
    -- discard out of spec roots\
\9for i = 1, 3 do\
        if t[i] < 0 or t[i] > 1 then\
       \9\9t[i] = -1\
       \9end\
\9end\
                \
\9-- sort but place -1 at the end\
    t = sortSpecial( t );\
    \
    return t;\
end\
\
local function getHorizontalLinearIntersectionPoint( points, y, line, minX, maxX )\
\9if abs( line.x1 - line.x2 ) < .00001 then\
\9\9if y >= min( line.y1, line.y2 ) - .00001 and y <= max( line.y1, line.y2 ) + .0001 then\
\9\9\9points[#points + 1] = floor( line.x1 + .5 )\
\9\9end\
\9else\
\9\9local m = ( line.y2 - line.y1 ) / ( line.x2 - line.x1 )\
\9\9local c = line.y1 - m * line.x1\
\9\9local x = ( y - c ) / m\
\9\9if x >= min( line.x1, line.x2 ) - .00001 and x <= max( line.x1, line.x2 ) + .0001 then\
\9\9\9points[#points + 1] = x\
\9\9end\
\9end\
end\
\
local function getVerticalLinearIntersectionPoint( points, x, line, minY, maxY )\
\9if abs( line.y1 - line.y2 ) < .00001 then\
\9\9if x >= math.min( line.x1, line.x2 ) - .00001 and x <= math.max( line.x1, line.x2 ) + .0001 then\
\9\9\9points[#points + 1] = floor( line.y1 + 0.5 )\
\9\9end\
\9else\
\9\9local m = ( line.y2 - line.y1 ) / ( line.x2 - line.x1 )\
\9\9local c = line.y1 - m * line.x1\
\9\9local y = m * x + c\
\9\9if y >= min( line.y1, line.y2 ) - .00001 and y <= max( line.y1, line.y2 ) + .0001 then\
\9\9\9points[#points + 1] = y\
\9\9end\
\9end\
end\
\
local function getHorizontalCurvedIntersectionPoints( points, y, line, minX, maxX )\
\9if not line.xCoefficients or not line.yCoefficients then\
\9\9line.xCoefficients = bezierCoeffs( line.x1, line.controlPoint1X, line.controlPoint2X, line.x2 )\
\9\9line.yCoefficients = bezierCoeffs( line.y1, line.controlPoint1Y, line.controlPoint2Y, line.y2 )\
\9end\
\
\9local xCoefficients = line.xCoefficients\
\9local yCoefficients = line.yCoefficients\
\
\9local yRoots = cubicRoots( { yCoefficients[1], yCoefficients[2], yCoefficients[3], yCoefficients[4] - y } )\
\
    for i = 1, 3 do\
        t = yRoots[i];\
        if t > 0 and t < 1 then\
\9        local x = xCoefficients[1] * t * t * t + xCoefficients[2] * t * t + xCoefficients[3] * t + xCoefficients[4];\
\9\9\9x = min( max( x, minX ), maxX )\
\9\9\9points[#points + 1] = x\
\9    end\
    end\
end\
\
local function getVerticalCurvedIntersectionPoints( points, x, line, minY, maxY )\
\9if not line.xCoefficients or not line.yCoefficients then\
\9\9line.xCoefficients = bezierCoeffs( line.x1, line.controlPoint1X, line.controlPoint2X, line.x2 )\
\9\9line.yCoefficients = bezierCoeffs( line.y1, line.controlPoint1Y, line.controlPoint2Y, line.y2 )\
\9end\
\
\9local xCoefficients = line.yCoefficients\
\9local yCoefficients = line.xCoefficients\
\
\9local yRoots = cubicRoots( { yCoefficients[1], yCoefficients[2], yCoefficients[3], yCoefficients[4] - x } )\
\
    for i = 1, 3 do\
        t = yRoots[i];\
        if t > 0 and t < 1 then\
\9        local y = xCoefficients[1] * t * t * t + xCoefficients[2] * t * t + xCoefficients[3] * t + xCoefficients[4];\
\9\9\9y = min( max( y, minY ), maxY )\
\9\9\9points[#points + 1] = y\
\9    end\
    end\
end\
\
local getLinearIntersectionPoint = getHorizontalLinearIntersectionPoint\
local getCurvedIntersectionPoints = getHorizontalCurvedIntersectionPoints\
\
class \"Path\" extends \"GraphicsObject\" {\
\9lines = {};\
\9defined = false; -- when true the path becomes immutable. set to true after :close is called\
\9width = 0;\
\9height = 0;\
\9x = 0;\
\9y = 0;\
\9currentX = 0;\
\9currentY = 0;\
\9outlinePoints = {}; -- the generic outline pixels used for fill and outline\
\9serialisedPath = Table; --TODO: read-only\
}\
\
--[[\
\9@constructor\
\9@desc Creates the start of a path\
\9@param [number] x -- the x coordinate\
\9@param [number] y -- the y coordinate\
\9@param [number] width -- the starting y coordinate\
\9@param [number] height -- the starting y coordinate\
\9@param [number] currentX -- the starting x coordinate\
\9@param [number] currentY -- the starting y coordinate\
]]\
function Path:initialise( x, y, width, height, currentX, currentY, lines )\
\9self:super( x, y, width, height )\
\9self.currentX = currentX or 1\
\9self.currentY = currentY or 1\
\9if lines then\
\9\9self.lines = lines\
\9\9self.defined = true\
\9end\
end\
\
--[[\
\9@static\
\9@desc Loads a path from a serialised path\
\9@param [table] serialisedPath -- the serialised path table\
\9@return [Path] path -- the path\
]]\
function Path.static:fromSerialisedPath( serialisedPath )\
\9return Path( serialisedPath.x, serialisedPath.y, serialisedPath.width, serialisedPath.height, 1, 1, serialisedPath.lines )\
end\
\
--[[\
\9@instance\
\9@desc Returns a serialised copy of the path which can be used to load from later\
\9@return [table] path -- the copied path table\
]]\
function Path.serialisedPath:get()\
\9local lines, pathCopy = self.lines, { x = self.x, y = self.y, width = self.width, height = self.height, lines = {} }\
\9local linesCopy = pathCopy.lines\
\
\9for i, line in ipairs( lines ) do\
\9\9local lineCopy = {}\
\9\9for k, v in pairs( line ) do\
\9\9\9lineCopy[k] = v\
\9\9end\
\9\9linesCopy[i] = lineCopy\
\9end\
\
\9return pathCopy\
end\
\
--[[\
\9@instance\
\9@desc Moves the current position to the given coordinates.\
\9@param [number] x -- the x coordinate to move to\
\9@param [number] y -- the y coordinate to move to\
]]\
function Path:moveTo( x, y )\
\9self.currentX = x\
\9self.currentY = y\
end\
\
--[[\
\9@instance\
\9@desc Adds a straight line from the current position to the specified position\
\9@param [number] x -- the x coordinate to add a line to\
\9@param [number] y -- the y coordinate to add a line to\
\9@return [boolean] didAdd -- whether the line was added\
]]\
function Path:lineTo( x, y )\
\9if self.defined or not x or not y or (x == self.currentX and y == self.currentY) then return false end\
\9self.lines[#self.lines + 1] = {\
\9\9mode = \"linear\";\
\9\9x1 = self.currentX;\
\9\9y1 = self.currentY;\
\9\9x2 = x;\
\9\9y2 = y;\
\9}\
\9self.currentX = x\
\9self.currentY = y\
\9--[[\
\9local pointsTable = self.points\
\9pointsTable[#pointsTable + 1] = false\
\9pointsTable[#pointsTable + 1] = false\
\9pointsTable[#pointsTable + 1] = { x, y }\
\9]]\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Create a bezier curve from current position to the specified position\
\9@param [number] endX -- the x coordinate to create the curve to\
\9@param [number] endY -- the y coordinate to create the curve to\
\9@param [number] controlPoint1X -- the x coodinate of the first control point (for the current position)\
\9@param [number] controlPoint1Y -- the y coodinate of the first control point (for the current position)\
\9@param [number] controlPoint2X -- the x coodinate of the first control point\
\9@param [number] controlPoint2Y -- the y coodinate of the first control point\
\9@return [boolean] didAdd -- whether the line was added\
]]\
function Path:curveTo( endX, endY, controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y )\
\9if self.defined or not endX or not endY or not controlPoint1X or not controlPoint1Y or not controlPoint2X or not controlPoint2Y then return false end\
\9\
\9self.lines[#self.lines + 1] = {\
\9\9mode = \"curve\";\
\9\9x1 = self.currentX;\
\9\9y1 = self.currentY;\
\9\9x2 = endX;\
\9\9y2 = endY;\
\9\9controlPoint1X = controlPoint1X;\
\9\9controlPoint1Y = controlPoint1Y;\
\9\9controlPoint2X = controlPoint2X;\
\9\9controlPoint2Y = controlPoint2Y;\
\9}\
\
\9self.currentX = endX\
\9self.currentY = endY\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Adds an arc at the current position\
\9@param [number] startAngle -- the angle to start (in radians)\
\9@param [number] endAngle -- the angle to end (in radians)\
\9@param [number] radius -- the radius\
\9@return [boolean] didAdd -- whether the line was added\
]]\
\
function Path:arc( startAngle, endAngle, radius )\
\9if self.defined then return false end\
\
\9local lines = self.lines\
\
\9local currentX, currentY = self.currentX, self.currentY\
\9local centreX, centreY = currentX - sin( startAngle ) * radius, currentY + cos( startAngle ) * radius\
\
\9local length = endAngle - startAngle\
\9local segments = floor( radius * abs( length ) * PI + .5 )\
\
\9for i = 0, segments do\
\9\9local angle = startAngle + length * i / segments\
\9\9local x, y = centreX + sin( angle ) * radius, centreY - cos( angle ) * radius\
\
\9\9lines[#lines + 1] = {\
\9\9\9mode = \"linear\";\
\9\9\9x1 = currentX;\
\9\9\9y1 = currentY;\
\9\9\9x2 = x;\
\9\9\9y2 = y;\
\9\9}\
\
\9\9currentX, currentY = x, y\
\9end\
\
\9self.currentX, self.currentY = currentX, currentY\
\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Closes the path (i.e. makes the end meet the start), making it immutable and drawable\
\9@return [boolean] didClose -- whether the path was closed\
]]\
function Path:close( linkedToEnd )\
\9linkedToEnd = (linkedToEnd == nil) and true or false\
\9if self.defined then return false end\
\
\9if #self.lines == 0 then\
\9\9error( \"Path has no lines!\", 2 )\
\9end\
\9if linkedToEnd and (self.lines[1].x1 ~= self.lines[#self.lines].x2 or self.lines[1].y1 ~= self.lines[#self.lines].y2) then\
\9\9self:lineTo( self.lines[1].x1, self.lines[1].y1 )\
\9end\
\
\9self.defined = true;\
\9self.currentX = false\
\9self.currentY = false\
\9return true\
end\
\
function Path:getHorizontalIntersections( y, minX, maxX )\
\9local points = {}\
\9local lines = self.lines\
\9for i = 1, #lines do\
\9\9if lines[i].mode == \"linear\" then\
\9\9\9getHorizontalLinearIntersectionPoint( points, y, lines[i], minX, maxX )\
\9\9else\
\9\9\9getHorizontalCurvedIntersectionPoints( points, y, lines[i], minX, maxX )\
\9\9end\
\9end\
\9table.sort( points )\
\9return points\
end\
\
function Path:getVerticalIntersections( x, minY, maxY )\
\9local points = {}\
\9local lines = self.lines\
\9for i = 1, #lines do\
\9\9if lines[i].mode == \"linear\" then\
\9\9\9getVerticalLinearIntersectionPoint( points, x, lines[i], minY, maxY )\
\9\9else\
\9\9\9getVerticalCurvedIntersectionPoints( points, x, lines[i], minY, maxY )\
\9\9end\
\9end\
\9table.sort( points )\
\9return points\
end\
\
--[[\
\9@instance\
\9@desc Get an array of the intersection points (essentially the outline)\
\9@return [table] points -- the points\
\9@return [table] vertices -- the points\
]]\
function Path:getPointsAndVertices( y, minX, maxX )\
\9local points = {}\
\9local lines = self.lines\
\9for i = 1, #lines do\
\9\9local line = lines[i]\
\9\9if line.mode == \"linear\" then\
\9\9\9getLinearIntersectionPoint( points, y, line, minX, maxX )\
\9\9else\
\9\9\9getCurvedIntersectionPoints( points, y, line, minX, maxX )\
\9\9end\
\9end\
\
\9local vertices = {}\
\9table.sort( points )\
\9for i = #points, 2, -1 do\
\9\9if round( points[i] ) == round( points[i-1] ) then\
\9\9\9vertices[i] = true\
\9\9\9vertices[i-1] = true\
\9\9end\
\9end\
\
\9return points, vertices\
end\
\
--[[\
    @instance\
    @desc Gets the points on the outline of the path\
    @param [number] outlineWidth -- the outline width\
    @param [boolean] dualAxis -- whether or not to check both axis\
    \9this should be true if generating outline points for fill mode\
    @return [table] points -- an array of points { [y] = { [1] = x1, [n] = xn } }\
    @return [number] minY -- the minimum Y coord\
    @return [number] maxY -- the maximum Y coord\
]]\
function Path.fill:get()\
\9if self.fill then return self.fill end\
\
\9local minY, maxY, minX, maxX = 1, self.height, 1, self.width\
\9local fill = {}\
\
\9for y = minY, maxY do\
\
\9\9local points = self:getHorizontalIntersections( y, minX, maxX )\
\
\9\9if #points == 1 then\
\9\9\9local x = floor( points[1] + .5 )\
\9\9\9fill[x] = fill[x] or {}\
\9\9\9fill[x][y] = true\
\9\9else\
\9\9\9local filling = false\
\9\9\9for i = 1, #points - 1 do\
\9\9\9\9local isVertex = ( round( points[i] ) == round( points[i + 1] ) ) or ( points[i-1] and round( points[i] ) == round( points[i - 1] ) )\
\9\9\9\9if not filling or not isVertex then\
\9\9\9\9\9filling = not filling\
\9\9\9\9end\
\9\9\9\9if filling then\
\9\9\9\9\9for x = floor( points[i] + .5 ), floor( points[i + 1] + .5 ) do\
\9\9\9\9\9\9fill[x] = fill[x] or {}\
\9\9\9\9\9\9fill[x][y] = true\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9self.fill = fill\
\9return fill\
end\
\
\
function Path.outline:get()\
\9if self.outline then return self.outline end\
\
\9local minY, maxY, minX, maxX = 1, self.height, 1, self.width\
\9local outline = {}\
\
\9for y = minY, maxY do\
\9\9local points = self:getHorizontalIntersections( y, minX, maxX )\
\
\9\9for i = 1, #points do\
\9\9\9local x = round( points[i] )\
\9\9\9outline[x] = outline[x] or {}\
\9\9\9outline[x][y] = true\
\9\9end\
\9end\
\
\9for x = minX, maxX do\
\9\9outline[x] = outline[x] or {}\
\9\9local points = self:getVerticalIntersections( x, minY, maxY )\
\
\9\9for i = 1, #points do\
\9\9\9local y = round( points[i] )\
\9\9\9outline[x][y] = true\
\9\9end\
\9end\
\
\9local thickendOutline = {}\
\9local function xScanline( min, max, inc, outlineWidth )\
\9\9if outlineWidth <= 1 then return end\
\9\9for y = 1, self.height do\
\9\9\9for x = min, max, inc do\
\9\9\9\9if outline[x] and outline[x][y] then\
\9\9\9\9\9for i = 1 - outlineWidth, outlineWidth - 1 do\
\9\9\9\9\9\9thickendOutline[x + i] = thickendOutline[x + i] or {}\
\9\9\9\9\9\9thickendOutline[x + i][y] = true\
\9\9\9\9\9end\9\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9local function yScanline( min, max, inc, outlineWidth )\
\9\9for x = 1, self.width do\
\9\9\9local lastY = 0\
\9\9\9local yPixels = 0\
\9\9\9local outlineX = outline[x]\
\9\9\9if outlineX then\
\9\9\9\9for y, isSet in pairs( outlineX ) do\
\9\9\9\9\9if isSet then\
\9\9\9\9\9\9for i = 1 - outlineWidth, outlineWidth - 1 do\
\9\9\9\9\9\9\9thickendOutline[x + i] = thickendOutline[x + i] or {}\
\9\9\9\9\9\9\9thickendOutline[x][y + i] = true\
\9\9\9\9\9\9end\9\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9xScanline( 1, self.width, 1, self.leftOutlineWidth )\
\9xScanline( self.width, 1, -1, self.rightOutlineWidth )\
\9yScanline( 1, self.height, 1, self.topOutlineWidth )\
\9yScanline( self.height, 1, -1, self.bottomOutlineWidth )\
\
\9self.outline = thickendOutline\
\9return thickendOutline\
end",
  },
  ApplicationEventManager = {
    [ "text/lua" ] = "\
class \"ApplicationEventManager\" extends \"EventManager\" {\
\9handlesGlobal = false;\
}\
\
--[[\
\9@instance\
\9@desc Perfoms the appropriate handles for the given event and then trickles them down through the owner's children\
\9@param [Event] event -- the event to handle\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function ApplicationEventManager:handleEvent( event )\
\9-- run the before phase handles first\
\9if self:handleEventPhase( event, Event.phases.BEFORE ) then\
\9\9return true\
\9end\
\
\9-- start trickling the event down\
\9local container = self.owner.container\
\9if container and container.event:handleEvent( event ) then\
\9\9return true\
\9end\
\
\9-- if nothing has killed the flow yet run the after phases\
\9return self:handleEventPhase( event, Event.phases.AFTER )\
end\
\
function ApplicationEventManager:connectGlobal()\
\9error( \"Cannot connect global handle on ApplicationEventManager as it is the global handler. Use the class' own manager.\", 0 )\
end\
\
function ApplicationEventManager:disconnectGlobal()\
\9error( \"Cannot disconnect global handle on ApplicationEventManager as it is the global handler. Use the handler's own manager.\", 0 )\
end",
  },
  Label = {
    [ "text/lua" ] = "\
class \"Label\" extends \"View\" {\
\
    text = false;\
    isAutosizing = true;\
    font = false;\
    textObject = false;\
    needsAutosize = false;\
\9\
}\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Label:initialiseCanvas()\
    self:super()\
    local width, height, theme, canvas = self.width, self.height, self.theme, self.canvas\
    local textObject = canvas:insert( Text( 1, 1, width, height, self.text ) )\
\
    theme:connect( textObject, \"textColour\" )\
    theme:connect( canvas, \"fillColour\" )\
    self.textObject = textObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
function Label:updateThemeStyle()\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
function Label.font:set( font )\
    self.font = font\
    local textObject = self.textObject\
    if textObject then\
        self.textObject.font = font\
        self.needsAutosize = true\
    end\
end\
\
function Label:updateWidth( width )\
    self.textObject.width = width\
end\
\
function Label.text:set( text )\
    self.text = text\
    self.textObject.text = text\
    self.needsAutosize = true\
end\
\
function Label.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function Label:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsAutosize then\
        self:autosize()\
    end\
end\
\
--[[\
    @instance\
    @desc Automatically resizes the button, regardless of isAutosizing value, to fit the text\
]]\
function Label:autosize()\
    -- TODO: support self.isAutosizing\
    local font, text = self.font, self.text\
\
    if font and text then\
        local fontWidth = font:getWidth( text )\
        self.width = fontWidth\
        self.height = font.height\
    end\
    self.needsAutosize = false\
end",
  },
  ScrollView = {
    [ "text/lua" ] = "-- TODO: scrolling quickly then the opposite way reverses speed (not stops it)\
\
\
local exp = math.exp\
\
local SCROLL_DECAY = -8\
local SCROLL_SPEED = 180\
local SCROLL_ACCELERATION = 1.2--0.97\
local SPEED_CUTOFF = 0.2\
\
class \"ScrollView\" extends \"Container\" {\
\9contents = false;\
\9horizontalScrollbar = false;\
\9verticalScrollbar = false;\
\9container = false;\
\9verticalVelocityTime = 0;\
\9verticalVelocity = 0;\
\9horizontalVelocity = 0;\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function ScrollView:initialise( ... )\
\9self:super( ... )\
\
\9local width, height = self.width, self.height\
\9self.verticalScrollbar = self:insert( Scrollbar( { isHorizontal = false, x = width - Scrollbar.width + 1, height = height } ) )\
\9self.container = self:insert( ScrollContainer( { x = 1, y = 1, width = width, height = height } ) )\
    -- self:sendToFront( self.horizontalScrollbar )\
    self:sendToFront( self.verticalScrollbar )\
\
    self:event( LoadedInterfaceEvent, self.onInterfaceLoaded )\
    self:event( MouseScrollEvent, self.onMouseScroll )\
end\
\
function ScrollView:initialiseCanvas()\
\9self:super()\
\
\9self.theme:connect( self.canvas, \"fillColour\" )\
end\
\
function ScrollView:onInterfaceLoaded( Event event, Event.phases phase )\
    local currentContainer = self.container\
    for i, childView in ipairs( self.children ) do\
        if childView ~= currentContainer and childView:typeOf( ScrollContainer ) then\
            childView.x = 1\
            childView.y = 1\
            self:remove( currentContainer )\
            self.container = childView\
            -- self:sendToFront( self.horizontalScrollbar )\
\9\9\9self.verticalScrollbar:getScroller()\
            self:sendToFront( self.verticalScrollbar )\
            break\
        end\
    end\
end\
\
function ScrollView:updateContainerSize()\
\9local container = self.container\
\9-- if container.width > self.width then\
\9-- else\
\9-- end\
\
\9if container.height > self.height then\
\9\9if not self.verticalScrollbar then\
\9\9\9self.verticalScrollbar = self:insert( Scrollbar( { isHorizontal = false, x = self.width - Scrollbar.width + 1, height = self.height } ) )\
\9\9end\
\9else\
\9\9self:remove( self.verticalScrollbar )\
\9end\
end\
\
function ScrollView:updateWidth( width )\
    width = self.width\
\9local verticalScrollbar = self.verticalScrollbar\
\9if verticalScrollbar then verticalScrollbar.x = width - verticalScrollbar.width + 1 end\
end\
\
function ScrollView:updateHeight( height )\
    height = self.height\
\9local verticalScrollbar = self.verticalScrollbar\
\9if verticalScrollbar then self.verticalScrollbar.height = height end\
end\
\
--[[\
\9@instance\
\9@desc Set vertical scroll offset of the contents\
\9@param [number] offsetY -- the vertical offset\
]]\
function ScrollView:setOffsetY( offsetY, isVelocity )\
\9local container = self.container\
\9if container then\
\9\9local height = self.height\
\9\9local currentOffsetY = self.offsetY\
\9\9local realOffsetY = math.max( math.min( offsetY, math.max( container.height - height, 0 ) ), 0 )\
\9\9self.raw.offsetY = realOffsetY\
\9\9local verticalScrollbar = self.verticalScrollbar\
\9\9if verticalScrollbar then verticalScrollbar:getScroller() end\
\9\9if realOffsetY ~= offsetY then\
\9\9\9self.verticalVelocity = 0\
\9\9\9self.verticalVelocityTime = 0\
\9\9end\
\9\9container.y = 1 - math.floor( realOffsetY + 0.5 )\
\9end\
end\
\
\
function ScrollView:update( deltaTime )\
\9self:super( deltaTime )\
\9local verticalVelocity = self.verticalVelocity\
\9if verticalVelocity ~= 0 then\
\9\9local startTime\
\9\9local time = self.verticalVelocityTime\
\9\9local newVerticalVelocity = verticalVelocity * exp( SCROLL_DECAY * (time + deltaTime) )\
\9\9local distance\
\9\9if math.abs( newVerticalVelocity ) <= SPEED_CUTOFF then\
\9\9\9self.verticalVelocity = 0\
\9\9\9self.verticalVelocityTime = 0\
\9\9else\
\9\9\9self.verticalVelocityTime = time + deltaTime\
\9\9\9local currentVerticalVelocity = verticalVelocity * exp( SCROLL_DECAY * time )\
\9\9\9self:setOffsetY( self.offsetY + (currentVerticalVelocity - newVerticalVelocity) / SCROLL_DECAY, true )\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Scrolls the scroll view to the offset given, animating the value\
\9@param [number] offsetY -- the direction/distance to scroll\
]]\
function ScrollView:scrollTo( offsetY )\
\9-- calculate the velocity required to reach a certain point\
\9-- see https://www.desmos.com/calculator/qis3qhbsvs for details\
\9-- d = vi / a * ( 1 - e ^ ln( vf / vi ) )\
\
\9-- it turns out that this is far easier than oeed first thought, having spent many, many hours playing with integrals...\
\9-- it's simply: vi = a * d + vf\
\9-- hence: (vi - vf)/a = d\
\9local deltaOffsetY = offsetY - self.offsetY\
\9local velocity = SCROLL_DECAY * deltaOffsetY + SPEED_CUTOFF\
\9self.verticalVelocity = velocity\
\9self.verticalVelocityTime = 0\
\9-- self.offsetY = self.offsetY + direction\
\9-- TODO: horizontal scrolling\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is scrolled over the scroll view\
\9@param [Event] event -- the mouse scroll event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function ScrollView:onMouseScroll( Event event, Event.phases phase )\
\9if self.isEnabled then\
\9\9local direction = event.direction\
\9\9local verticalVelocity = self.verticalVelocity\
\9\9instantaneousVelocity = verticalVelocity and verticalVelocity * exp( SCROLL_DECAY * (self.verticalVelocityTime or 0) ) or 0\
\9\9self.verticalVelocityTime = 0\
\9\9if direction * verticalVelocity > 1 then\
\9\9\9self.verticalVelocity = -direction * math.abs(instantaneousVelocity + direction * SCROLL_SPEED) ^ SCROLL_ACCELERATION\
\9\9else\
\9\9\9self.verticalVelocity = -direction * SCROLL_SPEED\
\9\9end\
\9\9-- self:scroll( event.direction * SCROLL_SPEED )\
\9end\
\9return true\
end",
  },
  View = {
    [ "text/lua" ] = "\
local DEFAULT_TIME = .3\
local DEFAULT_EASING = Animation.easings.IN_OUT_SINE\
\
local function newAnimation( self, label, time, values, easing, onFinish, round )\
\9local animations = self.animations\
\9for i = #animations, 1, -1 do\
\9\9if animations[i].label == label then\
\9\9\9table.remove( animations, i )\
\9\9end\
\9end\
\9\
\9-- prevent values that won't change from being animated\
\9local hasValue = false\
\9for k, v in pairs( values ) do\
\9\9if self[k] == v then\
\9\9\9values[k] = nil\
\9\9else\
\9\9\9hasValue = true\
\9\9end\
\9end\
\9if not hasValue then return end\
\9local animation = Animation( time, self, values, easing, round == nil and true or round )\
\9animations[#animations + 1] = { label = label, animation = animation, onFinish = onFinish }\
end\
\
class \"View\" {\
\9x = false;\
\9y = false;\
\9width = false;\
\9height = false;\
\9index = false; -- the z index in its parent\
\9parent = false;\
\9siblings = false;\
\9identifier = false;\
\9interfaceProperties = false; -- the properties the view was given in the interface XML file\
\
\9animations = {};\
\
\9event = false;\
\9canvas = false;\
\9theme = false;\
\9isCanvasHitTested = true;\
\9isVisible = true;\
\9isFocused = false;\
\9isSingleFocusOnly = false; -- whether only this view can be in-focus when focused (i.e. so 3 textboxes aren't focused at the same time)\
\9isFocusDismissable = true; -- whether clicking away from the view when focused will unfocus it\
\9isEnabled = true;\
\
\9isFirst = Boolean;\
\9isLast = Boolean; -- TODO: .isReadOnly\
\
\9stringConstraints = {}; -- the constraints strings\
\9loadedConstraints = {}; -- the parsed constraints\
\9constraintsNeedingUpdate = {}; -- the constraints that need to be refreshed next update\
\9needsConstraintUpdate = {}; -- whether the constraint values have changed and the view needs to be informed\
\9references = {};\
\9lastMouseDown = {};\
\9lastMouseUp = {};\
\9--[[ format:\
\9\9{\
\9\9\9[property] = {\
\9\9\9\9[reference1 (string)] = true;\
\9\9\9\9[reference2 (string)] = true;\
\9\9\9}\
\9\9}\
\9]]\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a view instance\
\9@param [table] properties -- the properties for the view\
]]\
function View:initialise( properties )\
\9self.animations.names = {} \
\9self:initialiseEventManager()\
\9self:initialiseTheme()\
\9self:initialiseCanvas()\
\
\9-- setmetatable( self.stringConstraints, {\
\9-- \9__index = { parent = self }, __newindex = function( t, k, v )\
\9-- \9\9if t.parent.identifier == \"testview\" then\
\9-- \9\9end\
\9-- \9\9rawset( t, k, v )\
\9-- \9end\
\9-- } )\
\9\
\9if properties and type( properties ) == \"table\" then\
\9\9-- TODO: replace\
\9\9for k, v in pairs(properties) do\
\9\9\9self[k] = v\
\9\9\9-- Code here...\
\9\9end\
\9\9-- self:properties( properties )\
\9end\
\
    self:event( ParentResizedInterfaceEvent, self.onParentResizedConstraintUpdate )\
    self:event( ParentChangedInterfaceEvent, self.onParentChangedConstraintUpdate )\
    self:event( MouseDownEvent, self.onMouseDownMetaEvents )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUpMetaEvents )\
    self:event( ReadyInterfaceEvent, self.onReadyConstraintUpdate )\
end\
\
function View:initialiseTheme()\
\9self.theme = ThemeOutlet( self )\
end\
\
--[[\
\9@instance\
\9@desc Initialises the view's event manager (used for overriding)\
]]\
function View:initialiseEventManager()\
\9self.event = EventManager( self )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function View:initialiseCanvas()\
\9self.canvas = Canvas( self.x or 1, self.y or 1, self.width or 1, self.height or 1, self )\
end\
\
--[[\
\9@instance\
\9@desc Returns the view's siblings in it's container\
\9@return [table] siblings -- an array of the siblings\
]]\
function View.siblings:get()\
\9local siblings = {}\
\
\9if self.parent then\
\9\9for i, child in ipairs( self.parent.children ) do\
\9\9\9if child ~= self then\
\9\9\9\9siblings[#siblings + 1] = child\
\9\9\9end\
\9\9end\
\9end\
\
\9return siblings\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the view is the first child of it's parent\
\9@return [boolean] isFirst -- whether  the view is the first child of it's parent\
]]\
function View.isFirst:get()\
    return self.index == 1\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the view is the last child of it's parent\
\9@return [boolean] isLast -- whether  the view is the last child of it's parent\
]]\
function View.isLast:get()\
    local parent = self.parent\
    return parent and (self.index == #parent.children) or false\
end\
\
--[[\
\9@instance\
\9@desc Returns whether the control is enabled, rising up to the parent containers as well\
\9@return [boolean] isEnabled -- whether the view is enabled\
]]\
function View.isEnabled:get()\
\9if not self.isEnabled then\
\9\9return false\
\9else\
\9\9local parent = self.parent\
\9\9if parent and not parent.isEnabled then\
\9\9\9return false\
\9\9else\
\9\9\9return true\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns the index of the view in it's parent. 1 is the bottom most view\
\9@return [number] index -- an array of the siblings\
]]\
function View.index:get()\
\9if self.parent then\
\9\9for i, child in ipairs( self.parent.children ) do\
\9\9\9if child == self then\
\9\9\9\9return i\
\9\9\9end\
\9\9end\
\9end\
\9return 1\
end\
\
--[[\
\9@instance\
\9@desc Sets the z index of the view in it's parent container\
\9@param [number] index\
]]\
function View.index:set( index )\
\9local parent = self.parent\
\9if parent then\
\9\9local containerChildren = parent.children\
\9\9index = math.max( math.min( index, #containerChildren), 1 )\
\
\9\9local currentIndex\
\9\9for i, child in ipairs( containerChildren ) do\
\9\9\9if child == self then\
\9\9\9\9currentIndex = i\
\9\9\9\9break\
\9\9\9end\
\9\9end\
\
\9\9if currentIndex ~= index then\
\9\9\9table.remove( containerChildren, currentIndex )\
\9\9\9table.insert( containerChildren, index, self )\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns the view's siblings in it's container that are of or inherit from the given class\
\9@param [class] _class -- the class type\
\9@return [table] siblings -- an array of the siblings\
]]\
function View:siblingsOfType( _class )\
\9local siblings = {}\
\
\9for i, sibling in ipairs( self.siblings ) do\
\9\9if sibling:typeOf( _class ) then\
\9\9\9siblings[#siblings + 1] = sibling\
\9\9end\
\9end\
\
\9return siblings\
end\
\
-- View:alias( View.x, \"left\" )\
-- View:alias( View.y, \"top\" )\
\
-- object.left is the raw left value (i.e. a number, or nil if not yet calculated)\
-- object.loadedConstraints.left is the parsed and simplified left value\
-- object.stringConstraints.left is the string constraint\
\
--[[\
\9@instance\
\9@desc Parses a constraint and simplifies it\
\9@param [string] property - the constraint to parse and simplify\
\9@return [table] parsed - the parsed and simplified constraint\
]]\
function View:parseConstraint( property )\
\9local loaded = self.loadedConstraints\
\9if loaded[property] then return loaded[property] end\
\
\9local constraints = self.stringConstraints\
\9local constraintString = constraints[property]\
\9\
\9if not constraintString then\
\9\9-- solve it based on other constraints\
\9\9local left, right, top, bottom, width, height = constraints.left or \"1\", constraints.right or \"1\", constraints.top or \"1\", constraints.bottom or \"1\", constraints.width or \"1\", constraints.height or \"1\"\
\
\9\9if property == \"width\" then\
\9\9\9constraintString = \"(\" .. right .. \")-(\" .. left .. \")+1\"\
\9\9elseif property == \"height\" then\
\9\9\9constraintString = \"(\" .. bottom .. \")-(\" .. top .. \")+1\"\
\9\9elseif property == \"left\" then\
\9\9\9constraintString = \"(\" .. right .. \")-(\" .. width .. \")+1\"\
\9\9elseif property == \"right\" then\
\9\9\9constraintString = \"(\" .. width .. \")+(\" .. left .. \")-1\"\
\9\9elseif property == \"top\" then\
\9\9\9constraintString = \"(\" .. bottom .. \")-(\" .. height .. \")+1\"\
\9\9elseif property == \"bottom\" then\
\9\9\9constraintString = \"(\" .. top .. \")+(\" .. height .. \")-1\"\
\9\9else\
\9\9\9constraintString = \"0\"\
\9\9end\
\9end\
\
\9local parsed = MathParser.static:parseString( tostring( constraintString ) )\
\9MathParser.static:simplify( parsed )\
\
\9loaded[property] = parsed\
\9return parsed\
end\
\
--[[\
\9@instance\
\9@desc Evaluates the numerical value of a constraint\
\9@param [string] property -- the name of the property (i.e. left, width, etc.)\
\9@return [number] value -- the numerical value\
]]\
function View:evalConstraint( property )\
\9local references = {}\
\9local parsed = self:parseConstraint( property )\
\9local resolved = MathParser.static:resolve( parsed, self, property, references )\
\9local value = MathParser.static:eval( resolved )\
\
\9local oldValue = self.raw[property]\
\9if oldValue ~= value then\
\9\9self.raw[property] = value\
\9\9self.references[property] = references\
\9\9\
\9\9self.needsConstraintUpdate[self:updateConstraint( property, value )] = true\
\9end\
\9return value\
end\
\
function View:updateConstraint( property, value )\
\9local stringConstraints = self.stringConstraints\
\9local canvas = self.canvas\
\9if property == \"top\" then\
\9\9self.raw.y = value\
\9\9if canvas then canvas.y = value end\
\9\9return \"y\"\
\9elseif property == \"bottom\" then\
\9\9if stringConstraints.height then\
\9\9\9value = value - self.height + 1\
\9\9\9self.raw.y = value\
\9\9\9if canvas then canvas.y = value end\
\9\9\9return \"y\"\
\9\9else\
\9\9\9value = value - self.y + 1\
\9\9\9self.raw.height = value\
\9\9\9if canvas then canvas.height = value end\
\9\9\9return \"height\"\
\9\9end\
\9elseif property == \"left\" then\
\9\9self.raw.x = value\
\9\9if canvas then canvas.x = value end\
\9\9return \"x\"\
\9elseif property == \"right\" then\
\9\9if stringConstraints.width then\
\9\9\9value = value - self.width + 1\
\9\9\9self.raw.x = value\
\9\9\9if canvas then canvas.x = value end\
\9\9\9return \"x\"\
\9\9else\
\9\9\9value = value - self.x + 1\
\9\9\9self.raw.width = value\
\9\9\9if canvas then canvas.width = value end\
\9\9\9return \"width\"\
\9\9end\
\9elseif property == \"width\" then\
\9\9self.raw.width = value\
\9\9if canvas then canvas.width = value end\
\9\9return \"width\"\
\9elseif property == \"height\" then\
\9\9self.raw.height = value\
\9\9if canvas then canvas.height = value end\
\9\9return \"height\"\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the parent changes. This updates constraints.\
\9@param [ParentChangedInterfaceEvent] event -- the event\
]]\
function View:onParentChangedConstraintUpdate( Event event, Event.phases phase )\
\9for k, v in pairs( self.stringConstraints ) do\
\9\9self.constraintsNeedingUpdate[k] = true\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the interface is loaded and ready. This updates constraints.\
\9@param [ReadyInterfaceEvent] event -- the event\
]]\
function View:onReadyConstraintUpdate( Event event, Event.phases phase )\
\9if event.isInit then\
\9\9for k, v in pairs( self.stringConstraints ) do\
\9\9\9self.constraintsNeedingUpdate[k] = true\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the parent resizes. This updates constraints.\
\9@param [ParentResizedInterfaceEvent] event -- the event\
]]\
function View:onParentResizedConstraintUpdate( Event event, Event.phases phase )\
\9local isHorizontal = event.isHorizontal\
\9local isVertical = event.isVertical\
\9local ident = self.identifier\
\9for k, v in pairs( self.stringConstraints ) do\
\9\9local isKHorizontal = ( k == \"left\" or k == \"right\" or k == \"width\" )\
\9\9if isHorizontal and isKHorizontal then\
\9\9\9self.constraintsNeedingUpdate[k] = true\
\9\9elseif isVertical and not isKHorizontal then\
\9\9\9self.constraintsNeedingUpdate[k] = true\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Re-evaluates a constraint, reparsing if necessary.\
\9@param [string] property -- the name of the property (i.e. left, width, etc.)\
\9@param [boolean] isReferenceChange -- false if it should re-parse the constraint\
\9@return [number] value\
\
\9@note - call when a reference changes with true\
\9@note - call when the constraint changes with false\
]]\
function View:reloadConstraint( property, isReferenceChange )\
\9if not isReferenceChange then\
\9\9self.loadedConstraints[property] = nil\
\9end\
\9return self:evalConstraint( property )\
end\
\
-- @instance\
-- function View.top:get()\
-- \9return self.top or self:evalConstraint \"top\"\
-- end\
\
-- -- @instance\
-- function View.top:set( top )\
\9-- if top then\
\9-- \9self.stringConstraints.top = top\
\9-- \9self:reloadConstraint \"top\"\
\9-- else\
\9-- \9self.stringConstraints.top = nil\
\9-- end\
-- end\
\
-- -- @instance\
-- function View.bottom:get()\
-- \9return self.bottom or self:evalConstraint \"bottom\"\
-- end\
\
-- -- @instance\
-- function View.bottom:set( bottom )\
-- \9if bottom then\
-- \9\9local stringConstraints = self.stringConstraints\
-- \9\9stringConstraints.bottom = bottom\
-- \9\9self:reloadConstraint \"bottom\"\
-- \9\9if stringConstraints.height then\
-- \9\9\9stringConstraints.top = nil\
-- \9\9elseif stringConstraints.top then\
-- \9\9\9stringConstraints.height = nil\
-- \9\9end\
-- \9else\
-- \9\9self.stringConstraints.top = nil\
-- \9end\
-- end\
\
-- @instance\
-- function View.left:get()\
-- \9return self.left or self:evalConstraint \"left\"\
-- end\
\
-- -- @instance\
-- function View.left:set( left )\
\9-- local value\
\9-- if left then\
\9-- \9local stringConstraints = self.stringConstraints\
\9-- \9stringConstraints.left = left\
\9-- \9value = self:reloadConstraint \"left\"\
\9-- \9if stringConstraints.width then\
\9-- \9\9stringConstraints.right = nil\
\9-- \9elseif stringConstraints.right then\
\9-- \9\9stringConstraints.width = nil\
\9-- \9end\
\9-- else\
\9-- \9self.stringConstraints.left = nil\
\9-- end\
\9-- return value\
-- end\
\
-- -- @instance \
-- function View.right:get()\
-- \9return self.right or self:evalConstraint \"right\"\
-- end\
\
-- -- @instance \
-- function View.right:set( right )\
-- \9local value\
-- \9if right then\
-- \9\9local stringConstraints = self.stringConstraints\
-- \9\9stringConstraints.right = right\
-- \9\9value = self:reloadConstraint \"right\"\
-- \9\9if stringConstraints.width then\
-- \9\9\9stringConstraints.left = nil\
-- \9\9elseif stringConstraints.left then\
-- \9\9\9stringConstraints.width = nil\
-- \9\9end\
-- \9else\
-- \9\9self.stringConstraints.right = nil\
-- \9end\
-- \9return value\
-- end\
\
-- @instance \
function View.width:get()\
\9return self.width or self:evalConstraint \"width\"\
end\
\
-- @instance \
function View.width:set( width )\
\9local value\
\9if width then\
\9\9local stringConstraints = self.stringConstraints\
\9\9stringConstraints.width = width\
\9\9value = self:reloadConstraint \"width\"\
\9\9if stringConstraints.left then\
\9\9\9stringConstraints.right = nil\
\9\9elseif stringConstraints.right then\
\9\9\9stringConstraints.left = nil\
\9\9end\
\9else\
\9\9self.stringConstraints.width = nil\
\9end\
\9return value\
end\
\
-- @instance \
function View.height:get()\
\9return self.height or self:evalConstraint \"height\"\
end\
\
-- @instance \
function View.height:set( height )\
\9local value\
\9if height then\
\9\9local stringConstraints = self.stringConstraints\
\9\9stringConstraints.height = height\
\9\9value = self:reloadConstraint \"height\"\
\9\9if stringConstraints.top then\
\9\9\9stringConstraints.bottom = nil\
\9\9elseif stringConstraints.bottom then\
\9\9\9stringConstraints.top = nil\
\9\9end\
\9else\
\9\9self.stringConstraints.height = nil\
\9end\
\9return value\
end\
\
function View.isVisible:set( isVisible )\
\9self.canvas.isVisible = isVisible\
\9self.isVisible = isVisible\
end\
\
function View.isVisible:get()\
\9return self.parent and self.isVisible -- if we don't have a parent we're effectively not visible\
end\
\
--[[\
\9@instance\
\9@desc Converts the local coordinates to local coordinates of a parent (or global if nil) to.\
\9@param [number] x -- the local x coordinate\
\9@param [number] y -- the local y coordinate\
\9@param [View] parent -- the parent to convert to\
\9@return [number] x -- the x coordinate in the parent's coordinate system\
\9@return [number] y -- the x coordinate in the parent's coordinate system\
]]\
function View:coordinatesTo( x, y, parent )\
\9parent = parent or self.application.container\
\
\9local currentParrent = { parent = self }\
\9while currentParrent.parent and currentParrent.parent ~= parent do\
\9\9currentParrent = currentParrent.parent\
\9\9x = x + currentParrent.x - 1\
\9\9y = y + currentParrent.y - 1\
\9end\
\9return x, y\
end\
\
--[[\
\9@instance\
\9@desc Converts the position of the view to the coordinates in a parent (or global if nil)\
\9@param [View] parent -- the parent to convert to\
\9@return [number] x -- the x coordinate in the parent's coordinate system\
\9@return [number] y -- the x coordinate in the parent's coordinate system\
]]\
function View:position( parent )\
\9if not self.parent or parent == self.parent then\
\9\9return self.x, self.y\
\9else\
\9\9local x, y = self:coordinatesTo( 1, 1, parent )\
\9\9return x, y\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Converts the coordinates of a parent (or global if nil) to local coordinates.\
\9@param [number] x -- the x coordinate\
\9@param [number] y -- the y coordinate\
\9@param [View] parent -- the parent to convert from\
\9@return [number] x -- the local x coordinate\
\9@return [number] y -- the local x coordinate\
]]\
function View:coordinates( x, y, parent )\
\9parent = parent or self.application.container\
\9\
\9local currentParrent = self\
\9while currentParrent and currentParrent ~= parent do\
\9\9x = x - currentParrent.x + 1\
\9\9y = y - currentParrent.y + 1\
\9\9currentParrent = currentParrent.parent\
\9end\
\
\9return x, y\
end\
\
--[[\
\9@instance\
\9@desc Hit test the view realative to its parent's coordinates\
\9@param [number] x -- the x coordinate to hit test\
\9@param [number] y -- the y coorindate to hit test\
\9@return [boolean] isHit -- whether the hit test hit\
]]\
function View:hitTest( x, y )\
\9local _x, _y = self.x, self.y\
\9return self.isVisible and _x <= x\
\9   and x <= _x + self.width - 1\
\9   and _y <= y and y <= _y + self.height - 1\
\9   and ( not self.isCanvasHitTested or self.canvas:hitTest( x - _x + 1, y - _y + 1 ) )\
end\
\
--[[\
\9@instance\
\9@desc Hit tests the view with an event relative to the parent, uses the coordinates if it's a MouseEvent, otherwise it will always return true\
\9@param [Event] event -- the event\
\9@param [View] parent -- the parent\
\9@return [boolean] isHit -- whether the hit test hit\
]]\
function View:hitTestEvent( event, parent )\
\9parent = parent or self.parent\
\9if not parent then return false\
\9elseif event:typeOf( MouseEvent ) then\
\9\9event:makeRelative( parent )\
\9\9local x, y = event.x, event.y\
\9\9return self:hitTest( x, y )\
\9else\
\9\9return true\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Update the animation\
\9@param [number] deltaTime -- time since last update\
]]\
function View:update( dt )\
\9local animations = self.animations\
\9for i = #animations, 1, -1 do\
\9\9local animation = animations[i]\
\9\9animation.animation:update( dt )\
\9\9if animation.animation.time >= animation.animation.duration then\
\9\9\9table.remove( animations, i )\
\9\9\9if animation.onFinish then\
\9\9\9\9animation.onFinish( self )\
\9\9\9end\
\9\9end\
\9end\
\
\9local constraintsNeedingUpdate = self.constraintsNeedingUpdate\
\9local constraintOrder = { \"width\", \"height\", \"left\", \"top\", \"bottom\", \"right\" }\
\9for i, v in ipairs( constraintOrder ) do\
\9\9if constraintsNeedingUpdate[v] then\
\9\9\9self:reloadConstraint( v, true )\
\9\9\9constraintsNeedingUpdate[v] = nil\
\9\9end\
\9end\
\
\9-- if self.hasInitialised then\
\9\9local needsConstraintUpdate = self.needsConstraintUpdate\
\9\9for k, isChanged in pairs( needsConstraintUpdate ) do\
\9\9\9if isChanged then\
\9\9\9\9local _k = k == \"x\" and \"updateX\" or k == \"y\" and \"updateY\" or k == \"width\" and \"updateWidth\" or k == \"height\" and \"updateHeight\"\
\9\9\9\9if self:isDefined( _k ) then\
\9\9\9\9\9self[_k]( self, self.raw[k] )\
\9\9\9\9end\
\9\9\9\9needsConstraintUpdate[k] = false\
\9\9\9end\
\9\9end\
\9-- end\
end\
\
--[[/\
\9@instance\
\9@desc Animate a change in a certain property\
\9@param [string] propertyName -- the name of the property\
\9@param [number] value -- the target value\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [boolean] round -- whether values are rounded. For keyframe animations, the keyframes will not be tweened between.\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animate( propertyName, value, time, onFinish, easing, delay, round )\
\9local addAnimation = function()\
\9\9newAnimation( self, propertyName, time or DEFAULT_TIME, { [propertyName] = value }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish, round )\
\9end\
\9if not delay or type( delay ) ~= 'number' or delay < 0.05 then\
\9\9addAnimation()\
\9else\
\9\9self.application:schedule(addAnimation, delay)\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the x coordinate\
\9@param [number] x -- the target x coordinate\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateX( x, time, onFinish, easing, delay )\
\9local addAnimation = function()\
\9\9newAnimation( self, \"x\", time or DEFAULT_TIME, { x = x }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
\9end\
\9if not delay or type( delay ) ~= 'number' or delay < 0.05 then\
\9\9addAnimation()\
\9else\
\9\9self.application:schedule(addAnimation, delay)\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the y coordinate\
\9@param [number] y -- the target y coordinate\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateY( y, time, onFinish, easing, delay )\
\9local addAnimation = function()\
\9\9newAnimation( self, \"y\", time or DEFAULT_TIME, { y = y }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
\9end\
\9if not delay or type( delay ) ~= 'number' or delay < 0.05 then\
\9\9addAnimation()\
\9else\
\9\9self.application:schedule(addAnimation, delay)\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the width\
\9@param [number] width -- the target width\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateWidth( width, time, onFinish, easing, delay )\
\9local addAnimation = function()\
\9\9newAnimation( self, \"width\", time or DEFAULT_TIME, { width = width }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
\9end\
\9if not delay or type( delay ) ~= 'number' or delay < 0.05 then\
\9\9addAnimation()\
\9else\
\9\9self.application:schedule(addAnimation, delay)\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the height\
\9@param [number] height -- the target height\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateHeight( height, time, onFinish, easing, delay )\
\9local addAnimation = function()\
\9\9newAnimation( self, \"height\", time or DEFAULT_TIME, { height = height }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
\9end\
\9if not delay or type( delay ) ~= 'number' or delay < 0.05 then\
\9\9addAnimation()\
\9else\
\9\9self.application:schedule(addAnimation, delay)\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the position\
\9@param [number] x -- the target x coordinate\
\9@param [number] y -- the target y coordinate\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:move( x, y, time, onFinish, easing )\
\9local d = false\
\9local function f()\
\9\9if not d then d = true return onFinish() end -- stops the function being called twice\
\9end\
\9self:animateX( x, time, type( onFinish ) == \"function\" and f, easing )\
\9self:animateY( y, time, type( onFinish ) == \"function\" and f, easing )\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the size\
\9@param [number] width -- the target width\
\9@param [number] height -- the target height\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:resize( width, height, time, onFinish, easing )\
\9local d = false\
\9local function f()\
\9\9if not d then d = true return onFinish() end -- stops the function being called twice\
\9end\
\9self:animateWidth( width, time, type( onFinish ) == \"function\" and f, easing )\
\9self:animateHeight( height, time, type( onFinish ) == \"function\" and f, easing )\
end\
\
local MAX_DOUBLE_CLICK_TIME = 0.8\
local MIN_MOUSE_HOLD_TIME = 0.3\
\
--[[\
\9@instance\
\9@desc Detects when the mouse is pressed. Used to fire mouse held and double click\
\9@param [MouseDownEvent] event\
]]\
function View:onMouseDownMetaEvents( Event event, Event.phases phase )\
\9local mouseButton, time = event.mouseButton, os.time()\
\9local lastMouseDown, lastMouseUp = self.lastMouseDown, self.lastMouseUp\
\
\9local thisLastMouseDown = lastMouseDown[mouseButton]\
\9if thisLastMouseDown and time - thisLastMouseDown < MAX_DOUBLE_CLICK_TIME then\
\9\9-- double click\
\9\9self.event:handleEvent( MouseDoubleClickEvent( mouseButton, event.x, event.y, event.globalX, event.globalY ) )\
\9else\
\9\9\
\9\9-- start a held timer\
\9\9local application = self.application \
\9\9if lastMouseDown.timer then\
\9\9\9application:unschedule( lastMouseDown.timer )\
\9\9end\
\
\9\9local x, y, globalX, globalY = event.x, event.y, event.globalX, event.globalY\
\9\9local n\
\9\9lastMouseDown.timer = application:schedule( function()\
\9\9\9lastMouseDown.timer = nil\
\9\9\9local thisLastMouseUp = lastMouseUp[mouseButton]\
\9\9\9if not thisLastMouseUp or thisLastMouseUp < time then\
\9\9\9\9self.event:handleEvent( MouseHeldEvent( mouseButton, x, y, globalX, globalY ) )\
\9\9\9end\
\9\9end, MIN_MOUSE_HOLD_TIME )\
\9\9n = lastMouseDown.timer\
\9end\
\9lastMouseDown[mouseButton] = time\
end\
\
--[[\
\9@instance\
\9@desc Detects when the mouse is released. Used to fire mouse held and double click\
\9@param [MouseUpEvent] event\
]]\
function View:onGlobalMouseUpMetaEvents( Event event, Event.phases phase )\
\9self.lastMouseUp[event.mouseButton] = os.time()\
end\
\
--[[\
\9@instance\
\9@desc Starts a drag and drop for the view\
\9@param [MouseDownEvent] event -- the mouse down event to start the event\
\9@param [ClipboardData] data -- the data to associate with the drag\
\9@param [boolean] hideSource -- whether the view is hidden when the drag starts\
\9@param [function] completion -- a function called when the drag and drop completes (cancelled or successful)\
\9@param [table{View}] views -- the list of views your want to be dragged (leave blank for just sel)\
]]\
function View:startDragDrop( event, data, hideSource, completion, views )\
    self.application.dragDropManager:start( views or { self }, data, event.globalX, event.globalY, hideSource, completion )\
end\
\
function View.isFocused:set( isFocused )\
    local wasFocused = self.isFocused\
    if wasFocused ~= isFocused then\
        self.isFocused = isFocused\
        -- self:updateThemeStyle()\
    end\
end\
\
function View:focus( filter )\
    self.application:focus( self, filter )\
end\
\
function View:addFocus()\
    self.application:addFocus( self )\
end\
\
function View:unfocus()\
    self.application:unfocus( self )\
end\
\
function View:clearFocus( filter )\
    self.application:clearFocus( filter )\
end\
\
function View:dispose()\
\9self.event:dispose()\
\
\9local parent = self.parent\
\9if parent then\
\9\9parent:remove( self )\
\9end\
\
\9if self.isFocused then\
\9\9self:unfocus()\
\9end\
end",
  },
  ListClipboardData = {
    [ "text/lua" ] = "\
class \"ListClipboardData\" extends \"ClipboardData\" {\
    \
    type = \"Silica:ListItem\";\
    listItem = false;\
\
}\
\
function ListClipboardData:initialise( listItem )\
    self:super()\
    self.listItem = listItem\
end",
  },
  IToolbarPressableItem = {
    [ "text/lua" ] = "\
interface \"IToolbarPressableItem\" {}",
  },
  KeyUpEvent = {
    [ "text/lua" ] = "\
class \"KeyUpEvent\" extends \"KeyEvent\" {\
    static = {\
        eventType = \"key_up\";\
    };\
}",
  },
  Checkbox = {
    [ "text/lua" ] = "\
class \"Checkbox\" extends \"View\" {\
\
    width = 7;\
    height = 7;\
\
    isPressed = false;\
    isEnabled = true;\
    isChecked = false;\
\
    checkObject = false;\
\
}\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function Checkbox:initialise( ... )\
\9self:super( ... )\
    self:event( MouseDownEvent, self.onMouseDown )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Checkbox:initialiseCanvas()\
    self:super()\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height, self.theme.fillColour, self.theme.outlineColour, self.theme.cornerRadius ) )\
    \
    local checkObject = Path( 2, 2, self.width - 2, self.height - 2, 1, 4 )\
    checkObject:lineTo( 2, 5 )\
    checkObject:lineTo( 5, 2 )\
    checkObject:close( false )\
\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( checkObject, \"outlineColour\", \"checkColour\" )\
\
    self.backgroundObject = backgroundObject\
    self.checkObject = checkObject\
    self.canvas:insert( checkObject )\
end\
\
function Checkbox:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or (self.isChecked and \"checked\" or \"default\" ) ) or ( self.isChecked and \"disabledChecked\" or \"disabled\" )\
end\
\
function Checkbox:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function Checkbox:updateWidth( width )\
    self.backgroundObject.width = width\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Checkbox.isPressed:set( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Checkbox.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Checkbox.isChecked:set( isChecked )\
    self.isChecked = isChecked\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance. Sends the event to the local handler.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Checkbox:onGlobalMouseUp( Event event, Event.phases phase )\9\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled then\
    \9\9if self:hitTestEvent( event ) then\
                self.isChecked = not self.isChecked\
    \9\9\9return self.event:handleEvent( event )\
            end\
\9\9end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Checkbox:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end",
  },
  Radio = {
    [ "text/lua" ] = "\
class \"Radio\" extends \"View\" {\
\
    width = 7;\
    height = 7;\
\
    isPressed = false;\
    isEnabled = true;\
    isChecked = false;\
\
}\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function Radio:initialise( ... )\
\9self:super( ... )\
    self:event( MouseDownEvent, self.onMouseDown )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
    end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Radio:initialiseCanvas()\
    self:super()\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height, self.theme.fillColour, self.theme.outlineColour, self.theme.cornerRadius ) )\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.backgroundObject = backgroundObject\
end\
\
function Radio:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function Radio:updateWidth( width )\
    self.backgroundObject.width = width\
end\
\
--[[\
    @instance\
    @desc Sets the checked state of the radio button. Sets all other sibling (in the same container) radios to false if being set to true\
    @param [boolean] isChecked -- the new checked state\
]]\
function Radio.isChecked:set( isChecked )\
    self.isChecked = isChecked\
    if isChecked then\
        for i, sibling in ipairs( self:siblingsOfType( Radio ) ) do\
            sibling.isChecked = false\
        end\
    end\
    self.event:handleEvent( ActionInterfaceEvent( self ) )\
    self:updateThemeStyle()\
end\
\
\
function Radio:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or (self.isChecked and \"checked\" or \"default\" ) ) or ( self.isChecked and \"disabledChecked\" or \"disabled\" )\
end\
\
function Radio.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Radio.isPressed:set( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Radio:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self:hitTestEvent( event ) then\
            self.isChecked = true\
            return self.event:handleEvent( event )\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Radio:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end",
  },
  WindowContainer = {
    [ "text/lua" ] = "\
class \"WindowContainer\" extends \"Container\" {\
\9backgroundObject = false;\
}\
\
function WindowContainer:initialise( ... )\
\9self:super( ... )\
end\
\
function WindowContainer:initialiseCanvas()\
\9self.canvas = WindowCanvas( self.x, self.y, self.width, self.height )\
\9self.backgroundObject = self.canvas:insert( Rectangle( 1, 1, self.width, self.height, Graphics.colours.WHITE ) )\
end\
\
function WindowContainer:updateHeight( height )\
\9self.backgroundObject.height = height\
end\
\
function WindowContainer:updateWidth( width )\
\9self.backgroundObject.width = width\
end",
  },
  Exception = {
    [ "text/lua" ] = "\
local exceptionClasses = {}\
local thrownExceptions = {}\
local nextID = 1\
\
function _G.try( func )\
    local ok, err = pcall( func )\
\
    if not ok and type( err ) == \"string\" then\
        local id = err:match( \"SilicaException: (%d+)\" )\
        if id then\
            local exception = thrownExceptions[tonumber( id )]\
            return function( handles )\
                for i, handle in ipairs( handles ) do\
                    if exception:typeOf( handle.catch ) or handle.default then\
                        return handle.handler( exception )\
                    end\
                end\
            end\
        end\
    end\
\
    return error( err, 0 )\
end\
\
function _G.catch( exceptionClass, handler )\
    return { catch = exceptionClass, handler = handler }\
end\
\
function _G.default( handler )\
    return { default = true, handler = handler }\
end\
\
class \"Exception\" {\
    \
    message = false;\
    level = false;\
    id = false;\
    traceback = {};\
    exceptionType = false;\
\
}\
\
--[[\
    @static\
    @desc Registers an Exception subclass to a exception type\
    @param [class] _class -- the class that was constructed\
]]\
function Exception.static:register( exceptionType, subclass )\
    exceptionClasses[exceptionType] = subclass\
end\
\
--[[\
    @static\
    @desc Registers an Exception subclass after it has just been constructed\
    @param [class] _class -- the class that was constructed\
]]\
function Exception.static:constructed( _class )\
    if _class.exceptionType then\
        Exception.register( _class.exceptionType, _class )\
    end\
end\
\
function Exception:initialise( message, level )\
    self.message = message\
    level = (level or 1) + 1\
    self.level = level\
    self.id = nextID\
    nextID = nextID + 1\
\
    local traceback = self.traceback\
    for i = 1, 5 do\
        local src = select( 2, pcall( error, \"\", i + level ) )\
        if src == \"pcall: \" then\
            break\
        else\
            traceback[i] = src:gsub( \":%s$\", \"\", 1 )\
        end\
    end\
end\
\
function Exception:throw()\
    -- TODO: check that these won't leak out of OS programs (maybe .. self.application and compare the application id)\
    local id = self.id\
    thrownExceptions[id] = self\
    error( \"SilicaException: \" .. self.id, 0 )\
end",
  },
  MouseDoubleClickEvent = {
    [ "text/lua" ] = "\
class \"MouseDoubleClickEvent\" extends \"MouseEvent\" {\
    eventType = \"mouse_double_click\";\
    mouseButton = false;\
    isSentToChildren = false;\
}\
\
--[[\
    @constructor\
    @desc Creates a mouse held event from the arguments\
    @param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
    @param [number] x -- the x screen coordinate\
    @param [number] y -- the y screen coordinate\
    @param [number] globalX -- the global x screen coordinate\
    @param [number] globalY -- the global y screen coordinate\
]]\
function MouseDoubleClickEvent:initialise( mouseButton, x, y, globalX, globalY )\
    self.mouseButton = mouseButton\
    self.x = x\
    self.y = y\
    self.globalX = globalX\
    self.globalY = globalY\
end",
  },
  ScaleableCanvas = {
    [ "text/lua" ] = "\
class \"ScaleableCanvas\" extends \"Canvas\" {\
    \
    scaleX = 1;\
    scaleY = 1;\
\
}\
\
function ScaleableCanvas.scaleX:set( scaleX )\
    if self.scaleX ~= scaleX then\
        self.hasChanged = true\
        self.scaleX = scaleX\
    end\
end\
\
function ScaleableCanvas.scaleY:set( scaleY )\
    if self.scaleY ~= scaleY then\
        self.hasChanged = true\
        self.scaleY = scaleY\
    end\
end\
\
function ScaleableCanvas:drawTo( canvas, isShadow )\
    local drawsShadow = self.drawsShadow\
    if self.isVisible then\
        if isShadow or self.hasChanged then\
            -- local drawdt = os.clock()\
            self:draw( isShadow )\
        end\
        \
        local width = self.width\
        local height = self.height\
        local fillColour = self.fillColour\
        local buffer = self.buffer\
        local scaleX = self.scaleX\
        local scaleY = self.scaleY\
        local _x = self.x - 1\
        local _y = self.y\
        \
\
        local setPixel\
        local TRANSPARENT = Graphics.colours.TRANSPARENT\
\
        local canvasWidth = canvas.width\
        local canvasHeight = canvas.height\
        local canvasBuffer = canvas.buffer\
        if isShadow then\
            local shadowColour\
            local owner = self.owner\
            if owner then\
                shadowColour = owner.theme.shadowColour\
            else\
                shadowColour = Graphics.colours.GREEN\
            end\
            setPixel = function( x, y, colour )\
                if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= canvasWidth and y <= canvasHeight then\
                    canvasBuffer[ ( y - 1 ) * canvasWidth + x ] = shadowColour\
                end\
            end\
        else\
            setPixel = function( x, y, colour )\
                if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= canvasWidth and y <= canvasHeight then\
                    canvasBuffer[ ( y - 1 ) * canvasWidth + x ] = colour\
                end\
            end\
        end\
\
        -- for x = 1, width do\
        --     for y = 0, height - 1 do -- just so there's no need for y-1 below\
        --         local colour = buffer[y * width + x] or fillColour\
        --         local nx, ny = x + _x, y + _y\
        --         setPixel( nx, ny, colour )\
        --         -- if colour ~= TRANSPARENT and nx >= 1 and ny >= 1 and nx <= canvasWidth and ny <= canvasHeight then\
        --         --     canvasBuffer[( ny - 1 ) * canvasWidth + nx] = colour\
        --         -- end\
        --     end\
        -- end\
\
        if scaleX == 1 and scaleY == 1 then\
            for x = 1, width do\
                for y = 0, height - 1 do -- just so there's no need for y-1 below\
                    local colour = buffer[y * width + x] or fillColour\
                    local nx, ny = x + _x, y + _y\
                    setPixel( nx, ny, colour )\
                end\
            end\
        else\
            local scaledWidth, scaledHeight = math.floor( width * scaleX + 0.5 ), math.floor( height * scaleY + 0.5 )\
            local ceil = math.ceil\
            local widthRatio = width / scaledWidth\
            local heightRatio = height / scaledHeight\
            local xMin, yMin = math.floor( ( width - scaledWidth ) / 2 ) + 1, math.floor( ( height - scaledHeight ) / 2 )\
\
            for x = 1, scaledWidth do\
                for y = 0, scaledHeight - 1 do -- just so there's no need for y-1 below\
                    local colour = buffer[ceil( y * heightRatio ) * width + ceil( x * widthRatio )] or TRANSPARENT\
                    local nx, ny = x + xMin + _x, y + yMin + _y\
                    setPixel( nx, ny, colour )\
                end\
            end\
        end\
\
\
    end\
    return self\
end",
  },
  Animation = {
    [ "text/lua" ] = "\
local math, assert, tostring, type = math, assert, tostring, type\
local pow, sin, cos, pi, sqrt, abs, asin = math.pow, math.sin, math.cos, math.pi, math.sqrt, math.abs, math.asin\
\
local function copyTables(destination, keysTable, valuesTable)\
    valuesTable = valuesTable or keysTable\
    local mt = getmetatable( keysTable )\
    if mt and getmetatable( destination ) == nil then\
        setmetatable(destination, mt)\
    end\
    for k,v in pairs( keysTable ) do\
        local value = valuesTable[k]\
        if type( value ) == \"table\" then\
            destination[k] = value[#value]\
        else\
            destination[k] = value\
        end\
    end\
    return destination\
end\
\
local function performEasingOnSubject(subject, targetValues, initialValues, time, duration, easingFunc, round)\
    local t,b,c,d\
    local progressPercentage, ceil, floor = false, math.ceil, math.floor\
    for k,v in pairs( targetValues ) do\
        if type( v ) == \"table\" then\
            log('keyframe')\
            -- Not sure what this for, I think keyframes would be more useful\
            -- performEasingOnSubject(subject[k], v, initialValues[k], time, duration, easingFunc)\
\
            -- Keyframe animation\
            progressPercentage = progressPercentage or easingFunc( time, 0, 1, duration )\
            local keyframe = progressPercentage * #v -- NOT an int, the progress through the keyframes. 0.5 is half way through the first keyframe\
\
            -- if round is true the keyframes values are not tweened between, they are just set when over the threshhold. This is the best approach for colours\
            if round then\
                local value = v[ ceil( keyframe ) ]\
                if subject[k] ~= value then\
                    subject[k] = value\
                end\
            else\
                -- TODO: tweenning not tested\
                local isInteger = ( keyframe % 1 == 0 )\
                if isInteger then\
                    subject[k] = v[ floor( keyframe + 0.5) ]\
                else\
                    local lowerKeyframe = floor( keyframe )\
                    local upperKeyframe = ceil( keyframe )\
                    local percentageUpper = keyframe - lowerKeyframe\
                    local lowerValue = v[ lowerKeyframe ]\
                    subject[k] = lowerValue + ( v[ upperKeyframe ] - lowerValue) * percentageUpper\
                end\
            end\
        else\
            b = initialValues[k]\
            if not b then error( \"No initial value for animation. Property name: \" .. k ) end\
            c = v - initialValues[k]\
            if round then\
                subject[k] = floor( easingFunc( time, b, c, duration ) + 0.5 )\
            else\
                subject[k] = easingFunc( time, b, c, duration )\
            end\
        end\
    end\
end\
\
class \"Animation\" {\
\9easings = Enum( Function, {} );\
\9duration = false;\
\9subject = false;\
\9targetValues = false; -- if a targetValue is an array, not a single value, the values are used as evenly spaced 'keyframes'. This can be used for colours.\
\9easingFunc = false;\
\9initialValues = false;\
\9time = false;\
    round = false;\
}\
\
--[[\
    @constructor\
    @desc Creates an animation instance for internal use\
    @param [number] duration -- the duration of the animation\
    @param [class] subject -- the subject of the animation\
    @param [class] targetValues -- the targetValues of the animation\
    @param [Animation.easing] easingFunc -- the easing function of the animation\
]]\
function Animation:initialise( duration, subject, targetValues, easingFunc, round )\
    self.duration = duration\
    self.subject = subject\
    self.targetValues = targetValues\
    self.easingFunc = easingFunc\
    self.round = round\
    self.initialValues = copyTables( {}, targetValues, subject )\
    self.time = 0\
end\
\
--[[\
\9@instance\
\9@desc Sets the animation to the specificed time point\
\9@param [number] time -- the time point\
\9@return [boolean] isComplete -- whether the animation is complete\
]]\
function Animation.time:set( time )\
\9assert( type(time ) == \"number\" and time >= 0, \"time must be a positive number or 0\")\
\
    local duration\
\9self.time = time\
\
\9if time <= 0 then\
\9\9self.time = 0\
\9\9copyTables(self.subject, self.initialValues)\
\9elseif time >= self.duration then -- the tween has expired\
\9\9self.time = self.duration\
\9\9copyTables(self.subject, self.targetValues)\
\9else\
\9\9performEasingOnSubject(self.subject, self.targetValues, self.initialValues, self.time, self.duration, self.easingFunc, self.round)\
\9end\
\
\9return self.time >= self.duration\
end\
\
--[[\
\9@instance\
\9@desc Resets the animation back to the start\
\9@return [boolean] isComplete -- whether the animation is complete\
]]\
function Animation:reset()\
\9return self:setTime( 0 )\
end\
\
--[[\
\9@instance\
\9@desc Updates the animation given a change in time, returning true if the animation is complete\
\9@param [number] deltaTime -- the change in time since the last update\
\9@return [boolean] isComplete -- whether the animation is complete\
]]\
function Animation:update( deltaTime )\
\9return self:setTime( self.time + deltaTime )\
end\
\9\
\
-- easing functions --\
\
-- linear\
function Animation.easings.LINEAR( t, b, c, d )\
\9return c * t / d + b\
end\
\
-- quad\
function Animation.easings.IN_QUAD( t, b, c, d )\
\9return c * pow(t / d, 2) + b\
end\
\
function Animation.easings.OUT_QUAD( t, b, c, d )\
\9t = t / d\
\9return -c * t * (t - 2) + b\
end\
\
function Animation.easings.IN_OUT_QUAD( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(t, 2) + b end\
\9return -c / 2 * ((t - 1) * (t - 3) - 1) + b\
end\
\
function Animation.easings.OUT_IN_QUAD( t, b, c, d )\
\9if t < d / 2 then return outQuad(t * 2, b, c / 2, d) end\
\9return inQuad((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- cubic\
function Animation.easings.IN_CUBIC ( t, b, c, d )\
\9return c * pow(t / d, 3) + b\
end\
\
function Animation.easings.OUT_CUBIC( t, b, c, d )\
\9return c * (pow(t / d - 1, 3) + 1) + b\
end\
\
function Animation.easings.IN_OUT_CUBIC( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * t * t * t + b end\
\9t = t - 2\
\9return c / 2 * (t * t * t + 2) + b\
end\
\
function Animation.easings.OUT_IN_CUBIC( t, b, c, d )\
\9if t < d / 2 then return outCubic(t * 2, b, c / 2, d) end\
\9return inCubic((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- quart\
function Animation.easings.IN_QUART( t, b, c, d )\
\9return c * pow(t / d, 4) + b\
end\
\
function Animation.easings.OUT_QUART( t, b, c, d )\
\9return -c * (pow(t / d - 1, 4) - 1) + b\
end\
\
function Animation.easings.IN_OUT_QUART( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(t, 4) + b end\
\9return -c / 2 * (pow(t - 2, 4) - 2) + b\
end\
\
function Animation.easings.OUT_IN_QUART( t, b, c, d )\
\9if t < d / 2 then return outQuart(t * 2, b, c / 2, d) end\
\9return inQuart((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- quint\
function Animation.easings.IN_QUINT( t, b, c, d )\
\9return c * pow(t / d, 5) + b\
end\
\
function Animation.easings.OUT_QUINT( t, b, c, d )\
\9return c * (pow(t / d - 1, 5) + 1) + b\
end\
\
function Animation.easings.IN_OUT_QUINT( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(t, 5) + b end\
\9return c / 2 * (pow(t - 2, 5) + 2) + b\
end\
\
function Animation.easings.OUT_IN_QUINT( t, b, c, d )\
\9if t < d / 2 then return outQuint(t * 2, b, c / 2, d) end\
\9return inQuint((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- sine\
function Animation.easings.IN_SINE( t, b, c, d )\
\9return -c * cos(t / d * (pi / 2)) + c + b\
end\
\
function Animation.easings.OUT_SINE( t, b, c, d )\
\9return c * sin(t / d * (pi / 2)) + b\
end\
\
function Animation.easings.IN_OUT_SINE( t, b, c, d )\
\9return -c / 2 * (cos(pi * t / d) - 1) + b\
end\
\
function Animation.easings.OUT_IN_SINE( t, b, c, d )\
\9if t < d / 2 then return outSine(t * 2, b, c / 2, d) end\
\9return inSine((t * 2) -d, b + c / 2, c / 2, d)\
end\
\
-- expo\
function Animation.easings.IN_EXPO( t, b, c, d )\
\9if t == 0 then return b end\
\9return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001\
end\
\
function Animation.easings.OUT_EXPO( t, b, c, d )\
\9if t == d then return b + c end\
\9return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b\
end\
\
function Animation.easings.IN_OUT_EXPO( t, b, c, d )\
\9if t == 0 then return b end\
\9if t == d then return b + c end\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005 end\
\9return c / 2 * 1.0005 * (-pow(2, -10 * (t - 1)) + 2) + b\
end\
\
function Animation.easings.OUT_IN_EXPO( t, b, c, d )\
\9if t < d / 2 then return outExpo(t * 2, b, c / 2, d) end\
\9return inExpo((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- circ\
function Animation.easings.IN_CIRC( t, b, c, d )\
\9return(-c * (sqrt(1 - pow(t / d, 2)) - 1) + b)\
end\
\
function Animation.easings.OUT_CIRC( t, b, c, d )\
\9return(c * sqrt(1 - pow(t / d - 1, 2)) + b)\
end\
\
function Animation.easings.IN_OUT_CIRC( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return -c / 2 * (sqrt(1 - t * t) - 1) + b end\
\9t = t - 2\
\9return c / 2 * (sqrt(1 - t * t) + 1) + b\
end\
\
function Animation.easings.OUT_IN_CIRC( t, b, c, d )\
\9if t < d / 2 then return outCirc(t * 2, b, c / 2, d) end\
\9return inCirc((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- elastic\
function Animation.easings.CALCULATE_P_A_S( p,a,c,d )\
\9p, a = p or d * 0.3, a or 0\
\9if a < abs( c ) then return p, c, p / 4 end -- p, a, s\
\9return p, a, p / (2 * pi) * asin( c/a ) -- p,a,s\
end\
\
function Animation.easings.IN_ELASTIC( t, b, c, d, a, p )\
\9local s\
\9if t == 0 then return b end\
\9t = t / d\
\9if t == 1 then return b + c end\
\9p,a,s = calculatePAS( p,a,c,d )\
\9t = t - 1\
\9return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b\
end\
\
function Animation.easings.OUT_ELASTIC( t, b, c, d, a, p )\
\9local s\
\9if t == 0 then return b end\
\9t = t / d\
\9if t == 1 then return b + c end\
\9p,a,s = calculatePAS( p,a,c,d )\
\9return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b\
end\
\
function Animation.easings.IN_OUT_ELASTIC( t, b, c, d, a, p )\
\9local s\
\9if t == 0 then return b end\
\9t = t / d * 2\
\9if t == 2 then return b + c end\
\9p,a,s = calculatePAS( p,a,c,d )\
\9t = t - 1\
\9if t < 0 then return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b end\
\9return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p ) * 0.5 + c + b\
end\
\
function Animation.easings.OUT_IN_ELASTIC( t, b, c, d, a, p )\
\9if t < d / 2 then return outElastic(t * 2, b, c / 2, d, a, p) end\
\9return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)\
end\
\
-- back\
function Animation.easings.IN_BACK( t, b, c, d, s )\
\9s = s or 1.70158\
\9t = t / d\
\9return c * t * t * ((s + 1) * t - s) + b\
end\
\
function Animation.easings.OUT_BACK( t, b, c, d, s )\
\9s = s or 1.70158\
\9t = t / d - 1\
\9return c * (t * t * ((s + 1) * t + s) + 1) + b\
end\
\
function Animation.easings.IN_OUT_BACK( t, b, c, d, s )\
\9s = (s or 1.70158) * 1.525\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end\
\9t = t - 2\
\9return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b\
end\
\
function Animation.easings.OUT_IN_BACK( t, b, c, d, s )\
\9if t < d / 2 then return outBack(t * 2, b, c / 2, d, s) end\
\9return inBack((t * 2) - d, b + c / 2, c / 2, d, s)\
end\
\
-- bounce\
function Animation.easings.OUT_BOUNCE( t, b, c, d )\
\9t = t / d\
\9if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end\
\9if t < 2 / 2.75 then\
\9\9t = t - (1.5 / 2.75)\
\9\9return c * (7.5625 * t * t + 0.75) + b\
\9elseif t < 2.5 / 2.75 then\
\9\9t = t - (2.25 / 2.75)\
\9\9return c * (7.5625 * t * t + 0.9375) + b\
\9end\
\9t = t - (2.625 / 2.75)\
\9return c * (7.5625 * t * t + 0.984375) + b\
end\
\
function Animation.easings.IN_BOUNCE( t, b, c, d )\
\9return c - outBounce(d - t, 0, c, d) + b\
end\
\
function Animation.easings.IN_OUT_BOUNCE( t, b, c, d )\
\9if t < d / 2 then return inBounce(t * 2, 0, c, d) * 0.5 + b end\
\9return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b\
end\
\
function Animation.easings.OUT_IN_BOUNCE( t, b, c, d )\
\9if t < d / 2 then return outBounce(t * 2, b, c / 2, d) end\
\9return inBounce((t * 2) - d, b + c / 2, c / 2, d)\
end",
  },
  KeyboardShortcutEvent = {
    [ "text/lua" ] = "\
class \"KeyboardShortcutEvent\" extends \"Event\" {\
    static = {\
        eventType = \"interface_keyboard_shortcut\";\
    };\
\9keys = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a key event from the arguments\
\9@param [table] arguments -- the event arguments\
]]\
function KeyboardShortcutEvent:initialise( keys )\
\9self.keys = keys\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the keys in the given table match those of the event\
\9@param [table] keys -- a table of keys (key strings like { 'ctrl', 'a' })\
\9@param [type] arg2 -- description\
\9@param [type] arg3 -- description\
\9@return [type] returnedValue -- description\
]]\
function KeyboardShortcutEvent:matchesKeys( keys )\
\9local eventKeys = self.keys\
\9for i, keyString in ipairs( keys ) do\
\9\9if not eventKeys[keyString] then\
\9\9\9return false\
\9\9end\
\9end\
\
\9local eventKeysLength = 0\
\9for keyString, _ in pairs( eventKeys ) do\
\9\9eventKeysLength = eventKeysLength + 1\
\9end\
\
\9return eventKeysLength == #keys\
end",
  },
  ToolbarStaticSpace = {
    [ "text/lua" ] = "\
class \"ToolbarStaticSpace\" extends \"View\" implements \"IToolbarItem\" {\
\
    width = 12;\
\
}",
  },
  Font = {
    [ "text/lua" ] = "\
local floor, ceil = math.floor, math.ceil\
local cache = {}\
\
local function readstring( handle )\
\9local v = handle.read()\
\9local s = \"\"\
\9while v ~= 0 do\
\9\9s = s .. string.char( v )\
\9\9v = handle.read()\
\9end\
\9return s\
end\
local function writestring( handle, text )\
\9for i = 1, #text do\
\9\9handle.write( text:byte( i ) )\
\9end\
end\
\
local function renderCharacterScaledDown( setPixel, character, _x, _y, cw, ch, scale, colour )\
\9_x = _x - 1\
\9_y = _y - 1\
\9for x = 1, cw do\
\9\9for y = 1, ch do\
\9\9\9if character[y] and character[y][x] then\
\9\9\9\9setPixel( ceil( _x + x * scale - .5 ), ceil( _y + y * scale - .5 ), colour )\
\9\9\9end\
\9\9end\
\9end\
end\
\
local no_char_map = {\
\9width = 5;\
\9{ true,  true,  true,  true, true };\
\9{ true, false, false, false, true };\
\9{ true, false, false, false, true };\
\9{ true, false, false, false, true };\
\9{ true, false, false, false, true };\
\9{ true,  true,  true,  true, true };\
}\
\
class \"Font\" {\
\9height = 0;\
\9desiredHeight = 0;\
\9spacing = 1;\
\9characters = false;\
\9scale = false;\
\
\9alignments = {\
\9\9LEFT = 0;\
\9\9CENTER = 1;\
\9\9CENTRE = 1;\
\9\9RIGHT = 2;\
\9\9JUSTIFIED = 3;\
\9};\
\
\9static = {\
\9\9systemFont = Font;\
\9};\
}\
\
--[[\
\9@constructor\
\9@desc Create a font with the given name\
\9@param [string] fontName -- the name of the desired font\
\9@param [number] desiredHeight -- the height of the desired font\
\9@param [boolean] reload -- default is false, whether the cache should be ignored and the font reloaded\
]]\
function Font:initialise( name, desiredHeight, reload )\
\9local characters, height\
\9desiredHeight = desiredHeight or 8\
\9if cache[name] and cache[name][desiredHeight] and not reload then\
\9\9characters, height = cache[name][desiredHeight][1], cache[name][desiredHeight][2]\
\9else\
\9\9local resource = Resource( name, Metadata.mimes.SFONT, \"fonts\" )\
\9\9characters, height = BitmapFont.static:decodeResource( resource )\
\9\9cache[name] = cache[name] or {}\
\9\9cache[name][desiredHeight] = { characters, height }\
\9end\
\9self.characters = characters\
\9self.height = height\
\9self.desiredHeight = desiredHeight or height\
\9self.scale = ( desiredHeight or height ) / height\
end\
\
function Font.static:initialisePresets()\
\9-- TODO: make this come from the theme\
\9-- Font.systemFont = Font( \"Napier\" )\
\9Font.static.systemFont = Font( \"Auckland\" )\
end\
\
function Font.static:readMetadata( file )\
\9local h = fs.open( file, \"rb\" )\
\9if h then\
\9\9local metadata = {}\
\9\9local v = h.read()\
\9\9while v == 0 do\
\9\9\9local key, value = readstring( h ), readstring( h )\
\9\9\9metadata[key] = value\
\9\9\9v = h.read()\
\9\9end\
\9\9h.close()\
\9\9return metadata\
\9end\
end\
\
function Font.static:encodeFile( file, characters, height, metadata )\
\9local h = fs.open( file, \"wb\" )\
\9return Font.encodeHandle( handle, characters, height, metadata)\
end\
\
function Font.static:encodeHandle( h, characters, height, metadata )\
\9if h then\
\9\9for k, v in pairs( metadata or {} ) do\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( k ) )\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( v ) )\
\9\9\9h.write( 0 )\
\9\9end\
\9\9h.write( 1 )\
\9\9h.write( height )\
\9\9local bytes\
\9\9if metadata.fontType == \"vector\" then\
\9\9\9bytes = VectorFont.static:encodeSet( characters, height )\
\9\9else\
\9\9\9bytes = BitmapFont.static:encodeSet( characters, height )\
\9\9end\
\9\9for _, byte in ipairs( bytes ) do\
\9\9\9h.write( byte )\
\9\9end\
\9\9h.close()\
\9\9return true\
\9end\
end\
\
function Font.static:decodeResource( resource )\
\9-- log(resource)\
\9local contents = resource.contents\
\9-- log(resource.path)\
\9-- log(contents)\
\9if contents then\
\9\9local i = 1\
\9\9local contentsLen = #contents\
\9\9local b = string.byte\
\9\9local sub = string.sub\
\9\9local h = {}\
\
\9\9function h.read()\
\9\9\9if i <= contentsLen then\
\9\9\9\9local value = b( sub( contents, i, i ) )\
\9\9\9\9i = i + 1\
\9\9\9\9return value\
\9\9\9end\
\9\9end\
\
\9\9return Font.static:decodeHandle( h )\
\9end\
end\
\
function Font.static:decodeFile( file )\
\9local h = fs.open( file, \"rb\" )\
\9return Font.static:decodeHandle( h )\
end\
\
function Font.static:decodeHandle( h )\
\9if h then\
\9\9local metadata = {}\
\9\9local v = h.read()\
\9\9while v == 0 do\
\9\9\9local key, value = readstring( h ), readstring( h )\
\9\9\9metadata[key] = value\
\9\9\9v = h.read()\
\9\9end\
\9\9local height = h.read()\
\9\9local bytes = {}\
\9\9for byte in h.read do\
\9\9\9bytes[#bytes + 1] = byte\
\9\9end\
\
\9\9local fontType = metadata.fontType\
\9\9local characters\
\
\9\9if fontType == \"bitmap\" then\
\9\9\9characters = BitmapFont.static:decodeSet( bytes, height )\
\9\9else\
\9\9\9characters = VectorFont.static:decodeSet( bytes, height )\
\9\9end\
\9\9return characters, height, metadata\
\9end\
end\
\
function Font.height:get()\
\9return self.height\
end\
\
function Font:getWidth( text )\
\9if not text then return 0 end\
\9local width = 0\
\9local scale, characters, desiredHeight, spacing = self.scale, self.characters, self.desiredHeight, self.spacing\
\9for i = 1, #text do\
\9\9local char = text:byte( i )\
\9\9local scale, bitmap = scale -- localise scale so it can be changed if the character isn't defined\
\9\9if characters[char] then\
\9\9\9bitmap = characters[char]\
\9\9else\
\9\9\9bitmap = no_char_map\
\9\9\9scale = desiredHeight / 6\
\9\9end\
\9\9width = width + bitmap.width * scale + spacing * scale\
\9end\
\9return width - spacing\
end\
\
function Font:getRawWidth( text )\
\9if not text then return 0 end\
\9local width = 0\
\9local scale, characters, desiredHeight, spacing = self.scale, self.characters, self.desiredHeight, self.spacing\
\9for i = 1, #text do\
\9\9local char = text:byte( i )\
\9\9local scale, bitmap = scale -- localise scale so it can be changed if the character isn't defined\
\9\9if characters[char] then\
\9\9\9bitmap = characters[char]\
\9\9else\
\9\9\9bitmap = no_char_map\
\9\9\9scale = desiredHeight / 6\
\9\9end\
\9\9width = width + bitmap.width * scale\
\9end\
\9return width\
end\
\
function Font:render( canvas, text, x, y, cropWidth, cropHeight, colour )\
\9y = y - 1\
\9x = x - 1\
\9text = text == nil and \"\" or tostring( text )\
\9local buffer = canvas.buffer\
\9local width, height, _height = canvas.width, canvas.height, self.height\
\9local cropX, cropY = math.min( x + cropWidth, width ), math.min( y + cropHeight, height )\
\9local TRANSPARENT = Graphics.colours.TRANSPARENT\
\9local scale, characters, desiredHeight, spacing = self.scale, self.characters, self.desiredHeight, self.spacing\
\9local function setPixel( x, y, colour )\
\9\9if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= cropX and y <= cropY then\
\9        buffer[ ( y - 1 ) * width + x ] = colour\
\9    end\
\9end\
\9for i = 1, #text do\
\9\9local char = text:byte( i )\
\9\9local bitmap\
\9\9if characters[char] then\
\9\9\9bitmap = characters[char]\
\9\9else\
\9\9\9bitmap = no_char_map\
\9\9\9scale = desiredHeight / 6\
\9\9end\
\9\9local cwidth = bitmap.width * scale\
\9\9if scale < 1 then\
\9\9\9renderCharacterScaledDown( setPixel, bitmap, x, y, bitmap.width, _height, scale, colour )\
\9\9else\
\9\9\9for _y = 1, desiredHeight do\
\9\9\9\9for _x = 1, ceil( cwidth ) do\
\9\9\9\9\9local bx, by = ceil( _x / scale ), ceil( _y / scale )\
\9\9\9\9\9local char_is_on = bitmap[by] and bitmap[by][bx]\
\9\9\9\9\9if char_is_on then\
\9\9\9\9\9\9setPixel( floor( x + _x + .5 ), floor( y + _y + .5 ), colour ) -- oh no, not this...\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9x = x + cwidth + spacing * scale\
\9end\
end",
  },
  LeftSymbol = {
    [ "text/lua" ] = "\
class \"LeftSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"left\";\
\
    serialisedPaths = {\
        {\
            x = 1;\
            y = 1;\
            lines = {\
                {\
                    y1 = 4;\
                    x1 = 1;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 1;\
                };\
                {\
                    y1 = 1;\
                    x1 = 4;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 3;\
                };\
                {\
                    y1 = 3;\
                    x1 = 4;\
                    x2 = 7;\
                    mode = \"linear\";\
                    y2 = 3;\
                };\
                {\
                    y1 = 3;\
                    x1 = 7;\
                    x2 = 7;\
                    mode = \"linear\";\
                    y2 = 5;\
                };\
                {\
                    y1 = 5;\
                    x1 = 7;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 5;\
                };\
                {\
                    y1 = 5;\
                    x1 = 4;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 7;\
                };\
                {\
                    y1 = 7;\
                    x1 = 4;\
                    x2 = 1;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
            };\
            height = 7;\
            width = 7;\
        }\
    }\
\
\
}",
  },
  ParentResizedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"ParentResizedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_parent_resized\";\
    };\
\9isHorizontal = false;\
\9isVertical = false;\
\9isSentToSender = false;\
\9isSentToChildren = true;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a parent resized event from the arguments\
\9@param [boolean] isHorizontal -- whether the change effected the width\
\9@param [boolean] isVertical -- whether the change effected the height\
\9@param [Container] sender -- the parent that resized\
]]\
function ParentResizedInterfaceEvent:initialise( isHorizontal, isVertical, sender )\
\9self.isHorizontal = isHorizontal\
\9self.isVertical = isVertical\
\9self.sender = sender\
end\
",
  },
  MouseEvent = {
    [ "text/lua" ] = "\
class \"MouseEvent\" extends \"Event\" {\
\9x = 0;\
\9y = 0;\
\9globalX = 0;\
\9globalY = 0;\
\
\9mouseButtons = {\
\9\9LEFT = 1;\
\9\9MIDDLE = 3;\
\9\9RIGHT = 2;\
\9};\
\
\9directions = {\
\9\9UP = -1;\
\9\9DOWN = 1;\
\9};\
}\
\
\
--[[\
\9@instance\
\9@desc Make the event's coordinates relative to the supplied view\
\9@param [View] view -- the view who's coordinate system will be used\
]]\
function MouseEvent:makeRelative( view )\
\9if not view then end\
\9local oldRelativeView = self.relativeView\
\9self:super( view )\
\9\
\9local x, y = self.x, self.y\
\
\9if oldRelativeView and oldRelativeView == view then\
\9\9-- return\
\9elseif oldRelativeView and oldRelativeView == view.parent then\
\9\9-- we are going 1 downward in to the stack\
\9\9x = x - view.x + 1\
\9\9y = y - view.y + 1\
\
\9elseif oldRelativeView and oldRelativeView.parent == view then\
\9\9-- we are going 1 upward in to the stack\
\9\9x = x + oldRelativeView.x - 1\
\9\9y = y + oldRelativeView.y - 1\
\9else\
\9\9-- we don't known exactly where the previous view was\
\9\9x, y = view:coordinates( self.globalX, self.globalY, self.application.container )\
\9end\
\9self.x = x\
\9self.y = y\
end",
  },
  Application = {
    [ "text/lua" ] = "\
-- need to fix scheduling ... cancelling them won't work right now\
-- each one needs to have its own ID and return that ID\
\
class \"Application\" {\
\
\9name = false;\
\9path = false;\
\9updateTimer = false;\
\9lastUpdate = 0;\
\9arguments = {};\
\9isRunning = false;\
\9container = false;\
\9document = false;\
\9event = false;\
\9schedules = {};\
\9keyboardShortcutManager = false;\
\9dragDropManager = false;\
\9focuses = {};\
\
\9interfaceName = false;\
\
\9-- TODO: exit codes\
\9-- exitCode = {\
\9-- \9OKAY = 1;\
\9-- ERROR = 2;\
\9-- \9-- etc\
\9-- };\
\
    static = {\
        resourceFolders = {}; -- the folders in which the applications resources are\
        resourceTables = false; -- the tables of files where resources are\
    }\
\
}\
\
function Application.static:initialise( ... )\
    self.resourceTables = __resourceTables or {}\
    _G.__resourceTables = nil\
end\
\
--[[\
    @static\
    @desc Adds the given directory to the resource listing and loads any classes\
    @param [string] path -- the path to the directory of resources\
]]\
function Application.static:load( path )\
    local folder = Folder( path )\
    if folder then\
        table.insert( self.resourceFolders, folder )\
        local classesFolder = folder:folderFromPath( \"classes\" )\
        if classesFolder then\
            table.insert( class.folders, classesFolder )\
            local luaMime = Metadata.mimes.LUA\
            local function loadFolder( folder )\
                for i, fileSystemItem in ipairs( folder.items ) do\
                    if fileSystemItem.metadata.mime == luaMime then\
                        class.load( fileSystemItem.name, fileSystemItem.contents )\
                    elseif fileSystemItem:typeOf( Folder ) then\
                        loadFolder( fileSystemItem )\
                    end\
                end\
            end\
            loadFolder( folder )\
        end\
    end\
end\
\
function Application:initialise( ... )\
\9class.setApplication( self )\
\9self.event = ApplicationEventManager( self )\
\9self.keyboardShortcutManager = KeyboardShortcutManager( self )\
\9self.dragDropManager = DragDropManager( self )\
\
\9Font.static:initialisePresets()\
\9\
\9self:reloadInterface()\
\
\9self.event:connect( TimerEvent, self.onTimer )\
end\
\
--[[\
\9@instance\
\9@desc Runs the application runtime with the supplied arguments\
\9@param ... -- the arguments feed to the program (simply use ... for the arguments)\
\9@return [number] exitCode -- returns the exit code of the application\
]]\
function Application:run( ... )\
\9self.arguments = { ... }\
\9self.isRunning = true\
\
\9self:update()\
\
\9while self.isRunning do\
\9\9local event = Event.static:create( coroutine.yield() )\
\9\9event.relativeView = self.container\
\9\9self.event:handleEvent( event )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Changes the interface name, reloading the interface\
\9@param [string] interfaceName -- the name of the interface (the file name without extension)\
]]\
function Application.interfaceName:set( interfaceName )\
\9if interfaceName and self.interfaceName ~= interfaceName then\
\9\9self.interfaceName = interfaceName\
\9\9self:reloadInterface()\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Loads the application container or changes it if there is one.\
]]\
function Application:reloadInterface()\
\9local interfaceName = self.interfaceName\
\
\9local oldContainer = self.container\
\9if oldContainer then\
\9\9oldContainer:dispose()\
\9end\
\
\9if interfaceName then\9\9\
\9\9self.container = Interface( interfaceName ).container\
\9else\
\9\9self.container = ApplicationContainer()\
\9end\
\9self.event:handleEvent( ReadyInterfaceEvent( true ) )\
end\
\
function Application.container:set( container )\
\9self.container = container\
end\
\
--[[\
\9@instance\
\9@desc Update all application's views\
]]\
function Application:update()\
\9-- TODO: not exactally sure how to handle deltaTime for the first one. for now it's one 60th\
\9local lastUpdate = self.lastUpdate or 1/60\
\9local deltaTime = os.clock() - lastUpdate\
\9self.updateTimer = os.startTimer( 1/20 )\
\9self.lastUpdate = os.clock()\
\
\9self:checkScheduled( lastUpdate )\
\9local container = self.container\
\9container:update( deltaTime )\
\9container:draw()\
end\
\
--[[\
\9@instance\
\9@desc Returns a table of the views in focus that are of the given type\
\9@param [class] type -- the type\
\9@param [table{View}] searchFocuses -- the focuses to look through, i.e. from the focuses changed event (defaults to the current ones)\
\9@return [table{View}] focuses -- the focuses\
]]\
function Application:focusesOfType( _type, searchFocuses )\
\9local focuses = {}\
\9for view, _ in pairs( searchFocuses or self.focuses ) do\
\9\9if view:typeOf( _type ) then\
\9\9\9table.insert( focuses, view )\
\9\9end\
\9end\
\9return focuses\
end\
\
--[[\
\9@instance\
\9@desc Returns true if there is at least one focused view\
\9@return [boolean] hasFocus\
]]\
function Application:hasFocus()\
\9return next( self.focuses ) ~= nil\
end\
\
--[[\
\9@instance\
\9@desc Unfocuses everything else and makes the given view the only focused view\
\9@param [View] newFocus -- the view that is to be focused upon\
\9@param [class] filter -- the filter class. any other views that are focused that extend this class will be unfocused, all others will be untouched\
]]\
function Application:focus( newFocus, filter )\
\9local focuses = self.focuses\
\9local oldFocuses = {}\
\9local hadOtherFocus = false\
\9for oldFocus, _ in pairs( focuses ) do\
\9\9if oldFocus ~= newFocus then\
\9\9\9oldFocuses[oldFocus] = true\
\9\9\9if (not filter or oldFocus:typeOf( filter )) then\
\9\9\9\9hadOtherFocus = true\
\9\9\9\9focuses[oldFocus] = nil\
\9\9\9\9oldFocus.isFocused = false\
\9\9\9end\
\9\9end\
\9end\
\9if hadOtherFocus or not focuses[newFocus] then\
\9\9if not focuses[newFocus] then\
\9\9\9focuses[newFocus] = true\
\9\9\9newFocus.isFocused = true\
\9\9end\
\9\9self.event:handleEvent( FocusesChangedInterfaceEvent( focuses, oldFocuses ) )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Adds the given view to the list of focused views, unfocusing single focus only views\
\9@param [view] newFocus -- the view that is to be focused upon\
]]\
function Application:addFocus( newFocus )\
\9local focuses = self.focuses\
\9local oldFocuses = {}\
\9if not focuses[newFocus] then\
\9\9for focusedView, _ in pairs( focuses ) do\
\9\9\9oldFocuses[focusedView] = true\
\9\9\9if focusedView.isSingleFocusOnly then\
\9\9\9\9focuses[focusedView] = nil\
\9\9\9end\
\9\9end\
\9\9focuses[newFocus] = true\
\9\9newFocus.isFocused = true\
\9\9self.event:handleEvent( FocusesChangedInterfaceEvent( focuses, oldFocuses ) )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Removes the given view from the list of focused views\
\9@param [view] oldFocus -- the view that is to be focused upon\
]]\
function Application:unfocus( oldFocus )\
\9local focuses = self.focuses\
\9if focuses[oldFocus] then\
\9\9local oldFocuses = {}\
\9\9for k, _ in pairs( focuses ) do\
\9\9\9oldFocuses[k] = true\
\9\9end\
\9\9focuses[oldFocus] = nil\
\9\9oldFocus.isFocused = false\
\9\9self.event:handleEvent( FocusesChangedInterfaceEvent( focuses, oldFocuses ) )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Unfocuses the view that is currently focused (i.e. the selected text box)\
\9@param [class] filter -- the filter class. views that are focused that extend this class will be unfocused, all others will be untouched. if nil all are unfocused\
]]\
function Application:unfocusAll( filter )\
\9local focuses = self.focuses\
\9local oldFocuses = {}\
\9for oldFocus, _ in pairs( focuses ) do\
\9\9if not filter or oldFocus:typeOf( filter ) then\
\9\9\9oldFocuses[oldFocus] = true\
\9\9\9focuses[oldFocus] = nil\
\9\9\9oldFocus.isFocused = false\
\9\9end\
\9end\
\9self.event:handleEvent( FocusesChangedInterfaceEvent( focuses, oldFocuses ) )\
end\
\
--[[\
\9@instance\
\9@desc Schedules a function to be called at a specified time in the future\
\9@param [number] time -- in how many seconds the function should be run\
\9@param [function] func -- the function to call (self is always passed as first argument)\
\9@param [class] _class -- the class to call the function on ( optional )\
\9@param ... -- any values you want. will be passed as the parameters (other than self)\
\9@return [number] scheduleId -- the ID of the scheduled task\
]]\
function Application:schedule( func, time, ... )\
\9time = time or 0.05\
\9local schedules = self.schedules\
\9table.insert( schedules, { func, os.clock() + time, ... } )\
\9return #schedules\
end\
\
--[[\
\9@instance\
\9@desc Unschedule a scheduled task\
\9@param [number] scheduleId -- the ID of the scheduled task\
\9@return [boolean] didUnschedule -- whether the task was unscheduled. this is only false if the task no longer exists or never existed\
]]\
function Application:unschedule( scheduleId )\
\9local schedules = self.schedules\
\9if schedules[scheduleId] then\
\9\9schedules[scheduleId] = nil\
\9\9return true\
\9else return false end\
end\
\
--[[\
\9@instance\
\9@desc Run any scheduled tasks that need to be run\
\9@param [number] lastUpdate -- the time of the last update\
]]\
function Application:checkScheduled( lastUpdate )\
\9local now = os.clock()\
\9local schedules = self.schedules\
\9for scheduleId, task in pairs( schedules ) do\
\9\9if task[2] <= now then\
\9\9\9local func = task[1]\
\9\9\9table.remove( task, 2 )\
\9\9\9table.remove( task, 1 )\
\9\9\9func( unpack( task ) )\
\9\9\9schedules[scheduleId] = nil\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when a timer is fired\
\9@param [TimerEvent] event -- the timer event\
\9@return [boolean] stopPropagation -- whether following handlers should not recieve this event\
]]\
function Application:onTimer( Event event, Event.phases phase )\
\9if event.timer and event.timer == self.updateTimer then\
\9\9self:update()\
\9\9return true\
\9end\
end",
  },
  CloseWindowButton = {
    [ "text/lua" ] = "\
class \"CloseWindowButton\" extends \"WindowButton\" {}\
\
function CloseWindowButton:initialiseCanvas()\
\9self:super()\
\
\9local symbolObject = Path( 4, 3, 3, 3 )\
    symbolObject:lineTo( 3, 3 )\
    symbolObject:moveTo( 3, 1 )\
    symbolObject:lineTo( 1, 3 )\
    symbolObject:close( false )\
\
    self.theme:connect( symbolObject, \"outlineColour\", \"symbolColour\" )\
    self.symbolObject = self.canvas:insert( symbolObject )\
end\
\
function CloseWindowButton:onMouseUp( Event event, Event.phases phase )    \
    if self.window then\
        self.window:close()\
        return true\
    end\
end",
  },
  TextFormatter = {
    [ "text/lua" ] = "\
-- written in love2d so I'll port it over at some point\
\
class \"TextFormatter\" {\
\9width = 0;\
\9height = 0;\
\
\9text = \"\";\
\
\9-- this stuff is actually controlled by the Font class\
\9-- might be better to make it a table of fonts and the range of the string\
\9-- but up to you, i'm not really sure how it works\
\
\9-- these are defaults, since they can change\
\9colour = Graphics.colours.GREY;\
\9underline = false;\
\9strikethrough = false;\
\
\9font_name = \"default\";\
\9font_size = 5;\
\9font_mode = \"default\"; -- italic, bold, bolditalic\
\
\9xAlignment = \"left\"; -- alignment.LEFT ?\
\9yAlignment = \"top\"; -- alignment.TOP?\
\
\9changed = false;\
\9stream = false;\
\9wrappedStream = false;\
}\
\
function TextFormatter:initialise( text, width, height )\
\9self.text = text\
\9self.width = width\
\9self.height = height\
end\
\
 -- this is called when a variable is set right?:  Yes, arguments are key, value if you want them\
function TextFormatter:set()\
\9self.changed = true\
end\
\
function TextFormatter:tostream()\
\9if not self.changed and self.stream then\
\9\9return self.stream\
\9end\
\9-- convert text into a formatted stream of characters\
end\
\
function TextFormatter:wrapstream( display_width, display_height, stream )\
\9if not self.changed and self.wrappedStream then\
\9\9return self.wrappedStream\
\9end\
\9stream = stream or self:tostream()\
\9-- wordwrap the stream and sort out alignment\
end",
  },
  DragView = {
    [ "text/lua" ] = "\
local SHADOW_RATIO = 2/3\
local MAX_SHADOW_SIZE = 3\
\
class \"DragView\" extends \"View\" {\
\
    imageObject = false;\
    shadowObject = false;\
    shadowSize = 0;\
    image = false;\
    shadowImage = false;\
}\
\
function DragView:initialiseCanvas()\
    self:super()\
\
    local width, height, canvas = self.width, self.height, self.canvas\
\
    local shadowObject = canvas:insert( ImageObject( 1, 1, width - SHADOW_RATIO * MAX_SHADOW_SIZE, height - MAX_SHADOW_SIZE, self.shadowImage ) )\
    local imageObject = canvas:insert( ImageObject( 1, 1, width - SHADOW_RATIO * MAX_SHADOW_SIZE, height - MAX_SHADOW_SIZE, self.image ) )\
\
    self.shadowObject = shadowObject\
    self.imageObject = imageObject\
end\
\
function DragView.image:set( image )\
    self.image = image\
    self.imageObject.image = image\
end\
\
function DragView.shadowImage:set( shadowImage )\
    self.shadowImage = shadowImage\
    self.shadowObject.image = shadowImage\
end\
\
function DragView.shadowSize:set( shadowSize )\
    self.shadowSize = shadowSize\
    local shadowObject = self.shadowObject\
    shadowObject.x = 1 + math.floor( SHADOW_RATIO * shadowSize + 0.5 )\
    shadowObject.y = 1 + math.floor( shadowSize + 0.5 )\
end\
\
function DragView:updateWidth( width )\
    self.imageObject.width = width - SHADOW_RATIO * MAX_SHADOW_SIZE\
    self.shadowObject.width = width - SHADOW_RATIO * MAX_SHADOW_SIZE\
end\
\
function DragView:updateHeight( height )\
    self.imageObject.height = height - MAX_SHADOW_SIZE\
    self.shadowObject.height = height - MAX_SHADOW_SIZE\
end",
  },
  ChildRemovedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"ChildRemovedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_child_removed\";\
    };\
\9childView = false; -- the removed child\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a child removed event from the arguments\
\9@param [View] childView -- the removed child\
]]\
function ChildRemovedInterfaceEvent:initialise( childView )\
\9self.childView = childView\
end",
  },
  MenuItem = {
    [ "text/lua" ] = "\
local TEXT_MARGIN = 12\
\
class \"MenuItem\" extends \"View\" {\
\
\9height = 12;\
\9width = 40;\
\
    isPressed = false;\
    isEnabled = true;\
\9isCanvasHitTested = false;\
\
    keyboardShortcut = false;\
    text = false;\
\
    font = false;\
    backgroundObject = false;\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a menu item instance\
\9@param [table] properties -- the properties for the view\
]]\
function MenuItem:initialise( ... )\
\9self:super( ... )\
\
    self:event( MouseDownEvent, self.onMouseDown )\
    self:event( KeyboardShortcutEvent, self.onKeyboardShortcut )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
end\
\
function MenuItem:initialiseCanvas()\
    self:super()\
    local width, height, canvas = self.width, self.height, self.canvas\
    local backgroundObject = canvas:insert( Rectangle( 1, 1, width, height, self.fillColour ) )\
    local textObject = canvas:insert( Text( 7, 3, height, width - TEXT_MARGIN, self.text ) )\
    local keyboardShortcut = self.keyboardShortcut\
    local shortcutObject = canvas:insert( Text( 1, 3, height, width - TEXT_MARGIN, keyboardShortcut and keyboardShortcut:symbols() or \"\" ) )\
    shortcutObject.alignment = Font.alignments.RIGHT\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( textObject, \"textColour\" )\
    self.theme:connect( shortcutObject, \"textColour\", \"shortcutColour\" )\
\
    self.backgroundObject = backgroundObject\
    self.textObject = textObject\
    self.shortcutObject = shortcutObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
-- function MenuItem.shortcut:set( shortcut )\
--     if shortcut and #shortcut > 0 then\
--         self.keyboardShortcut = KeyboardShortcut.fromString( shortcut ) or false\
--     else\
--         self.keyboardShortcut = false\
--     end\
-- end\
\
function MenuItem.font:set( font )\
    self.font = font\
    local textObject = self.textObject\
    local shortcutObject = self.shortcutObject\
    if textObject then\
        textObject.font = font\
        shortcutObject.font = font\
        self:updateText()\
    end\
end\
\
function MenuItem:updateText()\
    local text = self.text\
    local keyboardShortcut = self.keyboardShortcut\
    local symbols = keyboardShortcut and keyboardShortcut:symbols()\
    local textObject = self.textObject\
    local shortcutObject = self.shortcutObject\
\
    if textObject then\
        local textWidth = self.font:getWidth( text )\
        local shortcutWidth = symbols and self.font:getWidth( symbols ) or 0\
        local width = textWidth + TEXT_MARGIN + ( shortcutWidth ~= 0 and shortcutWidth + 8 or 0 )\
        self.width = width\
        textObject.text = text\
        shortcutObject.text = symbols\
        local parent = self.parent\
        if parent then\
            parent.needsLayoutUpdate = true\
        end\
    end\
end\
\
function MenuItem.text:set( text )\
    self.text = text\
    self:updateText()\
end\
\
function MenuItem.keyboardShortcut:set( keyboardShortcut )\
    if type( keyboardShortcut ) == \"string\" and #keyboardShortcut > 0 then\
        self.keyboardShortcut = KeyboardShortcut.fromString( keyboardShortcut ) or false\
    elseif not keyboardShortcut then\
        self.keyboardShortcut = false\
    end\
    self.keyboardShortcut = keyboardShortcut\
    self:updateText()\
end\
\
function MenuItem:updateWidth( width )\
    self.backgroundObject.width = width\
    self.textObject.width = width - TEXT_MARGIN\
    local shortcutObject = self.shortcutObject\
    shortcutObject.width = width - 5\
end\
\
function MenuItem:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function MenuItem:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function MenuItem.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function MenuItem.isPressed:set( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuItem:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled and self:hitTestEvent( event ) then\
            if self.event:handleEvent( ActionInterfaceEvent( self ) ) then return true end\
            self.parent:close()\
            local result = self.event:handleEvent( event )\
            return ( result ~= nil and result or true )\
        end\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuItem:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the a keyboard shortcut is fired\
    @param [Event] event -- the keyboard shortcut\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuItem:onKeyboardShortcut( Event event, Event.phases phase )\
    if self.isEnabled then\
        local keyboardShortcut = self.keyboardShortcut\
        if keyboardShortcut and keyboardShortcut:matchesEvent( event ) then\
            local parent = self.parent\
            local owner = parent.owner\
            if owner:typeOf( MenuBarItem ) then owner:flash() end\
            if self.event:handleEvent( ActionInterfaceEvent( self ) ) then return true end\
            parent:close()\
            return true\
        end\
    end\
end",
  },
  HomeSymbol = {
    [ "text/lua" ] = "\
class \"HomeSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"home\";\
\
    width = 9;\
    height = 9;\
\
    serialisedPaths = {\
        {\
          x = 1,\
          y = 1,\
          lines = {\
            {\
              y1 = 1,\
              x1 = 5,\
              x2 = 9,\
              mode = \"linear\",\
              y2 = 5,\
            },\
            {\
              y1 = 5,\
              x1 = 9,\
              x2 = 1,\
              mode = \"linear\",\
              y2 = 5,\
            },\
            {\
              y1 = 5,\
              x1 = 1,\
              x2 = 5,\
              mode = \"linear\",\
              y2 = 1,\
            },\
          },\
          height = 9,\
          width = 9,\
        },\
        {\
          x = 1,\
          y = 1,\
          lines = {\
            {\
              y1 = 5,\
              x1 = 8,\
              x2 = 8,\
              mode = \"linear\",\
              y2 = 9,\
            },\
            {\
              y1 = 9,\
              x1 = 8,\
              x2 = 6,\
              mode = \"linear\",\
              y2 = 9,\
            },\
            {\
              y1 = 9,\
              x1 = 6,\
              x2 = 6,\
              mode = \"linear\",\
              y2 = 7,\
            },\
            {\
              y1 = 7,\
              x1 = 6,\
              x2 = 4,\
              mode = \"linear\",\
              y2 = 7,\
            },\
            {\
              y1 = 7,\
              x1 = 4,\
              x2 = 4,\
              mode = \"linear\",\
              y2 = 9,\
            },\
            {\
              y1 = 9,\
              x1 = 4,\
              x2 = 2,\
              mode = \"linear\",\
              y2 = 9,\
            },\
            {\
              y1 = 9,\
              x1 = 2,\
              x2 = 2,\
              mode = \"linear\",\
              y2 = 5,\
            },\
            {\
              y1 = 5,\
              x1 = 2,\
              x2 = 8,\
              mode = \"linear\",\
              y2 = 5,\
            },\
          },\
          height = 9,\
          width = 9,\
        }\
    }\
\
\
}",
  },
  SearchBox = {
    [ "text/lua" ] = "\
class \"SearchBox\" extends \"TextBox\" {\
    \
    symbolObject = false;\
    placeholder = \"Search...\";\
\
}\
\
function SearchBox:initialiseCanvas()\
    self:super()\
\
    local symbolObject = SymbolObject( 8, 4, SearchSymbol )\
    self.canvas:insert( symbolObject )\
\
    self.theme:connect( symbolObject, \"outlineColour\", \"searchSymbolColour\" )\
    \
    self.symbolObject = symbolObject\
end",
  },
  ShadowObject = {
    [ "text/lua" ] = "\
class \"ShadowObject\" extends \"GraphicsObject\" {\
\
    views = {};\
\
}\
\
function ShadowObject:initialise( x, y, width, height, views )\
    self:super( x, y, width, height )\
    self.views = views or {}\
end\
\
function ShadowObject.views:set( views )\
    self.hasChanged = true\
    self.views = views\
end\
\
function ShadowObject.fill:get()\
    if self.fill then return self.fill end\
    log('update fill')\
    local fill = {}\
    local width = self.width\
    local height = self.height\
    for i, object in ipairs( self.views ) do\
        local objectFill = object.fill\
        local objectX, objectY = object.x, object.y\
        for x, row in pairs( objectFill ) do\
            local fillX = fill[x + objectX - 1]\
            if not fillX then\
                fillX = {}\
                fill[x + objectX - 1] = fillX\
            end\
\
            for y, isFilled in pairs( row ) do\
                fillX[y + objectY - 1] = isFilled\
            end\
        end\
    end\
\
    self.fill = fill\
    return fill\
end",
  },
  Bundle = {
    [ "text/lua" ] = "\
class \"Bundle\" extends \"Folder\" {}",
  },
  Separator = {
    [ "text/lua" ] = "\
class \"Separator\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.LIGHT_GREY;\
\9isDashed = true\
}\
\
function Separator:initialise( x, y, width, height, isDashed )\
\9self:super( x, y, width, height )\
\9\
\9if isDashed ~= nil then\
\9\9self.isDashed = isDashed\
\9end\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Separator.fill:get()\
\9local fill = self.fill\
\9if fill then return fill end\
\9local isDashed, height = self.isDashed, self.height\
\9fill = {}\
\9for x = 1, self.width do\
\9\9local fillX = {}\
\9\9if not isDashed or x % 2 == 1 then\
\9\9\9for y = 1, height do\
\9\9\9\9if not isDashed or y % 2 == 1 then\
\9\9\9\9\9fillX[y] = true\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9fill[x] = fillX\
\9end\
\
\9self.fill = fill\
\9return fill\
end",
  },
  Line = {
    [ "text/lua" ] = "\
class \"Line\" extends \"GraphicsObject\" {\
\9\
\9isFromTopLeft = true; -- if true the line looks like: \\ (from top left to bottom right), if false it is: /\
\
}\
\
--[[\
\9@static\
\9@desc Creates an object with a line going from corner to corner \
\9@param [number] x -- the x coordinate of the line\
\9@param [number] y -- the y coordinate of the line\
\9@param [number] width -- the width of the line\
\9@param [number] height -- the height of the line\
\9@param [number] isFromTopLeft -- whether the line is from the top left to bottom right\
]]\
function Line:initialise( x, y, width, height, isFromTopLeft )\
\9self:super( x, y, width, height )\
\9self.isFromTopLeft = isFromTopLeft ~= nil and isFromTopLeft or true\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Line.fill:get()\
\9-- TODO: why was this commented out?\
\9if self.fill then return self.fill end\
\
\9local fill = {{true}}\
\9local isFromTopLeft = self.isFromTopLeft\
\9local startX = 1\
\9local startY = isFromTopLeft and 1 or self.height\
\9local endX = self.width\
\9local endY = isFromTopLeft and self.height or 1\
\
    if startX == endX and startY == endY then\
        fill[startX] = { [startY] = true }\
        return\
    end\
\
    for x = 1, self.width do\
    \9fill[x] = {}\
    end\
    \
    local minX = math.min( startX, endX )\
    if minX == startX then\
        minY = startY\
        maxX = endX\
        maxY = endY\
    else\
        minY = endY\
        maxX = startX\
        maxY = startY\
    end\
\
    local xDiff = maxX - minX\
    local yDiff = maxY - minY\
            \
    if xDiff > math.abs(yDiff) then\
        local y = minY\
        local dy = yDiff / xDiff\
        for x=minX,maxX do\
            fill[x][math.floor( y + 0.5 )] = true\
            y = y + dy\
        end\
    else\
        local x = minX\
        local dx = xDiff / yDiff\
        if maxY >= minY then\
            for y=minY,maxY do\
                fill[math.max(math.min(math.floor( x + 0.5 ), endX), startX)][y] = true\
                x = x + dx\
            end\
        else\
            for y=minY,maxY,-1 do\
                fill[math.max(math.min(math.floor( x + 0.5 ), endX), startX)][y] = true\
                x = x - dx\
            end\
        end\
    end\
\
\
\9return fill\
end",
  },
  MathParser = {
    [ "text/lua" ] = "\
local symbols = {\
\9[\"+\"] = true;\
\9[\"-\"] = true;\
\9[\"*\"] = true;\
\9[\"/\"] = true;\
\9[\"(\"] = true;\
\9[\")\"] = true;\
\9[\",\"] = true;\
\9[\"^\"] = true;\
\9[\"%\"] = true;\
}\
\
local operatorLevels = {\
\9[\"+\"] = 1;\
\9[\"-\"] = 1;\
\9[\"*\"] = 2;\
\9[\"/\"] = 2;\
\9[\"%\"] = 2;\
\9[\"^\"] = 3;\
}\
\
local functionParameterCounts = {\
\9min = 2;\
\9max = 2;\
\9sqrt = 1;\
\9sin = 1;\
\9cos = 1;\
\9tan = 1;\
\9abs = 1;\
\9random = 2;\
\9pow = 2;\
\9exp = 1;\
\9floor = 1;\
\9ceil = 1;\
\9log = 1;\
\9ran = 0;\
\9degrees = 1;\
\9radians = 1;\
}\
\
local functions = {\
\9min = math.min;\
\9max = math.max;\
\9sqrt = math.sqrt;\
\9sin = math.sin;\
\9cos = math.cos;\
\9tan = math.tan;\
\9abs = math.abs;\
\9random = math.random;\
\9pow = math.pow;\
\9exp = math.exp;\
\9floor = math.floor;\
\9ceil = math.ceil;\
\9log = math.log;\
\9ran = math.random;\
\9degrees = function( n )\
\9\9return n * 180 / math.pi\
\9end;\
\9radians = function( n )\
\9\9return n / 180 * math.pi\
\9end;\
}\
\
local allowedIndices = { left = true, right = true, top = true, bottom = true, width = true, height = true }\
\
local parse, eval = nil, {}\
\
local function getpos( token )\
\9return token and \"[\" .. token.pos .. \"]: \"\
end\
\
local function getClosingBracket( tokens, pos )\
\9local level = 1\
\9while pos <= #tokens do\
\9\9if tokens[pos].type == \"symbol\" and tokens[pos].value == \"(\" then\
\9\9\9level = level + 1\
\9\9elseif tokens[pos].type == \"symbol\" and tokens[pos].value == \")\" then\
\9\9\9level = level - 1\
\9\9\9if level == 0 then\
\9\9\9\9return pos\
\9\9\9end\
\9\9end\
\9\9pos = pos + 1\
\9end\
end\
\
local function getBracketContents( tokens, start )\
\9local close = getClosingBracket( tokens, start )\
\9if close then\
\9\9local t = {}\
\9\9for i = 1, close - start do\
\9\9\9t[#t + 1] = tokens[start]\
\9\9\9table.remove( tokens, start )\
\9\9end\
\9\9table.remove( tokens, start )\
\9\9return t\
\9end\
end\
\
local function lex( str )\
\9local tokens = {}\
\9local pos = 1\
\9local lpos = 1\
\9local function push( t, v )\
\9\9tokens[#tokens + 1] = {\
\9\9\9type = t;\
\9\9\9value = v;\
\9\9\9pos = lpos;\
\9\9}\
\9end\
\9while pos <= #str do\
\9\9local c = str:sub( pos, pos )\
\9\9if str:find( \"^%d*%.?%d+\", pos ) then\
\9\9\9local num = str:match( \"^%d*%.?%d+\", pos )\
\9\9\9pos = pos + #num\
\9\9\9local exp = str:match( \"^e%-?%d+\", pos )\
\9\9\9if exp then\
\9\9\9\9pos = pos + #exp\
\9\9\9end\
\9\9\9local percentage = false\
\9\9\9if str:sub( pos, pos ) == \"%\" then\
\9\9\9\9percentage = true\
\9\9\9\9pos = pos + 1\
\9\9\9end\
\9\9\9local n = tonumber( num )\
\9\9\9if exp then\
\9\9\9\9n = n * 10 ^ tonumber( exp )\
\9\9\9end\
\9\9\9if percentage then\
\9\9\9\9push( \"percentage\", n / 100 )\
\9\9\9else\
\9\9\9\9push( \"constant\", n )\
\9\9\9end\
\9\9elseif c:find \"%s\" then\
\9\9\9pos = pos + #str:match( \"^%s+\", pos  )\
\9\9elseif c == \".\" then\
\9\9\9push \"dot\"\
\9\9\9pos = pos + 1\
\9\9elseif c:find \"[a-zA-Z_]\" then\
\9\9\9local word = str:match( \"^[_%w]+\", pos )\
\9\9\9push( \"word\", word )\
\9\9\9pos = pos + #word\
\9\9elseif symbols[c] then\
\9\9\9push( \"symbol\", c )\
\9\9\9pos = pos + 1\
\9\9else\
\9\9\9error( \"shit\", 0 ) -- more descriptive error? :P\
\9\9end\
\9\9lpos = pos\
\9end\
\9return tokens\
end\
\
local function parseRelativeIndexes( tokens )\
\9local i = 1\
\9while i <= #tokens do\
\9\9if tokens[i].type == \"dot\" then\
\9\9\9if not tokens[i-1] or tokens[i-1].type ~= \"word\" then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected super before '.', got \" .. ( tokens[i-1] and tokens[i-1].type or \"nothing\" ), 0 )\
\9\9\9end\
\9\9\9if not tokens[i+1] or tokens[i+1].type ~= \"word\" then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected super after '.' (trying to index \" .. tokens[i-1].value .. \"), got \" .. ( tokens[i-1] and tokens[i-1].type or \"nothing\" ), 0 )\
\9\9\9end\
\9\9\9tokens[i-1].type = \"relative\"\
\9\9\9local index = string.lower( tokens[i+1].value )\
\9\9\9if not allowedIndices[index] then\
\9\9\9\9error( \"Illegal relative index: \" .. index .. \". Possible indices are: left, right, top, bottom, width or height.\", 0 )\
\9\9\9end\
\9\9\9tokens[i-1].value = {\
\9\9\9\9parent = tokens[i-1].value;\
\9\9\9\9index = index;\
\9\9\9}\
\9\9\9table.remove( tokens, i )\
\9\9\9table.remove( tokens, i )\
\9\9end\
\9\9i = i + 1\
\9end\
end\
\
local function parseFunctionCalls( tokens )\
\9local i = 1\
\9while i <= #tokens do\
\9\9if tokens[i].type == \"word\" and tokens[i + 1] and tokens[i + 1].type == \"symbol\" and tokens[i + 1].value == \"(\" then\
\9\9\9local content = getBracketContents( tokens, i + 2 )\
\9\9\9if content then\
\9\9\9\9table.remove( tokens, i + 1 )\
\
\9\9\9\9local parameters = {}\
\9\9\9\9if content[1] then\
\9\9\9\9\9parameters[1] = {}\
\9\9\9\9end\
\
\9\9\9\9for p = 1, #content do\
\9\9\9\9\9if content[p].type == \"symbol\" and content[p].value == \",\" then\
\9\9\9\9\9\9parameters[#parameters + 1] = {}\
\9\9\9\9\9else\
\9\9\9\9\9\9parameters[#parameters][#parameters[#parameters] + 1] = content[p]\
\9\9\9\9\9end\
\9\9\9\9end\
\
\9\9\9\9for i = 1, #parameters do\
\9\9\9\9\9if #parameters[i] == 0 then\
\9\9\9\9\9\9error( getpos( tokens[i] ) .. \"function parameter is empty\", 0 )\
\9\9\9\9\9end\
\9\9\9\9\9parse( parameters[i] )\
\9\9\9\9end\
\
\9\9\9\9tokens[i].type = \"call\"\
\9\9\9\9tokens[i].value = {\
\9\9\9\9\9func = tokens[i].value;\
\9\9\9\9\9parameters = parameters;\
\9\9\9\9}\
\9\9\9else\
\9\9\9\9error( getpos( tokens[i + 1] ) .. \"expected ')' to close '('\", 0 )\
\9\9\9end\
\9\9end\
\9\9i = i + 1\
\9end\
end\
\
local function parseBrackets( tokens )\
\9local i = 1\
\9while i <= #tokens do\
\9\9if tokens[i].type == \"symbol\" and tokens[i].value == \"(\" then\
\9\9\9local contents = getBracketContents( tokens, i + 1 )\
\9\9\9if contents then\
\9\9\9\9tokens[i] = {\
\9\9\9\9\9type = \"bracket\";\
\9\9\9\9\9value = parse( contents );\
\9\9\9\9\9pos = tokens[i].pos;\
\9\9\9\9}\
\9\9\9else\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected ')' to close '('\", 0 )\
\9\9\9end\
\9\9elseif tokens[i].type == \"symbol\" and tokens[i].value == \")\" then\
\9\9\9error( getpos( tokens[i] ) .. \"unexpected ')' with no opening '('\", 0 )\
\9\9else\
\9\9\9i = i + 1\
\9\9end\
\9end\
end\
\
local function parseUnaryMinuses( tokens )\
\9for i = #tokens, 1, -1 do\
\9\9if tokens[i].type == \"symbol\" and tokens[i].value == \"-\" and ( not tokens[i-1] or tokens[i-1].type == \"symbol\" ) then\
\9\9\9local n = tokens[i+1]\
\9\9\9if not n or n.type == \"symbol\" then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected constant (number) or percentage after '-'\", 0 )\
\9\9\9end\
\9\9\9tokens[i].type = \"constant\"\
\9\9\9tokens[i].value = -1\
\9\9\9table.insert( tokens, i + 1, {\
\9\9\9\9type = \"symbol\";\
\9\9\9\9value = \"*\";\
\9\9\9\9pos = tokens[i].pos;\
\9\9\9} )\
\9\9end\
\9end\
end\
\
local function parseMathConstants( tokens )\
\9for i = 1, #tokens do\
\9\9if tokens[i].type == \"word\" and tokens[i].value:lower() == \"pi\" then\
\9\9\9tokens[i].type = \"constant\"\
\9\9\9tokens[i].value = math.pi\
\9\9elseif tokens[i].type == \"word\" and tokens[i].value:lower() == \"phi\" then\
\9\9\9tokens[i].type = \"constant\"\
\9\9\9tokens[i].value = 1.61803398875 -- can support 2 extra numbers on the end, checked in lua prompt, need to get more precise version\
\9\9end\
\9end\
end\
\
function parse( tokens )\
\9if #tokens == 0 then\
\9\9error( \"no values in tokens\", 0 )\
\9end\
\9parseFunctionCalls( tokens )\
\9parseBrackets( tokens )\
\9parseUnaryMinuses( tokens )\
\9for i = 1, #tokens do\
\9\9if i % 2 == 1 and tokens[i].type == \"symbol\" then\
\9\9\9error( getpos( tokens[i] ) .. \"unexpected symbol, expected operand\", 0 )\
\9\9elseif i % 2 == 0 and tokens[i].type ~= \"symbol\" then\
\9\9\9error( getpos( tokens[i] ) .. \"expected symbol between operands\", 0 )\
\9\9end\
\9\9if tokens[i].type == \"symbol\" and tokens[i].value == \",\" then\
\9\9\9error( getpos( tokens[i] ) .. \"unexpected ','\", 0 )\
\9\9end\
\9end\
\9if #tokens % 2 == 0 then\
\9\9error( getpos( tokens[#tokens] ) .. \"expected operand\", 0 )\
\9end\
\9return tokens\
end\
\
local function checkFunctionCalls( tokens )\
\9for i = 1, #tokens do\
\9\9if tokens[i].type == \"call\" then\
\9\9\9local f = tokens[i].value.func\
\9\9\9local count = functionParameterCounts[f]\
\9\9\9if not count then\
\9\9\9\9error( getpos( tokens[i] ) .. \"no such function '\" .. f .. \"'\", 0 )\
\9\9\9end\
\9\9\9local p = tokens[i].value.parameters\
\9\9\9if #p ~= count then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected \" .. count .. \" parameters, got \" .. #p, 0 )\
\9\9\9end\
\9\9\9for i = 1, count do\
\9\9\9\9checkFunctionCalls( p[i] )\
\9\9\9end\
\9\9\9tokens[i].value.func = functions[f]\
\9\9elseif tokens[i].type == \"bracket\" then\
\9\9\9checkFunctionCalls( tokens[i].value )\
\9\9end\
\9end\
\9return tokens\
end\
\
local function isKnownValue( t )\
\9if type( t ) == \"number\" then return true end\
\9if t.type == \"bracket\" then\
\9\9for i = 1, #t.value do\
\9\9\9if type( t.value[i] ) ~= \"string\" and not isKnownValue( t.value[i] ) then\
\9\9\9\9return false\
\9\9\9end\
\9\9end\
\9\9return true\
\9elseif t.type == \"call\" then\
\9\9for p = 1, #t.value.parameters do\
\9\9\9for i = 1, #t.value.parameters[p] do\
\9\9\9\9if type( t.value.parameters[p][i] ) ~= \"string\" and not isKnownValue( t.value.parameters[p][i] ) then\
\9\9\9\9\9return false\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9return true\
\9end\
\9return t.type == \"constant\"\
end\
\
local function groupByLevel( terms, operators, level )\
\9local i = 1\
\9while i <= #operators do\
\9\9local t = { terms[i] }\
\9\9while operatorLevels[operators[i]] == level do\
\9\9\9t[#t + 1] = operators[i]\
\9\9\9table.remove( operators, i )\
\9\9\9t[#t + 1] = terms[i + 1]\
\9\9\9table.remove( terms, i + 1 )\
\9\9end\
\9\9if #t > 1 then\
\9\9\9terms[i] = {\
\9\9\9\9type = \"bracket\";\
\9\9\9\9pos = terms[i].pos;\
\9\9\9\9value = t;\
\9\9\9}\
\9\9end\
\9\9i = i + 1\
\9end\
end\
\
local function group( tokens )\
\9local levels = {}\
\9for i = 1, #tokens do\
\9\9tokens[i].pos = nil\
\9\9if tokens[i].type == \"symbol\" then\
\9\9\9levels[operatorLevels[tokens[i].value]] = true\
\9\9elseif tokens[i].type == \"bracket\" then\
\9\9\9tokens[i].value = group( tokens[i].value )\
\9\9elseif tokens[i].type == \"call\" then\
\9\9\9local p = tokens[i].value.parameters\
\9\9\9for i = 1, #p do\
\9\9\9\9p[i] = group( p[i] )\
\9\9\9end\
\9\9end\
\9end\
\9local terms = {}\
\9local operators = {}\
\9for i = 1, #tokens do\
\9\9local t = i % 2 == 1 and terms or operators\
\9\9t[#t + 1] = i % 2 == 0 and tokens[i].value or tokens[i]\
\9end\
\
\9if next( levels, next( levels ) ) then\
\9\9groupByLevel( terms, operators, 3 )\
\9\9groupByLevel( terms, operators, 2 )\
\9end\
\
\9local tokens = { terms[1] }\
\9for i = 1, #operators do\
\9\9tokens[#tokens + 1] = operators[i]\
\9\9tokens[#tokens + 1] = terms[i + 1]\
\9end\
\
\9return tokens\
end\
\
--FIX:\
function eval.knownList( list )\
\9local n = eval.knownValue( list[1] )\
\9for i = 1, ( #list - 1 ) / 2 do\
\9\9local n2 = eval.knownValue( list[i * 2 + 1] )\
\9\9local op = list[i * 2]\
\9\9if op == \"+\" then\
\9\9\9n = n + n2\
\9\9elseif op == \"-\" then\
\9\9\9n = n - n2\
\9\9elseif op == \"*\" then\
\9\9\9n = n * n2\
\9\9elseif op == \"/\" then\
\9\9\9n = n / n2\
\9\9elseif op == \"%\" then\
\9\9\9n = n % n2\
\9\9elseif op == \"^\" then\
\9\9\9n = n ^ n2\
\9\9end\
\9end\
\9return n\
end\
\
-- FIX:\
function eval.knownValue( token )\
\9if type( token ) == \"number\" then\
\9\9return math.floor( token + .5 )\
\9elseif token.type == \"bracket\" then\
\9\9return math.floor( eval.knownList( token.value ) + .5 )\
\9elseif token.type == \"call\" then\
\9\9local p = token.value.parameters\
\9\9for i = 1, #p do\
\9\9\9p[i] = eval.knownList( p[i] )\
\9\9end\
\9\9return math.floor( token.value.func( unpack( p ) ) + .5 )\
\9elseif token.type == \"constant\" then\
\9\9return math.floor( token.value + .5 )\
\9else\
\9\9error( \"Unknown value for token type: \" .. tostring( token.type ), 0 )\
\9end\
end\
\
class \"MathParser\" {} -- I think it's best just to make it a class so it's loaded properly (when we make the loader). Happy to change it though.\
\
function MathParser.static:parseString( str )\
\9local tokens = lex( str )\
\9parseRelativeIndexes( tokens )\
\9parseMathConstants( tokens )\
\9return group( checkFunctionCalls( parse( tokens ) ) )\
end\
\
function MathParser.static:simplify( tokens )\
\9for i = 1, #tokens do\
\9\9if type( tokens[i] ) ~= \"string\" then\
\9\9\9if isKnownValue( tokens[i] ) then\
\9\9\9\9tokens[i] = eval.knownValue( tokens[i] )\
\9\9\9elseif tokens[i].type == \"bracket\" then\
\9\9\9\9tokens[i].value = MathParser.simplify( tokens[i].value )\
\9\9\9elseif tokens[i].type == \"call\" then\
\9\9\9\9local p = tokens[i].value.parameters\
\9\9\9\9for i = 1, #p do\
\9\9\9\9\9p[i] = MathParser.simplify( p[i] )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9for i = 1, #tokens do\
\9\9if type( tokens[i] ) == \"table\" and tokens[i].type == \"constant\" then\
\9\9\9tokens[i] = tokens[i].value\
\9\9end\
\9end\
\9for i = 1, #tokens do\
\9\9if i % 2 == 1 and not isKnownValue( tokens[i] ) then\
\9\9\9return tokens\
\9\9end\
\9end\
\9return { eval.knownList( tokens ) }\
end\
\
-- solve percentages\
-- plug in relative indexes\
function MathParser.static:resolve( tokens, object, property, references )\
\9references = references or {}\
\9local parent = object.parent\
\9local parentSize = parent and ( ( property == \"left\" or property == \"right\" or property == \"width\" ) and parent.width or parent.height ) or 0\
\9local t = {}\
\9for i = 1, #tokens do\
\9\9if type( tokens[i] ) == \"number\" or type( tokens[i] ) == \"string\" then -- these will be raw numbers\
\9\9\9t[#t + 1] = tokens[i]\
\9\9elseif tokens[i].type == \"constant\" then -- these will be raw numbers\
\9\9\9t[#t + 1] = tokens[i].value\
\9\9elseif tokens[i].type == \"percentage\" then -- these will be raw numbers\
\9\9\9t[#t + 1] = tokens[i].value * parentSize\
\9\9elseif tokens[i].type == \"bracket\" then -- this will be a bracket token\
\9\9\9t[#t + 1] = {\
\9\9\9\9type = \"bracket\";\
\9\9\9\9value = MathParser.resolve( tokens[i].value, object, property, references )\
\9\9\9}\
\9\9elseif tokens[i].type == \"call\" then -- this will be a call token\
\9\9\9local parameters = {}\
\9\9\9for i, v in ipairs( tokens[i].value.parameters ) do\
\9\9\9\9parameters[i] = MathParser.resolve( v, object, property, references )\
\9\9\9end\
\9\9\9t[#t + 1] = {\
\9\9\9\9type = \"call\";\
\9\9\9\9value = {\
\9\9\9\9\9func = tokens[i].value.func;\
\9\9\9\9\9parameters = parameters;\
\9\9\9\9}\
\9\9\9}\
\9\9elseif tokens[i].type == \"relative\" then -- this will be a bracket token\
\9\9\9local identifier, index = token.value.parent, token.value.index\
\9\9\9local value = { 0 }\
\
\9\9\9if identifier == \"parent\" then\
\9\9\9\9error( \"Constraint can not use 'parent' for a relative value. Use percentages for getting parent width or height (100%)\", 0 )\
\9\9\9elseif identifier == \"self\" and property == index then\
\9\9\9\9error( \"Cannot use recursive constraint index. (tried to use self.\" .. index .. \" within self.\" .. index .. \")\", 0 )\
\9\9\9else\
\9\9\9\9references[identifier] = true\
\9\9\9\9local view = identifier == \"self\" and object or parent:findChild( identifier, false )\
\9\9\9\9if view then\
\9\9\9\9\9value = view:parseConstraint( index ) or value\
\9\9\9\9else\
\9\9\9\9\9error( \"Could not find view '\" .. identifier .. \"'\", 0 )\
\9\9\9\9end\
\9\9\9end\
\9\9\9t[#t + 1] = {\
\9\9\9\9type = \"bracket\";\
\9\9\9\9value = value;\
\9\9\9}\
\9\9end\
\9end\
\9return t, references\
end\
\
function MathParser.static:eval( list )\
\9return eval.knownList( list )\
end",
  },
  Image = {
    [ "text/lua" ] = "\
local hexnums = { [10] = \"a\", [11] = \"b\", [12] = \"c\", [13] = \"d\", [14] = \"e\" , [15] = \"f\" }\
local function getHexOf(colour)\
    if colour == Graphics.colours.TRANSPARENT or not colour or not tonumber(colour) then\
        return \" \"\
    end\
    local value = math.log(colour)/math.log(2)\
    if value > 9 then\
            value = hexnums[value]\
    end\
    return value\
end\
\
local function getColourOf(hex)\
    if hex == ' ' then\
        return Graphics.colours.TRANSPARENT\
    end\
    local value = tonumber(hex, 16)\
    if not value then return nil end\
    value = math.pow(2,value)\
    return value\
end\
\
local function split(a,e)\
    local t,e=e or\":\",{}\
    local t=string.format(\"([^%s]+)\",t)\
    a:gsub(t,function(t)e[#e+1]=t end)\
    return e\
end\
\
local IMAGE_MIMES = { \"image/paint\" }\
\
class \"Image\" {\
    \
    width = false;\
    height = false;\
    pixels = false;\
    -- resource = false;\
    -- file = false;\
    contents = false;\
    scaledCache = {};\
\
}\
\
function Image.static:blank( width, height )\
    local image = Image()\
    image.width = width\
    image.height = height\
    local TRANSPARENT = Graphics.colours.TRANSPARENT\
    local pixels = {}\
    for x = 1, width do\
        local pixelsX = {}\
        for y = 1, height do\
            pixelsX[y] = TRANSPARENT\
        end\
        pixels[x] = pixelsX\
    end\
    image.pixels = pixels\
    return image\
end\
\
function Image.static:fromPath( path )\
    local file = File( path )\
    if file then\
        local image = Image()\
        image.contents = file.contents\
        image:loadPaintFormat()\
        return image\
    end\
end\
\
function Image.static:fromName( name )\
    log(\"name \"..name)\
    local resource = Resource( name, IMAGE_MIMES )\
    if resource then\
        return Image.fromResource( resource )\
    end\
end\
\
function Image.static:fromResource( resource )\
    local image = Image()\
    image.contents = resource.contents\
    image:loadPaintFormat()\
    return image\
end\
\
function Image.static:fromPixels( pixels, width, height )\
    local image = Image()\
    image.width = width\
    image.height = height\
    image:loadPixels( pixels )\
    return image\
end\
\
function Image:loadPixels( pixels )\
    local newPixels = {}\
\
    for x, column in ipairs( pixels ) do\
        local pixelsX = {}\
        for y, colour in ipairs( column ) do\
            pixelsX[y] = colour\
        end\
        newPixels[x] = pixelsX\
    end\
\
    self.pixels = newPixels\
end\
\
function Image:loadPaintFormat()\
    local lines = split( self.contents, \"\\n\" )\
    local pixels = {}\
\
    for y, line in ipairs( lines ) do\
        for x = 1, #line do\
            if not pixels[x] then\
                pixels[x] = {}\
            end\
            pixels[x][y] = getColourOf( line:sub( x, x ) )\
        end\
    end\
\
    self.width = #pixels\
    self.height = #lines\
    self.pixels = pixels\
end\
\
function Image:toPaintFormat()\
    local pixels = self.pixels\
    local paintFormat = \"\"\
    local width, height = self.width, self.height\
\
    for y = 1, height do\
        for x = 1, width do\
            paintFormat = paintFormat .. getHexOf( pixels[x][y] )\
        end\
        paintFormat = paintFormat .. \"\\n\"\
    end\
\
    return paintFormat\
end\
\
function Image.pixels:set( pixels )\
    self.pixels = pixels\
    self.scaledCache = {\
        [self.width .. \":\" .. self.height] = pixels;\
    }\
end\
\
--[[\
    @instance\
    @desc Returns the image's pixels scaled to the desired dimensions. These are cached so performance should not be a huge concern.\
    @param [number] scaledWidth\
    @param [number] scaledHeight\
    @return [table] pixels -- the scaled pixels\
]]\
function Image:getScaledPixels( scaledWidth, scaledHeight )\
    scaledWidth = math.floor( scaledWidth + 0.5 )\
    scaledHeight = math.floor( scaledHeight + 0.5 )\
\
    local scaledCache = self.scaledCache\
\
    if scaledCache[scaledWidth .. \":\" .. scaledHeight] then\
        return scaledCache[scaledWidth .. \":\" .. scaledHeight]\
    end\
\
    local width, height, pixels = self.width, self.height, self.pixels\
\
    local scaledPixels = {}\
    local widthRatio = width / scaledWidth\
    local heightRatio = height / scaledHeight\
    local ceil = math.ceil\
\
    for x = 1, scaledWidth do\
        local pixelsX = pixels[ ceil( x * widthRatio ) ]\
        if not pixelsX then break end\
        local scaledX = {}\
        for y = 1, scaledHeight do\
            scaledX[y] = pixelsX[ ceil( y * heightRatio ) ]\
        end\
        scaledPixels[x] = scaledX\
    end\
\
    scaledCache[scaledWidth .. \":\" .. scaledHeight] = scaledPixels\
\
    return scaledPixels\
end\
\
--[[\
    @instance\
    @desc Renders the given image on top of the self image at the given position\
    @param [Image] appendingImage -- description\
    @param [number] x\
    @param [number] y\
]]\
function Image:appendImage( appendingImage, x, y )\
    local appendingPixels = appendingImage.pixels\
    local pixels = self.pixels\
    for _x, column in ipairs( appendingPixels ) do\
        local pixelsX = pixels[x + _x - 1]\
        if not pixelsX then break end\
        for _y, colour in ipairs( column ) do\
            if pixelsX[y + _y - 1] then\
                pixelsX[y + _y - 1] = colour\
            end\
        end\
    end\
    self.pixels = pixels\
end",
  },
  TextChangedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"TextChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_text\";\
    };\
\9text = false; -- the new text value\
\9oldText = false; -- the previous text value\
}\
\
--[[\
\9@constructor\
\9@desc Creates a Text event from the arguments\
\9@param text -- the new text value\
\9@param oldText -- the old text value\
]]\
function TextChangedInterfaceEvent:initialise( text, oldText )\
\9self.text = text\
\9self.oldText = oldText\
end\
",
  },
  Interface = {
    [ "text/lua" ] = "\
-- local function callSetters( instance, _class )\
-- \9local definedFunctions, setters, raw = _class.definedFunctions, class.setters, instance.raw\
-- \9for k, _ in pairs( _class.definedProperties ) do\
-- \9\9local classValue = _class[k]\
-- \9\9local instanceValue = raw[k]\
-- \9\9if classValue and type( classValue ) ~= \"table\" and instanceValue == classValue and definedFunctions[setters[k]] then\
-- \9\9\9instance[k] = classValue\
-- \9\9end\
-- \9end\
-- end\
\
class \"Interface\" {\
\9name = false; -- the name of the interface (the file name without the extension)\
\9container = false; -- if you want to generate a container based on the interface (i.e. not use the properties and children for an already made interface) you can use the value\
\9containerProperties = false; -- the properties given to the root element\
\9children = false; -- the children of the interface\
\9containerClass = false; -- the class type of the interface\
\9childNodes = false; -- the nodes from the root elements XML\
}\
\
--[[\
\9@constructor\
\9@desc Creates and loads an interface with the given name\
\9@param [string] interfaceName -- the file name of the interface\
]]\
function Interface:initialise( interfaceName, extend )\
\9self.name = interfaceName\
\9extend = extend or ApplicationContainer\
\
\9-- TODO: dynamic path resolving for interfaces and other files\
\9local resource = Resource( interfaceName, Metadata.mimes.SINTERFACE, \"interfaces\" )\
\9local contents = resource.contents\
\9if contents then\
\9\9local nodes, err = XML.static:fromText( contents )\
\9\9if not err and #nodes ~= 1 then err = \"Interfaces must only have 1 root element.\" end\
\9\9if not nodes or err then\
\9\9\9error( \"Interface XML invaid: \" .. interfaceName .. \".sinterface. Error: \" .. tostring( err ), 0 )\
\9\9end\
\
\9\9local rootNode = nodes[1]\
\9\9local containerClass = class.get( rootNode.type )\
\9\9local err\
\
\9\9if not containerClass then\
\9\9\9err = \"Container class not found: \" .. rootNode.type\
\9\9elseif not containerClass:typeOf( extend ) then\
\9\9\9err = \"Container class does not extend '\" .. extend.className .. \"': \" .. rootNode.type\
\9\9else\
\9\9\9self.containerClass = containerClass\
\9\9\9self.containerProperties = rootNode.attributes\
\9\9\9self.childNodes = rootNode.body\
\9\9end\
\
\9\9if err then\
\9\9\9error( \"Interface XML invaid: \" .. interfaceName .. \".sinterface. Error: \" .. err, 0 )\
\9\9end\
\9else\
\9\9error( \"Interface file not found: \" .. interfaceName .. \".sinterface\", 0 )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns and generates if needed a container from the interface.\
\9@return [Container] container -- the container\
]]\
function Interface.container:get()\
\9local container = self.container\
\9if container then return container end\
\
\9local containerProperties = self.containerProperties\
\9local containerClass = self.containerClass\
\9container = containerClass.spawn( containerProperties )\
\9container.interfaceProperties = containerProperties\
\9if not container then\
\9\9error( \"Interface XML invaid: \" .. self.name .. \".sinterface. Error: Failed to initialise Container class: \" .. tostring( self.class ) .. \". Identifier: \" .. tostring( properties.identifier ), 0 )\
\9end\
\
\9self.container = container\
\9-- callSetters( container, containerClass )\
\
\9local children = self.children\
\9for i, childView in ipairs( children ) do\
\9\9container:insert( childView )\
\9\9-- callSetters( childView, childView.class )\
\9end\
\
\
\9container.event:handleEvent( LoadedInterfaceEvent( container ) )\
\9return container\
end\
\
--[[\
\9@instance\
\9@desc Creates a table of children from the interface file\
\9@return [table] children -- the table of child views\
]]\
function Interface.children:get()\
\9log(\"get chilfdren\")\
\9local children = self.children\
\9if children then return children end\
\9local function insertTo( childNode, parentContainer )\
\9\9local childClass = class.get( childNode.type )\
\9\9if not childClass then\
\9\9\9return nil, \"Class not found: \" .. childNode.type\
\9\9elseif not childClass:typeOf( View ) then\
\9\9\9return nil,\"Class does not extend 'View': \" .. childNode.type\
\9\9end\
\
\9\9local interfaceProperties = {}\
\9\9for k, v in pairs( childNode.attributes ) do\
\9\9\9interfaceProperties[k] = v\
\9\9end\
\9\9childNode.attributes.interfaceProperties = interfaceProperties\
\9\9local childView = childClass( childNode.attributes )--:new( false, childNode.attributes )\
\9log(\"got \"..tostring(childView))\
\
\9\9if not childView then\
\9\9\9return nil, \"Failed to initialise \" .. childNode.type .. \". Identifier: \" .. tostring( childNode.attributes.identifier )\
\9\9end\
\
\
\9\9if childNode.body and #childNode.body > 0 then\
\9\9\9if not childClass:typeOf( Container ) then\
\9\9\9\9return nil, \"Class does not extend 'Container' but has children: \" .. childNode.type\
\9\9\9else\
\9\9\9\9for i, _childNode in ipairs( childNode.body ) do\
\9\9\9\9\9local child, err = insertTo( _childNode, childView )\
\9\9\9\9\9if err then return nil, err end\
\9\9\9\9\9if child then childView:insert( child ) end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9return childView\
\9end\
\
\9local children = {}\
\9for i, childNode in ipairs( self.childNodes ) do\
\9\9log(\"node\")\
\9\9local childView, err = insertTo( childNode )\
\9\9if err then error( \"Interface XML invaid: \" .. self.name .. \".sinterface. Error: \" .. err, 0 ) end\
\9\9if childView then table.insert( children, childView ) end\
\9end\
\9self.children = children\
\9return children\
end",
  },
  SiblingRemovedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"SiblingRemovedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_sibling_removed\";\
    };\
\9view = false; -- the new sibling that was removed\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a siblings changed event from the arguments\
\9@param [View] view -- the removed sibling view\
]]\
function SiblingRemovedInterfaceEvent:initialise( view )\
\9self.view = view\
end",
  },
  ForwardSymbol = {
    [ "text/lua" ] = "\
class \"ForwardSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"forward\";\
\
    width = 4;\
\
    serialisedPaths = {\
        {\
            x = 1;\
            y = 1;\
            lines = {\
                {\
                    y1 = 1;\
                    x1 = 4;\
                    x2 = 1;\
                    mode = \"linear\";\
                    y2 = 4;\
                };\
                {\
                    y1 = 4;\
                    x1 = 1;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 7;\
                };\
                {\
                    y1 = 7;\
                    x1 = 4;\
                    x2 = 4;\
                    mode = \"linear\";\
                    y2 = 1;\
                };\
            };\
            height = 7;\
            width = 4;\
        }\
\
    }\
\
\
}",
  },
  MenuBar = {
    [ "text/lua" ] = "\
class \"MenuBar\" extends \"Container\" {\
\9needsLayoutUpdate = false;\9\
    separatorObject = false;\
}\
\
function MenuBar:initialiseCanvas()\
    self:super()\
    local separatorObject = self.canvas:insert( Rectangle( 1, self.height, self.width, 1 ) )\
    self.theme:connect( separatorObject, \"fillColour\", \"separatorColour\" )\
    self.theme:connect( self.canvas, \"fillColour\" )\
    self.separatorObject = separatorObject\
end\
\
function MenuBar:updateThemeStyle()\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
--[[\
\9@instance\
\9@desc Updates the location of the menu bar items\
]]\
function MenuBar:updateLayout()\
\9local x = 6\
\9local height = 1\
\9for i, childView in ipairs( self.children ) do\
\9\9childView.x = x\
\9\9x = x + childView.width\
\9\9height = math.max( height, childView.height )\
\9end\
\9self.height = height\
\9self.needsLayoutUpdate = false\
end\
\
function MenuBar:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function MenuBar:updateWidth( width )\
\9self.separatorObject.width = width\
end\
\
function MenuBar:updateHeight( Height )\
\9self.separatorObject.y = Height\
end\
\
function MenuBar.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function MenuBar.isVisible:set( isVisible )\
\9self:super( isVisible )\
\9if isVisible then\
\9\9self.needsLayoutUpdate = true\
\9end\
end\
\
function MenuBar:insert( ... )\
\9self:super( ... )\
\9self.needsLayoutUpdate = true\
end\
\
function MenuBar:removeChild( ... )\
\9self:super( ... )\
\9self.needsLayoutUpdate = true\
end",
  },
  Package = {
    [ "text/lua" ] = "\
local RESOURCE_PACKAGE_FOLDERS = { classes = true; fonts = true; interfaces = true; themes = true; resources = true; miscellaneous = true; }\
\
local RESOURCE_PACKAGE_TEMPLATE = [[\
\
local args = { ... }\
if #args == 1 and args[1] == \"contents\" then\
    return files\
end\
\
_G.__resourceTables = _G.__resourceTables or {}\
_G.__resourceTables[#_G.__resourceTables + 1] = files\
local loaded = {}\
local classes = files[\"classes\"]\
local loadClass\
\
\
local f, err = loadstring( classes[\"class\"][\"text/lua\"], \"class.lua\" )\
if err then error( err, 0 ) end\
local ok, err = pcall( f )\
if err then error( err, 0 ) end\
\
table.insert( class.tables, classes )\
\
for name, contents in pairs( classes ) do\
    if name ~= \"class\" then\
        class.get( name )\
    end\
end\
\
]]\
\
local g_tLuaKeywords = {\
    [ \"and\" ] = true,\
    [ \"break\" ] = true,\
    [ \"do\" ] = true,\
    [ \"else\" ] = true,\
    [ \"elseif\" ] = true,\
    [ \"end\" ] = true,\
    [ \"false\" ] = true,\
    [ \"for\" ] = true,\
    [ \"function\" ] = true,\
    [ \"if\" ] = true,\
    [ \"in\" ] = true,\
    [ \"local\" ] = true,\
    [ \"nil\" ] = true,\
    [ \"not\" ] = true,\
    [ \"or\" ] = true,\
    [ \"repeat\" ] = true,\
    [ \"return\" ] = true,\
    [ \"then\" ] = true,\
    [ \"true\" ] = true,\
    [ \"until\" ] = true,\
    [ \"while\" ] = true,\
}\
\
-- A modified textutils.serialise that is slightly smaller (no indents, etc.)\
local function serialise_( t, tTracking )\
    local sType = type(t)\
    if sType == \"table\" then\
        if tTracking[t] ~= nil then\
            error( \"Cannot serialize table with recursive entries\", 0 )\
        end\
        tTracking[t] = true\
\
        if next(t) == nil then\
            return \"{}\"\
        else\
            local sResult = \"{\"\
            local tSeen = {}\
            for k,v in ipairs(t) do\
                tSeen[k] = true\
                sResult = sResult .. serialise( v, tTracking ) .. \";\"\
            end\
            for k,v in pairs(t) do\
                if not tSeen[k] then\
                    local sEntry\
                    if type(k) == \"string\" and not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\
                        sEntry = k .. \"=\" .. serialise( v, tTracking ) .. \";\"\
                    else\
                        sEntry = \"[\" .. serialise( k, tTracking ) .. \"]=\" .. serialise( v, tTracking ) .. \";\"\
                    end\
                    sResult = sResult .. sEntry\
                end\
            end\
            sResult = sResult:sub( 1, #sResult - 1 ) .. \"}\"\
            return sResult\
        end\
    elseif sType == \"string\" then\
        return string.format( \"%q\", t )\
    elseif sType == \"number\" or sType == \"boolean\" or sType == \"nil\" then\
        return tostring(t)\
    else\
        error( \"Cannot serialize type \"..sType, 0 )\
    end\
end\
\
class \"Package\" extends \"File\" {}\
\
function Package.static:make( path, overwrite, Folder folder, isResourcePackage )\
    local contents = \"\"\
    if isResourcePackage then\
        local folders = {}\
        for i, item in ipairs( folder.items ) do\
            local itemName = item.fullName\
            logtraceback()\
            if RESOURCE_PACKAGE_FOLDERS[itemName] and item:typeOf( Folder ) then\
                folders[itemName] = item:serialise( true )\
            elseif itemName == \"loadfirst.scfg\" and item.metadata.mime == Metadata.mimes.SCFG then\
                folders[\"loadfirst\"] = { [Metadata.mimes.SCFG] = item.contents }\
            end\
        end\
        contents = \"local files = \" .. serialise_(folders, {}) .. RESOURCE_PACKAGE_TEMPLATE\
        -- contents = textutils.serialize(folders)\
    else\
        local allItems = folder:serialise( false )\
        contents = serialise_(allItems, {})\
        -- contents = textutils.serialize(allItems)\
    end\
    -- log(contents)\
    -- log( serialise( allItems, {} ) )\
    return self:super( path, overwrite, isResourcePackage and Metadata.mimes.RESOURCEPKG or Metadata.mimes.PACKAGE, contents )\
end\
",
  },
  ScreenCanvas = {
    [ "text/lua" ] = "\
class \"ScreenCanvas\" extends \"Canvas\" {\
\9fillColour = Graphics.colours.LIGHT_BLUE;\
\9drawn = {};\
}\
\
function ScreenCanvas.hasChanged:set( hasChanged )\
\9self.hasChanged = hasChanged\
end\
\
--[[\
\9@instance\
\9@desc Draws the canvas to the terminal/screen provided\
\9@param [term] terminal -- the terminal object to draw to\
\9@return self\
]]\
function ScreenCanvas:drawToTerminal( terminal )\
    if self.isVisible then\
\9\9if self.hasChanged then\
\9        local s = os.clock()\
\9\9\9self:draw()\
\9\9\9terminal = terminal or term\
\
\9\9\9local currentLength, currentX, currentY, currentColour\
\
\9\9\9local sBC, sCP, w = term.setBackgroundColour, term.setCursorPos, term.write\
\9\9\9local function draw()\
\9\9\9\9if currentLength == 0 then return end\
\9\9\9\9sBC( currentColour )\
\9\9\9\9sCP( currentX, currentY )\
\9\9\9\9w( (\" \"):rep( currentLength ) )\
\9\9\9end\
\
\9\9\9local buffer = self.buffer\
\9\9\9local colour = self.fillColour or 1\
\9\9\9local width = self.width\
\9\9\9local height = self.height\
\9\9\9local drawn = self.drawn\
\9\9\9-- the blacked out corners. if theres a faster way to do this then feel free to change it\
\9\9\9local corner = { \
\9\9\9\9[1]={ [1]=true, [2]=true, [3]=true, [4]=true, [height - 3]=true, [height - 2]=true, [height - 1]=true, [height]=true },\
\9\9\9\9[2]={ [1]=true, [2]=true, [height - 1]=true, [height]=true },\
\9\9\9\9[3]={ [1]=true, [height]=true },\
\9\9\9\9[4]={ [1]=true, [height]=true },\
\9\9\9\9[width - 3]={ [1]=true, [height]=true },\
\9\9\9\9[width - 2]={ [1]=true, [height]=true },\
\9\9\9\9[width - 1]={ [1]=true, [2]=true, [height - 1]=true, [height]=true },\
\9\9\9\9[width]={ [1]=true, [2]=true, [3]=true, [4]=true, [height - 3]=true, [height - 2]=true, [height - 1]=true, [height]=true },\
\9\9\9}\
\9\9\9local cornerColour = Graphics.colours.BLACK\
\9\9\9for x, v in pairs( corner ) do -- ipairs won't do the [height-3] indexes, for example\
\9\9\9\9for y, v in pairs( v ) do\
\9\9\9\9\9buffer[ ( y - 1 ) * width + x ] = cornerColour\
\9\9\9\9end\
\9\9\9end\
\9        local blit = term.blit\
\9        local hexes = { \
\9        \9[2^0] = \"0\",\
\9        \9[2^1] = \"1\",\
\9        \9[2^2] = \"2\",\
\9        \9[2^3] = \"3\",\
\9        \9[2^4] = \"4\",\
\9        \9[2^5] = \"5\",\
\9        \9[2^6] = \"6\",\
\9        \9[2^7] = \"7\",\
\9        \9[2^8] = \"8\",\
\9        \9[2^9] = \"9\",\
\9        \9[2^10] = \"a\",\
\9        \9[2^11] = \"b\",\
\9        \9[2^12] = \"c\",\
\9        \9[2^13] = \"d\",\
\9        \9[2^14] = \"e\",\
\9        \9[2^15] = \"f\"\
\9        }\
\
\9\9\9for y = 1, self.height do\
\9\9\9\9-- currentY = y\
\9\9\9\9-- currentLength = 0\
\9\9\9\9-- currentColour = nil\
\9\9\9\9-- for x = 1, width do\
\9\9\9\9-- \9local p = ( y - 1 ) * width + x\
\9\9\9\9-- \9local c = buffer[p] or colour\
\9\9\9\9-- \9if c ~= drawn[p] then\
\9\9\9\9-- \9\9drawn[p] = c\
\9\9\9\9-- \9\9if currentColour == c then\
\9\9\9\9-- \9\9\9currentLength = currentLength + 1\
\9\9\9\9-- \9\9else\
\9\9\9\9-- \9\9\9draw()\
\9\9\9\9-- \9\9\9currentLength = 1\
\9\9\9\9-- \9\9\9currentX = x\
\9\9\9\9-- \9\9\9currentColour = c\
\9\9\9\9-- \9\9end\
\9\9\9\9-- \9elseif currentLength ~= 0 then\
\9\9\9\9-- \9\9draw()\
\9\9\9\9-- \9\9currentLength = 0\
\9\9\9\9-- \9\9currentColour = nil\
\9\9\9\9-- \9else\
\9\9\9\9-- \9\9currentColour = nil\
\9\9\9\9-- \9end\
\9\9\9\9-- end\
\9\9\9\9-- draw()\
\9\9\9\9local changed = false\
\9\9\9\9local str = \"\"\
\9\9\9\9for x = 1, width do\
\9\9\9\9\9local p = ( y - 1 ) * width + x\
\9\9\9\9\9local c = buffer[p] or colour\
\9\9\9\9\9str = str .. hexes[c]\
\9\9\9\9\9if not changed and c ~= drawn[p] then\
\9\9\9\9\9\9changed = true\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9\9if changed then\
\9\9\9\9\9log(y)\
\9\9\9\9\9log(str)\
\9\9\9\9\9term.setCursorPos(1,y)\
\9\9\9\9\9term.setBackgroundColour(8)\
\9\9\9\9\9blit(\"e\"..str)\
\9\9\9\9\9sleep(0)\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9return self\
end",
  },
  FocusesChangedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"FocusesChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_focuses_changed\";\
    };\
\9newFocuses = false; -- the new views that are being focused on. doesn't lose it's focus when it recieves this event.\
    oldFocuses = false; -- the old views that previously were focused\
}\
\
--[[\
\9@constructor\
\9@desc Creates a focus event from the arguments\
    @param [table] newFocuses -- the new focuses\
\9@param [table] oldFocuses -- the old focuses\
]]\
function FocusesChangedInterfaceEvent:initialise( newFocuses, oldFocuses )\
\9self.newFocuses = newFocuses\
    self.oldFocuses = oldFocuses\
end\
\
--[[\
    @instance\
    @desc Returns true if the given is currently focused\
    @param [View] view\
    @return [boolean] isFocused\
]]\
function FocusesChangedInterfaceEvent:contains( view )\
    return self.newFocuses[view] ~= nil\
end\
\
--[[\
    @instance\
    @desc Returns true if the given was focused\
    @param [View] view\
    @return [boolean] isFocused\
]]\
function FocusesChangedInterfaceEvent:didContain( view )\
    return self.oldFocuses[view] ~= nil\
end",
  },
  AlertWindow = {
    [ "text/lua" ] = "\
class \"AlertWindow\" extends \"Window\" {\
\9interfaceName = \"alert\";\
\9okayButton = InterfaceOutlet( \"okayButton\" );\
}\
\
function AlertWindow:initialise( ... )\
\9self:super( ... )\
\
\9self:event( LoadedInterfaceEvent, self.onInterfaceLoaded )\
\9self:event( ReadyInterfaceEvent, self.onReady )\
\
\9self.width = 100\
\9self.height = 40\
end\
\
function AlertWindow:onReady( Event event, Event.phases phase )\
\9self:centre()\
\9self:focus()\
\9self.okayButton:focus()\
end",
  },
  KeyEvent = {
    [ "text/lua" ] = "\
class \"KeyEvent\" extends \"Event\" {\
\9keyCode = Number;\
\9keyString = String.allowsNil;\
\9isCharacter = Boolean;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a key event from the arguments\
\9@param [number] keyCode -- the key's numerical key code\
]]\
function KeyEvent:initialise( Number keyCode )\
\9self.keyCode = keyCode\
\9self.keyString = KeyboardShortcutManager.static:convert( keyCode )\
\9-- TODO: this needs testing\
\9self.isCharacter = (2 <= keyCode and keyCode <= 13) or (16 <= keyCode and keyCode <= 27) or (30 <= keyCode and keyCode <= 41) or (44 <= keyCode and keyCode <= 53)\
end",
  },
  Folder = {
    [ "text/lua" ] = "\
local function tidy( path )\
    if type(path)~=\"string\" then logtraceback() end\
    path = \"/\" .. path\
    return path\
        :gsub( \"/.-/%.%./\", \"/\" )\
        :gsub( \"^.-/%.%./\", \"\" )\
        :gsub( \"/%./\", \"/\" )\
        :gsub( \"^%.%./\", \"\" )\
        :gsub( \"^%.%.$\", \"\" )\
        :gsub( \"//+\", \"/\" )\
        -- :gsub( \"^[^/]\", \"/\" )\
        :gsub( \"/$\", \"\" )\
end\
\
class \"Folder\" extends \"FileSystemItem\" {\
    \
    allItems = false;\
    items = false;\
    files = false;\
    folders = false;\
    fs = false; -- an fs API sandbox \
    io = false; -- an fs API sandbox \
\
}\
\
function Folder.metatable:__call( path, ... )\
    if fs.exists( path ) and fs.isDir( path ) and not fs.isReadOnly( path ) then\
        local name = fs.getName( path )\
        if name ~= \".DS_Store\" and name ~= \".metadata\" then\
            return self.spawn( path, ... )\
        end\
    end\
    return false\
end\
\
function Folder.static:make( path, overwrite )\
    local exists = fs.exists( path )\
    if overwrite and exists then\
        fs.delete( path )\
        exists = false\
    end\
\
    if not exists then\
        fs.makeDir( path )\
        return Folder( path )\
    end\
end\
\
function Folder:serialise( flatten, metadataProperties )\
    local allItems = {}\
\
    local path = self.path\
    for i, name in ipairs( fs.list( path ) ) do\
        local item = FileSystemItem( path .. \"/\" .. name, self )\
        if item then\
            local itemName = item.name\
            local isFolder = item:typeOf( Folder )\
            if not isFolder or not flatten then\
                if flatten and allItems[flatten and itemName or name] then\
                    allItems[flatten and itemName or name][item.metadata.mime] = item.contents\
                else\
                    allItems[flatten and itemName or name] = flatten and {[item.metadata.mime] = item.contents} or { isFolder and {} or item.contents, item.metadata:serialise( metadataProperties ) }\
                end\
            end\
            if isFolder then\
                local subItems = item:serialise( flatten, metadataProperties )\
                if flatten and not item:typeOf( Bundle ) then\
                    for k, subItem in pairs( subItems ) do\
                        -- if flatten then\
                            allItems[k] = subItem--{ subItem., item.metadata:serialise() }\
                        -- else\
                            -- allItems[name][1][subItem.fullName] = { item, item.metadata:serialise() }\
                        -- end\
                    end\
                else\
                    allItems[name][1] = subItems\
                end\
            end\
        end\
    end\
\
    return allItems\
end\
\
function Folder:getItems( noFiles, noFolders )\
    local items = {}\
    local path = self.path\
    for i, name in ipairs( fs.list( path ) ) do\
        if name ~= \".DS_Store\" and name ~= \".metadata\" then\
            local item = FileSystemItem( path .. \"/\" .. name, self )\
            if not ( noFolders and noFolders ) or ( noFiles and not item:typeOf( IEditableFileSystemItem ) ) or ( noFolders and not item:typeOf( Folder ) ) then\
                table.insert( items, item )\
            end\
        end\
    end\
    return items\
end\
\
function Folder.items:get()\
    return self:getItems( false, false )\
end\
\
function Folder.files:get()\
    return self:getItem( false, true )\
end\
\
function Folder.folders:get()\
    return self:getItem( true, false )\
end\
\
function Folder.items:set( items )\
    error( \"Folder.items is a read-only property.\", 2 ) -- TODO: check if 2 is correct error level\
end\
\
function Folder.files:set( files )\
    error( \"Folder.files is a read-only property.\", 2 ) -- TODO: check if 2 is correct error level\
end\
\
function Folder.folders:set( folders )\
    error( \"Folder.folders is a read-only property.\", 2 ) -- TODO: check if 2 is correct error level\
end\
\
function Folder:itemFromPath( path )\
    return FileSystemItem( self.path .. tidy( path ) )\
end\
\
function Folder:fileFromPath( path )\
    return File( self.path .. tidy( path ) )\
end\
\
function Folder:folderFromPath( path )\
    return Folder( self.path .. tidy( path ) )\
end\
\
--[[\
    @instance\
    @desc Find an IEditableFileSystemItem that matches the name (without the extension) and the mime type.\
    @param [string] name -- the exact name of the file without extension to match\
    @param [Metatable.mimes/table{Metatable.mimes}] mimes -- a mime or table of mimes\
    @param [boolean] noSubfolders -- whether to not look in subfolders, by default subfolders will be searched\
    @return [IEditableFileSystemItem] returnedValue -- description\
]]\
function Folder:find( name, mimes, noSubfolders )\
    local items = self.items\
    local folders = {}\
    if type( mimes ) == \"string\" then mimes = { mimes } end\
    for i, fileSystemItem in ipairs( items ) do\
        if fileSystemItem:typeOf( IEditableFileSystemItem ) then\
            if --[[(]] name == fileSystemItem.name --[[ or name == fileSystemItem.fullName )]] then\
                local mime = fileSystemItem.metadata.mime\
                for i, _mime in ipairs( mimes ) do\
                    if _mime == mime then\
                        return fileSystemItem\
                    end\
                end\
            end\
        end\
        if not noSubfolders and fileSystemItem:typeOf( Folder ) then\
            -- look through folders last\
            table.insert( folders, fileSystemItem )\
        end\
    end\
\
    for i, folder in ipairs( folders ) do\
        local found = folder:find( name, mimes )\
        if found then\
            return found\
        end\
    end\
    return false\
end\
\
function Folder.fs:get()\
    local _fs = self.fs\
    if _fs then return _fs end\
    _fs = {\
        combine = fs.combine;\
        getDir = fs.getDir;\
        getName = fs.getName;\
        getDrive = fs.getDrive;\
    }\
\
    local relativePath = self.path\
    local function resolve( path )\
        return relativePath .. tidy( path )\
    end\
\
    local resolveFunctions = { \"list\"; \"exists\"; \"isDir\"; \"isReadOnly\"; \"getSize\"; \"getFreeSpace\"; \"makeDir\"; \"delete\"; \"open\"; \"find\"; } -- TODO: will find will work\
    for i, name in ipairs( resolveFunctions ) do\
        local func = fs[name]\
        _fs[name] = function ( path, ... )\
            log(\"func \"..name..\" : \"..tostring(path))\
            path = path and resolve( path ) or path\
            return func( path, ... )\
        end\
    end\
\
    local doubleResolveFunctions = { \"copy\"; \"move\"; }\
    for i, name in ipairs( doubleResolveFunctions ) do\
        local func = fs[name]\
        _fs[name] = function ( fromPath, toPath, ... )\
            return func( resolve( fromPath ), resolve( toPath ), ... )\
        end\
    end\
\
    -- function _fs.combine( partial, path, ... )\
    --     return fs.combine( partial, resolve( path), ... )\
    -- end\
\
    self.raw.fs = _fs\
    return _fs\
end\
\
function Folder.fs:set( fs )\
    error( \"Folder.fs is a read-only property.\", 2 ) -- TODO: check if 2 is correct error level\
end\
\
function Folder.io:get()\
    local _io = self.io\
    if _io then return _io end\
    _io = {\
        input = io.input;\
        output = io.output;\
        type = io.type;\
        close = io.close;\
        write = io.write;\
        flush = io.flush;\
        lines = io.lines;\
        read = io.read;\
    }\
\
    function _io.open( path, ... )\
        return io.open( resolve( path), ... )\
    end\
\
    self.raw.io = _io\
    return _io\
end\
\
function Folder.io:set( io )\
    error( \"Folder.io is a read-only property.\", 2 ) -- TODO: check if 2 is correct error level\
end\
\
function Folder:package( path, overwrite, isResourcePackage )\
    return Package.static:make( path, overwrite, self, isResourcePackage )\
end",
  },
  Document = {
    [ "text/lua" ] = "\
class \"Document\" {\
\
\9contents = false;\
\9file = false;\
\9isBinary = false;\
\9isModified = false;\
\
}\
\
--[[\
\9@constructor\
\9@desc Creates a document from the given path\
\9@param [string] path -- the path of the document\
]]\
function Document:initialise( path )\
\9self.path = path\
\9\9\
\9local file = FileSystemItem( path )\
\
\9if file then\
\9\9if file:typeOf( IEditableFileSystemItem ) then\
\9\9\9local isBinary = self.isBinary\
\9\9\9if isBinary and not file:typeOf( File ) then\
\9\9\9\9-- TODO: error, binary cannot be used on non-File FileSystemItems (i.e. Bundles)\
\9\9\9end\
\9\9\9-- TODO: error handling\
\9\9\9local rawContents = self.isBinary and file.binaryContents or file.contents\
\9\9\9if rawContents then\
\9\9\9\9local contents, err = self:parse( rawContents )\
\9\9\9\9if contents then\
\9\9\9\9\9self.contents = contents\
\9\9\9\9else\
\9\9\9\9\9-- TODO: Error, content empty or corrupt\
\9\9\9\9end\
\9\9\9else\
\9\9\9\9-- TODO: Error, content empty or corrupt\
\9\9\9end\
\9\9else\
\9\9\9-- TODO: Error, tried to open folder\
\9\9end\
\9else\
\9\9self:blank()\
\9end\
\
\9if err then\
\9\9self:onError( err )\
\9end\
end\
\
--[[\
\9@static\
\9@desc Opens a file and sets it as the application's active document, opening a file dialouge if neccesary. If there was an error the application's active document will not be changed. Simply use Document( path ) if you want to open a document but not set it as active.\
\9@param [Document] documentClass -- the type of Document class you want to use (it's probably easier to do MyDocument:open)\
\9@param [string] path -- the path of the document. if empty an open file dialouge will be shown\
]]\
function Document.static:open( documentClass, path )\
\9local function f( path )\
\9\9local document = documentClass( path )\
\9\9if document.contents then\
\9\9\9local oldDocument = Document.application.document\
\9\9\9if oldDocument then\
\9\9\9\9oldDocument:close( function( isClosed )\
\9\9\9\9\9if isClosed then Document.application.document = document end\
\9\9\9\9end )\
\9\9\9else\
\9\9\9\9Document.application.document = document\
\9\9\9end\
\9\9end\
\9end\
\
\9if path then\
\9\9f( path )\
\9else \
\9\9-- TODO: open file dialouge\
\9\9f( \"test.txt\" )\
\9end\
end\
\
--[[\
\9@static\
\9@desc Sets self.contents to whatever is required for a blank document. You will normally want to override this.\
]]\
function Document:blank()\
\9self.contents = \"\"\
end\
\
--[[\
\9@instance\
\9@desc Parses the read handle. If this returns nil :parse is used with the content of .readAll(). When subclassing you MUST override this or parse! (what's the point of subclassing otherwise?)\
\9@param [handle] handle -- the handle of the document\
\9@return contents -- the parsed contents. return false if handle is invalid.\
\9@return [string] err -- the error message if rawContents is invalid. this is REQUIRED if contents is returned as false, be helpful to your users.\
]]\
function Document:parseHandle( handle )\
end\
\
--[[\
\9@instance\
\9@desc Parses the raw string from the document. When subclassing you MUST override this or parseHandle! (what's the point of subclassing otherwise?)\
\9@param [string] rawContents -- the contents of the document\
\9@return contents -- the parsed contents. return false if rawContents is invalid.\
\9@return [string] err -- the error message if rawContents is invalid. this is REQUIRED if contents is returned as false, be helpful to your users.\
]]\
function Document:parse( rawContents )\
\9return rawContents\
end\
\
--[[\
\9@instance\
\9@desc Called when there was an error reading or writing the document. By default makes the application show an alert box. Override this if you want to change that.\
\9@param [string] err -- a description of the error encountered\
]]\
function Document:onError( err )\
\9-- TODO: alert window\
\9error( err )\
end\
\
function Document.contents:set( contents )\
\9self.contents = contents\
\9-- if self.hasInitialised then\
\9\9self.isModified = true\
\9-- end\
end\
\
\
--[[\
\9@instance\
\9@desc Saves the document's contents to it's path. Calls :write with self.path\
\9@return [string/nil] err -- the error message if there was an issue with saving, nil otherwise.\
]]\
function Document:save()\
\9if self.isBinary then\
\9\9self.file.binaryContents = self.contents\
\9else\
\9\9self.file.contents = self.contents\
\9end\
\9if not err then\
\9\9self.isModified = false\
\9end\
\9return err\
end\
\
--[[\
\9@instance\
\9@desc Saves the document's contents to the given path.\
\9@param [string] path -- the path to save to\
\9@return [string/nil] err -- the error message if there was an issue with saving, nil otherwise.\
]]\
function Document:saveAs( path )\
\9if not path then\
\9\9-- show save as dialouge\
\9else\
\9\9local file = self.file.new( path )\
\9\9if self.isBinary then\
\9\9\9file.binaryContents = self.contents\
\9\9else\
\9\9\9file.contents = self.contents\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Serialises the document's contents to the handle. When subclassing you MUST override this! (what's the point of subclassing otherwise?)\
\9@param [handle] handle -- the contents to serialise (don't asume it's equal to self.contents)\
\9@return okay -- whether serialisation was okay. return nil if the handle isn't used (you want to use :serialise) return false if there was an eror.\
\9@return [string] err -- the error message if there was an issue in serialising. this is REQUIRED if contents is returned as false, be helpful to your users.\
]]\
function Document:serialiseHandle( handle )\
end\
\
Document:alias( Document.serialiseHandle, \"serializeHandle\" )\
\
--[[\
\9@instance\
\9@desc Serialises the document's contents to it's raw form for saving. When subclassing you MUST override this! (what's the point of subclassing otherwise?)\
\9@param [string] contents -- the contents to serialise (don't asume it's equal to self.contents)\
\9@return serialisedContents -- the serialised contents. return false if there was an eror.\
\9@return [string] err -- the error message if there was an issue in serialising. this is REQUIRED if contents is returned as false, be helpful to your users.\
]]\
function Document:serialise( contents )\
\9return contents\
end\
\
Document:alias( Document.serialise, \"serialize\" )\
\
--[[\
\9@instance\
\9@desc Called when the path being written to already exists (but not when it's the document's own path). By default makes the application show an alert box. Override this if you want to change that.\
\9@param [string] path -- the path being overwritten\
]]\
function Document:onOverwrite( path )\
\9-- TODO: alert window\
\9error( \"Already exists: \" .. path )\
end\
\
--[[\
\9@instance\
\9@desc Tries to close the document, prompting the user (calling :onClose) if it's been modified\
\9@param [function( [boolean] isClosed )] callback -- the callback to call either after it was closed or the user cancelled. the argument is true if the document was closed, false it's still open\
]]\
function Document:close( callback )\
\9if not self.isModified then\
\9\9self.application.document = false\
\9\9callback( true )\
\9else\
\9\9self:onClose( function( isClosed ) \
\9\9\9if isClosed then self.application.document = false end\
\9\9\9callback( isClosed )\
\9\9end )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the user is asked whether they want to close and save their document. By default makes the application show an alert box. Override this if you want to change that.\
\9@param [function( [boolean] isClosed )] callback -- the callback to call either after it was closed or the user cancelled. the argument is true if the document was closed, false it's still open\
]]\
function Document:onClose( callback )\
\9-- self:save()\
\9callback( false )\
end",
  },
  Theme = {
    [ "text/lua" ] = "\
class \"Theme\" {\
\9name = false;\
\9extends = false; -- the name of the theme this one extends\
\9classes = {};\
\9\
\9static = {\
\9\9active = false; -- @static  the current theme\
\9\9themes = { 1 }; -- @static  a cache of already created themes\
\9}\
}\
\
--[[\
\9@constructor\
\9@desc Loads a theme from name\
\9@param [string] themeName -- the name of the theme\
\9@table [table] cantExtend -- a table of the theme names that the theme can't extend (as they are currently extending, which would cause recussursion)\
]]\
function Theme:initialise( themeName, cantExtend )\
\9cantExtend = cantExtend or {}\
\9if cantExtend[themeName] then\
\9\9error( \"Unabled to extend with theme: \" .. themeName .. \". It is already extended higher up, which would cause recussursion.\", 0 )\
\9end\
\9\
\9self.name = themeName\
\
\9-- TODO: dynamic path resolving for interfaces and other files\
\9local resource = Resource( themeName, Metadata.mimes.STHEME, \"themes\" )\
\9local contents = resource.contents\
\9if contents then\
\9\9local nodes, err = XML.static:fromText( contents )\
\9\9if not nodes then\
\9\9\9error( \"Theme XML invaid: \" .. themeName .. \".stheme. Error: \" .. err, 0 )\
\9\9end\
\9\9cantExtend[themeName] = true\
\9\9local err = self:initialiseTheme( nodes[1], cantExtend )\
\9\9if err then\
\9\9\9error( \"Theme XML invaid: \" .. themeName .. \".stheme. Error: \" .. err, 0 )\
\9\9end\
\9else\
\9\9error( \"Theme file not found: \" .. themeName .. \".stheme\", 0 )\
\9end\
\
\9Theme.static.themes[themeName] = self\
end\
\
--[[\
\9@static\
\9@desc Returns the theme with the given name. This retireves the theme from a cache if it's already been defined and should be used instead of just Theme()\
\9@param [string] themeName -- the name of the theme\
\9@table [table] cantExtend -- a table of the theme names that the theme can't extend (as they are currently extending, which would cause recussursion)\
\9@return [Theme] theme -- the theme with the given name\
]]\
function Theme.static:named( themeName, cantExtend )\
\9return Theme.static.themes[themeName] or Theme( themeName, cantExtend )\
end\
\
--[[\
\9@instance\
\9@desc Creates the container from the interface file\
\9@param [table] nodes -- the nodes from the XML file\
\9@table [table] cantExtend -- a table of the theme names that the theme can't extend (as they are currently extending, which would cause recussursion)\
]]\
function Theme:initialiseTheme( nodes, cantExtend )\
\9if not nodes then\
\9\9return \"Format invalid.\"\
\9elseif nodes.type ~= \"Theme\" then\
\9\9return \"Root element must be 'Theme', got '\" .. tostring( nodes.type ) .. \"'.\"\
\9end\
\
\9local extends = nodes.attributes.extends\
\
\9local classes = {}\
\9if extends then\
\9\9local extendingTheme = Theme.static:named( extends, cantExtend )\
\9\9if not extendingTheme then return \"Tried to extend a non-existant theme: \" .. extends\
\9\9elseif extendingTheme == self.name then return \"Tried to extend self\" end\
\9\9local extendsClasses = extendingTheme.classes\
\
\9\9for className, classNode in pairs( extendsClasses ) do\
\9\9\9local classTheme = {}\
\9\9\9for propertyName, propertyNode in pairs( classNode ) do\
\9\9\9\9local propertyTheme = {}\
\9\9\9\9for styleName, styleValue in pairs( propertyNode ) do\
\9\9\9\9\9propertyTheme[styleName] = styleValue\
\9\9\9\9end\
\9\9\9\9classTheme[propertyName] = propertyTheme\
\9\9\9end\
\9\9\9classes[className] = classTheme\
\9\9end\
\9\9self.extends = extends\
\9end\
\
\9for i, classNode in ipairs( nodes.body ) do\
\9\9local classTheme = classes[classNode.type] or {}\
\9\9for i2, propertyNode in ipairs( classNode.body ) do\
\9\9\9local propertyTheme = classTheme[propertyNode.type] or {}\
\9\9\9local validationTypeName = propertyNode.attributes.type\
\9\9\9for styleName, styleValue in pairs( propertyNode.attributes ) do\
\9\9\9\9if styleName ~= \"type\" then\
\9\9\9\9\9if Validator.static:isValid( styleValue, validationTypeName ) then\
\9\9\9\9\9\9propertyTheme[styleName] = Validator.static:parse( styleValue, validationTypeName )\
\9\9\9\9\9else\
\9\9\9\9\9\9return \"Style value '\" .. tostring( styleValue ) .. \"' is invalid for type '\" .. validationTypeName .. \"' : '\" .. styleName .. \"' (of property: \" .. propertyNode.type .. \" and of class: \" .. classNode.type .. \")\" \
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9\9classTheme[propertyNode.type] = propertyTheme\
\9\9end\
\9\9classes[classNode.type] = classTheme\
\9end\
\9self.classes = classes\
end\
\
--[[\
\9@instance\
\9@desc Gets a value from the theme with the given style for the given class\
\9@param [string] _class -- the name of the class to get the value for\
\9@param [string] propertyName -- the name of the property\
\9@param [string] styleName -- default is \"default\", the style of the value (e.g. disabled, pressed, etc.)\
\9@param [boolean] noError -- whether the function should return false instead of erroring\
\9@return themeValue -- the theme value\
]]\
function Theme:value( _class, propertyName, styleName, noError )\
\9if styleName == \"type\" then\
\9\9error( \"Reserverd style name: \" .. styleName, 0 )\
\9end\
\9styleName = styleName or \"default\"\
\9local className = _class.className\
\
\9local err\
\9local classTheme = self.classes[className]\
\9if classTheme then\
\9\9local propertyTheme = classTheme[propertyName]\
\9\9if propertyTheme then\
\9\9\9local styleValue = propertyTheme[styleName] or propertyTheme[\"default\"]\
\9\9\9if styleValue ~= nil then\
\9\9\9\9return styleValue\
\9\9\9else\
\9\9\9\9err = \"Theme '\" .. self.name .. \"' does not have any definition for style: '\" .. styleName .. \"' or 'default' (of property: \" .. propertyName .. \" and of class: \" .. _class.className .. \")\"\
\9\9\9end\
\9\9else\
\9\9\9err = \"Theme '\" .. self.name .. \"' does not have any definitions for property: '\" .. propertyName .. \"' (of class: \" .. className .. \")\"\
\9\9end\
\9else\
\9\9err = \"Theme '\" .. self.name .. \"' does not have any definitions for class: '\" .. className .. \"'\"\
\9end\
\
\9-- an error occured, try to see if the value was defined for a super class\
\9local super = _class.super\
\9if super then\
\9\9local themeValue = self:value( super, propertyName, styleName, true )\
\9\9if themeValue then\
\9\9\9return themeValue\
\9\9end\
\9end\
\
\9-- there was no value defined for a super class\
\9if noError then\
\9\9return false\
\9else\
\9\9error( err, 0 )\
\9end\
end",
  },
  ThemeOutlet = {
    [ "text/lua" ] = "\
class \"ThemeOutlet\" {\
\9style = \"default\";\
\9owner = false;\
\9ownerClass = false;\
\9connections = {};\
}\
\
--[[\
\9@constructor\
\9@desc Creates a ThemeOutlet\
\9@param [class] owner -- the outlet owner\
]]\
function ThemeOutlet:initialise( owner )\
\9self.owner = owner\
\9self.ownerClass = owner.class\
\9owner.event:connectGlobal( ThemeChangedInterfaceEvent, self.onThemeChange, nil, self )\
end\
\
--[[\
\9@instance\
\9@desc Returns the value for the given key, using the current theme style\
\9@param [string] key -- the key of the value\
\9@return value -- the value\
]]\
-- function ThemeOutlet:get( key )\
-- \9if key == \"class\" or self.definedBoth[key] or class.defined[key] then return false end\
-- \9return true, self:themeValue( key, self.style )\
-- end\
\
--[[\
\9@instance\
\9@desc Connect a class value to a theme value, updating it each time the style is changed\
\9@param [class] _class -- the class to connect the value to\
\9@param [string] classKey -- the key of the class' value\
\9@param [string] key -- the key of the value\
]]\
function ThemeOutlet:connect( _class, classKey, key )\
\9self:disconnect( _class, classKey, key )\
\9key = key or classKey\
\9if not _class:isDefinedProperty( classKey ) then\
\9\9error( \"Attempted to connect theme to undefined property '\" .. classKey .. \"' for object '\" .. tostring( _class ) .. \"'\", 4 )\
\9end\
\9table.insert( self.connections, { _class, classKey, key, _class[classKey] } )\
\9_class[classKey] = self:value( key, style )\
end\
\
--[[\
\9@instance\
\9@desc Disconnect a class value from a theme value\
\9@param [class] _class -- the class that was connected\
\9@param [string] classKey -- the key of the class' value\
\9@param [string] key -- the key of the value\
]]\
function ThemeOutlet:disconnect( _class, classKey, key )\
\9key = key or classKey\
\9for i, connection in pairs( self.connections ) do\
\9\9if _class == connection[1] and classKey == connection[2] and key == connection[3] then\
\9\9\9self.connections[i] = nil\
\9\9\9_class[classKey] = connection[4]\
\9\9\9return\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Fired when the theme changes, updates the value\
\9@param [string] style -- the style name\
]]\
function ThemeOutlet:onThemeChange( Event event, Event.phases phase )\
\9local style = self.style\
\9for i, connection in pairs( self.connections ) do\
\9\9connection[1][connection[2]] = self:value( connection[3], style )\
\9end\
\
end\
\
--[[\
\9@instance\
\9@desc Sets the current style (pressed, checked, disabled, etc) for the owner\
\9@param [string] style -- the style name\
]]\
function ThemeOutlet.style:set( style )\
\9self.style = style\
\9for i, connection in pairs( self.connections ) do\
\9\9connection[1][connection[2]] = self:value( connection[3], style )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns the value for the current theme given the property name and style)\
\9@param [string] propertyName -- the name of the property\
\9@param [string] styleName -- defaults to the current style\
\9@return themeValue -- the theme value\
]]\
function ThemeOutlet:value( valueName, styleName )\
\9return Theme.static.active:value( self.ownerClass, valueName, styleName or self.style )\
end",
  },
  XML = {
    [ "text/lua" ] = "\
-- TODO: XML bug. backslashes in attributes don't work. A single \"\\\" results in: expected '\"' to close string. While \"\\\\\"\" results in two backslashes being the parsed text\
\
local function fromXMLString( value )\
\9value = string.gsub(value, \"&#x( [%x]+ )%;\",\
\9\9function( h ) \
\9\9\9return string.char( tonumber(h,16) )\
\9\9end);\
\9value = string.gsub(value, \"&#([0-9]+)%;\",\
\9\9function( h )\
\9\9\9return string.char( tonumber(h,10) )\
\9\9end);\
\9value = string.gsub (value, \"&quot;\", \"\\\"\");\
\9value = string.gsub (value, \"&apos;\", \"'\");\
\9value = string.gsub (value, \"&gt;\", \">\");\
\9value = string.gsub (value, \"&lt;\", \"<\");\
\9value = string.gsub (value, \"&amp;\", \"&\");\
\9return value;\
end\
\
local function lex( text )\
\9local tokens = {}\
\9local pos, line, char = 1, 1, 1\
\9local function push( type, value )\
\9\9tokens[#tokens + 1] = {\
\9\9\9type = type;\
\9\9\9value = value;\
\9\9\9char = char;\
\9\9\9line = line;\
\9\9}\
\9end\
\9while pos <= #text do\
\9\9local c = text:sub( pos, pos )\
\9\9if c == \"\\n\" then\
\9\9\9line = line + 1\
\9\9\9char = 1\
\9\9\9pos = pos + 1\
\9\9elseif c:find \"%s\" then\
\9\9\9pos = pos + #text:match( \"%s+\", pos )\
\9\9elseif c == \"\\\"\" or c == \"'\" then\
\9\9\9local e, f, l = false, false, line\
\9\9\9for i = pos + 1, #text do\
\9\9\9\9if e then\
\9\9\9\9\9e = false\
\9\9\9\9elseif text:sub( i, i ) == \"\\\\\" then\
\9\9\9\9\9e = true\
\9\9\9\9elseif text:sub( i, i ) == c then\
\9\9\9\9\9push( \"string\", fromXMLString( text:sub( pos + 1, i - 1 ) ) )\
\9\9\9\9\9pos = i + 1\
\9\9\9\9\9f = true\
\9\9\9\9\9break\
\9\9\9\9elseif text:sub( i, i ) == \"\\n\" then\
\9\9\9\9\9line = line + 1\
\9\9\9\9end\
\9\9\9end\
\9\9\9if not f then\
\9\9\9\9return false, \"[\" .. l .. \" (char:\" .. char .. \")]: expected '\" .. c .. \"' to close string\"\
\9\9\9end\
\9\9elseif c:find \"[a-zA-Z%-%._]\" then\
\9\9\9local v = text:match( \"[a-zA-Z%d%-%._]+\", pos )\
\9\9\9push( \"word\", v )\
\9\9\9pos = pos + #v\
\9\9elseif text:find( \"^#?%.?%d\", pos ) then\
\9\9\9local v = text:match( \"^#?%d*%.?%d+%%?\", pos )\
\9\9\9pos = pos + #v\
\9\9\9local percentage = false\
\9\9\9if v:sub( -1 ) == \"%\" then\
\9\9\9\9v = v:sub( 1, -2 )\
\9\9\9\9percentage = true\
\9\9\9end\
\9\9\9if v:sub( 1, 1 ) == \"#\" then\
\9\9\9\9v = tonumber( v:sub( 2 ), 16 )\
\9\9\9else\
\9\9\9\9v = tonumber( v )\
\9\9\9end\
\9\9\9if percentage then\
\9\9\9\9v = v / 100\
\9\9\9end\
\9\9\9push( \"number\", v )\
\9\9elseif text:find( \"^<!%-%-.-%-%->\", pos ) then\
\9\9\9pos = pos + #text:match( \"^<!%-%-.-%-%->\", pos )\
\9\9else\
\9\9\9push( \"symbol\", c )\
\9\9\9pos = pos + 1\
\9\9end\
\9end\
\9return tokens\
end\
\
local parser = {}\
function parser:new( tokens )\
\9local t = setmetatable( {}, { __index = self } )\
\9t.tokens = tokens\
\9t.pos = 1\
\9t.last = tokens[1]\
\9t.exception = false\
\9return t\
end\
\
function parser:throw( message )\
\9if self.last then\
\9\9self.exception = \"[line \" .. self.last.line .. \", char \" .. self.last.char .. \"]: \" .. message\
\9else\
\9\9self.exception = \"[unknown]: \" .. message\
\9end\
\9return false, self.exception\
end\
\
function parser:thrown()\
\9return self.exception\
end\
\
function parser:peek()\
\9return self.tokens[self.pos]\
end\
\
function parser:next()\
\9self.pos = self.pos + 1\
\9self.last = self.tokens[self.pos] or self.last\
\9return self.tokens[self.pos]\
end\
\
function parser:test( type, value )\
\9local token = self:peek()\
\9return token and token.type == type and ( not value or token.value == value )\
end\
\
function parser:parseXMLInitialiser()\
\9local closing = false\
\
\9if self:test( \"symbol\", \"/\" ) then\
\9\9closing = true\
\9\9self:next()\
\9end\
\
\9if not self:test \"word\" then\
\9\9return self:throw \"expected name of XML item\"\
\9end\
\
\9local name = self:peek().value\
\9self:next()\
\
\9if closing then\
\9\9if self:test( \"symbol\", \">\" ) then\
\9\9\9self:next()\
\9\9else\
\9\9\9return self:throw \"expected '>' to close closing tag\"\
\9\9end\
\9end\
\
\9return name, closing\
end\
\
function parser:parseXMLAttributes()\
\9local attributes = {}\
\9while true do\
\9\9if self:test \"word\" then\
\9\9\9local name = self:peek().value\
\9\9\9self:next()\
\
\9\9\9if self:test( \"symbol\", \"=\" ) or self:test( \"symbol\", \":\" ) then\
\9\9\9\9local v = self:next()\
\
\9\9\9\9if v.type == \"number\" or v.type == \"string\" then\
\9\9\9\9\9attributes[name] = v.value\
\9\9\9\9elseif v.type == \"word\" then\
\9\9\9\9\9local word = v.value\
\9\9\9\9\9if word == \"true\" or word == \"false\" then\
\9\9\9\9\9\9word = word == \"true\"\
\9\9\9\9\9end\
\9\9\9\9\9attributes[name] = word\
\9\9\9\9else\
\9\9\9\9\9return self:throw( \"unexpected \" .. v.type .. \" as attribute value\" )\
\9\9\9\9end\
\
\9\9\9\9self:next()\
\9\9\9else\
\9\9\9\9attributes[name] = true\
\9\9\9\9self:next()\
\9\9\9end\
\9\9elseif self:test( \"symbol\", \"/\" ) then\
\9\9\9self:next()\
\9\9\9if not self:test( \"symbol\", \">\" ) then\
\9\9\9\9return self:throw \"expected '>' after '/' to close opening tag\"\
\9\9\9end\
\
\9\9\9self:next()\
\9\9\9return attributes, false\
\9\9elseif self:test( \"symbol\", \">\" ) then\
\9\9\9self:next()\
\9\9\9return attributes, true\
\9\9elseif not self:peek() then\
\9\9\9return attributes, false\
\9\9else\
\9\9\9return self:throw( \"unexpected \" .. self:peek().type .. \" in attributes\" )\
\9\9end\
\9end\
end\
\
function parser:parseXMLBody()\
\9local blocks = {}\
\
\9while self:peek() do\
\9\9while not self:test( \"symbol\", \"<\" ) do\
\9\9\9self:next()\
\9\9end\
\
\9\9self:next()\
\9\9local type, isClosing = self:parseXMLInitialiser()\
\9\9if self:thrown() then\
\9\9\9return false, self.exception\
\9\9end\
\
\9\9if isClosing then\
\9\9\9return blocks, type\
\9\9end\
\
\9\9local attributes, hasBody = self:parseXMLAttributes()\
\9\9if self:thrown() then\
\9\9\9return false, self.exception\
\9\9end\
\
\9\9local body, closer\
\9\9if hasBody then\
\9\9\9body, closer = self:parseXMLBody()\
\9\9\9if self:thrown() then\
\9\9\9\9return false, self.exception\
\9\9\9end\
\9\9\9if not closer then\
\9\9\9\9return self:throw( \"expected '</\" .. type .. \">' to close XML item, got nothing\" )\
\9\9\9elseif closer ~= type then\
\9\9\9\9return self:throw( \"expected '</\" .. type .. \">' to close XML item, got '</\" .. closer .. \">'\" )\
\9\9\9end\
\9\9end\
\
\9\9blocks[#blocks + 1] = {\
\9\9\9type = type;\
\9\9\9attributes = attributes;\
\9\9\9body = body;\
\9\9}\
\9end\
\
\9return blocks\
end\
\
class \"XML\" {}\
\
--[[\
\9@static\
\9@desc Loads XML from source text\
\9@param [string] xmlText -- the XML text to parse\
\9@return [table] xmlNodes -- the parsed XML nodes\
\9on error:\
\9@return false\
\9@return [string] error -- the error message\
]]\
function XML.static:fromText( xmlText )\
\9local tokens, err = lex( xmlText )\
\9if not tokens then\
\9\9return false, err\
\9end\
\
\9local p = parser:new( tokens )\
\9local blocks, data = p:parseXMLBody()\
\
\9if not blocks then\
\9\9return false, data\
\9end\
\9if data then -- if they put a </*> in the main body\
\9\9return p:throw( \"unexpected '</\" .. data .. \">' in main body\" )\
\9end\
\9return blocks\
end\
\
--[[\
\9@static\
\9@desc Loads an XML file\
\9@param [string] filePath -- the path to the XML file\
\9@return [table] xmlNodes -- the parsed XML nodes\
]]\
function XML.static:fromFile( filePath )\
\9local h = fs.open( filePath, \"r\" )\
\9if not h then\
\9\9error( \"Failed to open XML file: \" .. filePath, 0 )\
\9end\
\
\9local text = h.readAll()\
\9h.close()\
\9return XML.fromText( text )\
end",
  },
  BackSymbol = {
    [ "text/lua" ] = "\
class \"BackSymbol\" extends \"Symbol\" {\
\
    symbolName =  \"back\";\
\
    width = 4;\
\
    serialisedPaths = {\
        {\
            x = 1,\
            y = 1,\
            lines = {\
                {\
                    y1 = 1,\
                    x1 = 1,\
                    x2 = 4,\
                    mode = \"linear\",\
                    y2 = 4,\
                },\
                {\
                    y1 = 4,\
                    x1 = 4,\
                    x2 = 1,\
                    mode = \"linear\",\
                    y2 = 7,\
                },\
                {\
                    y1 = 7,\
                    x1 = 1,\
                    x2 = 1,\
                    mode = \"linear\",\
                    y2 = 1,\
                },\
            },\
            height = 7,\
            width = 4,\
        }\
    }\
\
\
}",
  },
  Validator = {
    [ "text/lua" ] = "\
-- validates and parses values (so BLUE becomes Graphics.colours.BLUE)\
class \"Validator\" {}\
\
--[[\
\9@instance\
\9@desc Gets a validation table from the given type name\
\9@param [string] typeName -- the type to validate against\
\9@return [Validator.validatorType] validatorType -- the table of valid values\
]]\
function Validator.static:validatorType( typeName )\
\9-- TODO: make validator types dynamic\
\9if typeName == \"Graphics.colours\" then\
\9\9return function( k ) return Graphics.colours[k] end\
\9elseif typeName == \"number\" then\
\9\9return tonumber\
\9elseif typeName == \"string\" then\
\9\9return tostring\
\9elseif typeName == \"boolean\" or typeName == \"bool\" then\
\9\9return function( K ) local k = K:lower() if k == \"true\" then return true elseif k == \"false\" then return false end end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Validate a value against the given type\
\9@param value -- the value to validate\
\9@param [string] typeName -- the type to validate against\
\9@return [boolean] isValid -- whether the value is valid\
]]\
function Validator.static:isValid( value, typeName )\
\9local validatorType = self:validatorType( typeName )\
\9return validatorType( value ) ~= nil\
end\
\
--[[\
\9@instance\
\9@desc Parse a value to the given type\
\9@param value -- the value to parse\
\9@param [string] typeName -- the type to parse to\
\9@return parsedValue -- the parsed value\
]]\
function Validator.static:parse( value, typeName )\
\9local validatorType = self:validatorType( typeName )\
\9return validatorType( value )\
end",
  },
  KeyboardShortcut = {
    [ "text/lua" ] = "\
class \"KeyboardShortcut\" {\
\9keys = {};\
}\
\
--[[\
\9@constructor\
\9@desc Creates a keyboard shortcut\
\9@param ... -- all the keys for the shortcut\
]]\
function KeyboardShortcut:initialise( ... )\
\9self.keys = { ... }\
end\
\
--[[\
\9@instance\
\9@desc Returns the symbol string to be used on menus and elsewhere to represent the shortcut\
\9@return [string] symbols -- the symbols string\
]]\
function KeyboardShortcut:symbols()\
\9local symbols = \"\"\
\9local symbol = KeyboardShortcutManager.symbol\
\9for i, keyString in ipairs( self.keys ) do\
\9\9symbols = symbols .. symbol( keyString )\
\9end\
\9return symbols\
end\
\
--[[\
\9@instance\
\9@desc Creates a keyboard shortcut from a string. Each key is separated by a space. Keys represented by a character (i.e. a, 5, /) should be written as the character. Other posibilities are: ctrl (also acts as command on OS X), alt, shift, tab, esc, delete, backspace, enter, left, right, up, down, fn, home, end, f1, f2 .. f12\
\9@param [string] keys -- the shortcut string\
\9@return [KeyboardShortcut] keyboardShortcut -- the keyboard shortcut\
]]\
function KeyboardShortcut.static:fromString( str )\
\9local parts = String( str ):split( \" \" )\
\9local keys = {}\
\
\9local isValid = KeyboardShortcutManager.isValid\9\
\9for i, key in ipairs( parts ) do\
\9\9if #key > 0 then\
\9\9\9if isValid( key ) then\
\9\9\9\9table.insert( keys, key )\
\9\9\9else\
\9\9\9\9error( \"Invalid keyboard shortcut '\" .. str ..\"'. The key '\" .. key .. \"' is not valid. Omit sides (i.e. leftShift is just shift) and use the character where possible (i.e. / not slash)\", 0 )\
\9\9\9end\
\9\9end\
\9end\
\
\9return KeyboardShortcut( unpack( keys ) )\
end\
\
--[[\
\9@instance\
\9@desc Compares the shortcut to a keyboard shortcut event\
\9@param [KeyboardShortcutEvent] event -- the keyboard shortcut event\
\9@return [boolean] isMatch -- whether the keyboard shortcut was a match (i.e. the keys are down)\
]]\
function KeyboardShortcut:matchesEvent( event )\
\9return event:matchesKeys( self.keys )\
end",
  },
  Button = {
    [ "text/lua" ] = "\
class \"Button\" extends \"View\" {\
\
    height = 16; -- the default height\
    width = 36;\
    text = false;\
\
    isPressed = false;\
    isFocused = false;\
    isAutosizing = true;\
    font = false;\
\
    shadowObject = false;\
    backgroundObject = false;\
    isFocusDismissable = false;\
    textObject = false;\
\
    needsAutosize = false;\
    margin = Number;\
    leftMargin = 0;\
    rightMargin = 0;\
}\
\
-- action Button.buttonOne function( event )\
-- end\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function Button:initialise( ... )\
    self:super( ... )\
\
    self:event( MouseDownEvent, self.onMouseDown )\
    self:event( KeyDownEvent, self.onKeyDown )\
    self:event( KeyUpEvent, self.onKeyUp )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Button:initialiseCanvas()\
    self:super()\
    local width, height, theme, canvas = self.width, self.height, self.theme, self.canvas\
    local shadowObject = canvas:insert( RoundedRectangle( 2, 2, width - 1, height - 1, theme:value( \"shadowColour\" ) ) )\
    local backgroundObject = canvas:insert( RoundedRectangle( 1, 1, width - 1, height - 1, theme.fillColour, theme.outlineColour, cornerRadius ) )\
    local textObject = canvas:insert( Text( 1, 5, width, 10, self.text ) )\
\
    theme:connect( backgroundObject, \"fillColour\" )\
    theme:connect( backgroundObject, \"outlineColour\" )\
    theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    theme:connect( shadowObject, \"fillColour\", \"shadowColour\" )\
    theme:connect( shadowObject, \"radius\", \"cornerRadius\" )\
    theme:connect( textObject, \"textColour\" )\
    theme:connect( self, \"leftMargin\" )\
    theme:connect( self, \"rightMargin\" )\
\
    self.backgroundObject = backgroundObject\
    self.shadowObject = shadowObject\
    self.textObject = textObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
function Button:updateHeight( height )\
    self.backgroundObject.height = height - 1\
    self.shadowObject.height = height - 1\
    -- self.needsAutosize = true\
end\
\
function Button:updateWidth( width )\
    self.backgroundObject.width = width - 1\
    self.shadowObject.width = width - 1\
    local textObject = self.textObject\
    if textObject then\
        local leftMargin, rightMargin = self.leftMargin, self.rightMargin\
        textObject.x = self.isPressed and leftMargin + 2 or leftMargin + 1\
        textObject.width = width - leftMargin - rightMargin\
    end\
end\
\
function Button.text:set( text )\
    self.text = text\
    local textObject = self.textObject\
    if textObject then\
        textObject.text = text\
    end\
    self.needsAutosize = true\
end\
\
--[[\
    @instance\
    @desc Set the margin on either side of the text\
    @param [number] margin -- the space around the text\
]]\
function Button.margin:set( margin )\
    self.leftMargin = margin\
    self.rightMargin = margin\
end\
\
--[[\
    @instance\
    @desc Set the margin on the left side of the text\
    @param [number] margin -- the space around the left side of the text\
]]\
function Button.leftMargin:set( leftMargin )\
    self.leftMargin = leftMargin\
    self.needsAutosize = true\
end\
\
--[[\
    @instance\
    @desc Set the margin on the left side of the text\
    @param [number] margin -- the space around the left side of the text\
]]\
function Button.rightMargin:set( rightMargin )\
    self.rightMargin = rightMargin\
    self.needsAutosize = true\
end\
\
function Button:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsAutosize then\
        self:autosize()\
    end\
end\
\
function Button.font:set( font )\
    self.font = font\
    local textObject = self.textObject\
    if textObject then\
        textObject.font = font\
        self.needsAutosize = true\
    end\
end\
\
function Button.needsAutosize:set( needsAutosize )\
    self.needsAutosize = needsAutosize\
end\
\
--[[\
    @instance\
    @desc Automatically resizes the button, regardless of isAutosizing value, to fit the text\
]]\
function Button:autosize()\
    -- TODO: support self.isAutosizing\
    local font, text = self.font, self.text\
\
    if font and text then\
        local fontWidth = font:getWidth( text )\
        self.width = fontWidth + self.leftMargin + self.rightMargin + 1\
\
        local fontHeight = font.height\
        self.height = fontHeight + 8\
    end\
    self.needsAutosize = false\
end\
\
function Button:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or ( self.isFocused and \"focused\" or \"default\" ) ) or \"disabled\"\
end\
\
function Button.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function Button.isPressed:set( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
    local backgroundObject = self.backgroundObject\
    backgroundObject.x = isPressed and 2 or 1\
    backgroundObject.y = isPressed and 2 or 1\
    local textObject = self.textObject\
    -- textObject.x = isPressed and self.leftMargin + 2 or self.leftMargin + 1\
    if textObject then\
        textObject.y = isPressed and 6 or 5\
    end\
end\
\
function Button.isFocused:set( isFocused )\
    self.isFocused = isFocused\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled and self:hitTestEvent( event ) then\
            self.event:handleEvent( ActionInterfaceEvent( self ) )\
            local result = self.event:handleEvent( event )\
            return result == nil and true or result\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when a key is pressed down. Presses the button down if it isin focus and it was the enter key.\
    @param [KeyDownEvent] event -- the key down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onKeyDown( Event event, Event.phases phase )\
    if self.isEnabled and self.isFocused and event.keyCode == keys.enter then\
        self.isPressed = true\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when a key is pressed released. Fires the button action if the button is pressed, in focus and it was the enter key.\
    @param [KeyUpEvent] event -- the key down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onKeyUp( Event event, Event.phases phase )\
    if self.isEnabled and self.isPressed and self.isFocused and event.keyCode == keys.enter then\
        self.isPressed = false\
    self.event:handleEvent( ActionInterfaceEvent( self ) )\
        return true\
    end\
end",
  },
  Window = {
    [ "text/lua" ] = "\
class \"Window\" extends \"Container\" {\
\9-- separatorObject = false;\9\
\9-- shadowObject = false;\
\9-- barObject = false;\
\9barHeight = 7;\
\
\9container = false;\
    closeButton = false;\
    minimiseButton = false;\
    maximiseButton = false;\
    isEnabled = false;\
\
\9dragX = false;\
\9dragY = false;\
    isDragging = false;\
    isResizingX = false;\
\9isResizingY = false;\
\
    minWidth = 60;\
    minHeight = 40;\
    maxWidth = 300;\
    maxHeight = 150;\
\
    isCanvasHitTested = false;\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function Window:initialise( ... )\
\9self:super( ... )\
    self.closeButton = self:insert( CloseWindowButton( { x = 1, y = 1, window = self } ))\
    self.minimiseButton = self:insert( MinimiseWindowButton( { x = 9, y = 1, window = self } ))\
    self.maximiseButton = self:insert( MaximiseWindowButton( { x = 17, y = 1, window = self } ))\
\
    self:loadInterface()\
    \
    self:event( MouseDownEvent, self.onMouseDownBefore, Event.phases.BEFORE )\
    self:event( MouseDownEvent, self.onMouseDownAfter, Event.phases.AFTER )\
    self.event:connectGlobal( MouseDragEvent, self.onGlobalMouseDrag )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
    self:event( LoadedInterfaceEvent, self.onInterfaceLoaded )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Window:initialiseCanvas()\
    self:super()\
    -- self.canvas.fillColour = Graphics.colours.GREEN\
\9local barHeight = self.barHeight\
    local shadowObject = self.canvas:insert( RoundedRectangle( 3, 4, self.width - 2, self.height - 3 ) )\
    local barObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width - 2, barHeight ) )\
    local separatorObject = self.canvas:insert( Rectangle( 1, barHeight + 1, self.width - 2, 1 ) )\
\
    self.theme:connect( barObject, \"fillColour\", \"barColour\" )\
    self.theme:connect( barObject, \"topRadius\", \"topCornerRadius\" )\
    self.theme:connect( separatorObject, \"fillColour\", \"separatorColour\" )\
    self.theme:connect( shadowObject, \"topRadius\", \"topCornerRadius\" )\
    self.theme:connect( shadowObject, \"bottomRadius\", \"bottomCornerRadius\" )\
    self.theme:connect( shadowObject, \"fillColour\", \"shadowColour\" )\
    self.shadowObject = shadowObject\
\9self.barObject = barObject\
\9self.separatorObject = separatorObject\
end\
\
--[[\
    @instance\
    @desc Loads the interface specified by the self.interfaceName interface name\
]]\
function Window:loadInterface()\
    local interfaceName = self.interfaceName\
    if interfaceName then\
        local barHeight = self.barHeight\
        local x, y, width, height = 1, barHeight + 2, self.width - 2, self.height - barHeight - 5\
        local container = Interface( interfaceName, WindowContainer ).container\
        container.x = x\
        container.y = y\
        container.width = width\
        container.height = height\
        self.container = self:insert( container )\
    else\
        self.container = self:insert( WindowContainer( { x = x, y = y, width = width, height = height } ) )\
    end\
end\
\
function Window.height:set( height )\
    height = math.max( math.min( height, self.maxHeight ), self.minHeight )\
    self:super( height )\
    self.shadowObject.height = height - 3\
    local container = self.container\
    if container then container.height = height - self.barHeight - 5 end\
end\
\
function Window.width:set( width )\
    width = math.max( math.min( width, self.maxWidth ), self.minWidth )\
    self:super( width )\
    self.shadowObject.width = width - 2\
    self.barObject.width = width - 2\
    self.separatorObject.width = width - 2\
    local container = self.container\
    if container then container.width = width - 2 end\
end\
\
function Window:onInterfaceLoaded( Event event, Event.phases phase )\
    local currentContainer = self.container\
    for i, childView in ipairs( self.children ) do\
        if childView ~= currentContainer and childView:typeOf( WindowContainer ) then\
            childView.x = 1\
            childView.y = self.barHeight + 2\
            childView.width = self.width - 2\
            childView.height = self.height - self.barHeight - 5\
            self:remove( self.container )\
            self.container = childView\
            break\
        end\
    end\
end\
\
function Window:updateThemeStyle()\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
function Window.isEnabled:set( isEnabled )\
    self:super( isEnabled )\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Centres the window relative to it's parent (which should be the application container)\
]]\
function Window:centre()\
    local parent = self.parent\
    if parent then\
        self.x = math.ceil( ( parent.width - self.width ) / 2)\
        self.y = math.ceil( ( parent.height - self.height ) / 2)\
    end\
end\
\
Window:alias( Window.centre, \"center\" )\
\
--[[\
    @instance\
    @desc Focus on the window, bringing it to the front and enabling controls whilst unfocusing other windows\
]]\
function Window:focus()\
    if not self.isEnabled then\
        self.application:clearFocus( Window )\
        self.isEnabled = true\
        self.parent:sendToFront( self )\
        for i, sibling in ipairs( self:siblingsOfType( Window ) ) do\
            sibling:unfocus()\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Unfocus on the window, disabling controls\
]]\
function Window:unfocus()\
    self.isEnabled = false\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed on the window bar before children have recieved the event. Makes the window front most and active\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onMouseDownBefore( Event event, Event.phases phase )\
    self:focus()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed on the window bar after children have recieved the event. Starts dragging.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onMouseDownAfter( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        x = event.x\
        y = event.y\
        local width = self.width\
        local height = self.height\
        local isResizingX = x >= width - 6\
        local isResizingY = y >= height - 8\
        self.isResizingX = isResizingX\
        self.isResizingY = isResizingY\
        self.isDragging = not ( isResizingX or isResizingY )\
        self.dragX = isResizingX and width - x or x\
        self.dragY = isResizingY and height - y or y\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is dragged anywhere on screen. Moves the window if dragging\
    @param [Event] event -- the mouse drag event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onGlobalMouseDrag( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        local preventPropagation = false\
        if self.isDragging then\
            self.x = event.x - self.dragX + 1\
            self.y = event.y - self.dragY + 1\
            preventPropagation = true\
        else\
            if self.isResizingX then\
                self.width = event.x - self.x + self.dragX + 1\
                preventPropagation = true\
            end\
            if self.isResizingY then\
                self.height = event.y - self.y + self.dragY + 1\
                preventPropagation = true\
            end\
        end\
        return preventPropagation\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Stops dragging\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onGlobalMouseUp( Event event, Event.phases phase )\
    if (self.isDragging or self.isResizingX or self.isResizingY ) and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.dragX = false\
        self.dragY = false\
        self.isDragging = false\
        self.isResizingX = false\
        self.isResizingY = false\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Closes the window, removing it from the screen\
]]\
function Window:close()\
    self.isVisible = false\
    self.parent:remove( self )\
end",
  },
  WindowButton = {
    [ "text/lua" ] = "\
class \"WindowButton\" extends \"View\" {\
\9width = 9;\
\9height = 7;\
    isPressed = false;\
    backgroundObject = false;\
    symbolObject = false;\
    window = false;\
}\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function WindowButton:initialise( ... )\
    self:super( ... )\
    \
    self:event( MouseDownEvent, self.onMouseDown )\
    self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )\
    if self.onMouseUp then self:event( MouseUpEvent, self.onMouseUp ) end\
end\
\
function WindowButton:initialiseCanvas()\
\9self:super()\
\
    local backgroundObject = self.canvas:insert( Circle( 3, 2, 5, 5 ) )\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    -- local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height ) )\
\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    -- self.theme:connect( backgroundObject, \"topLeftRadius\", \"cornerRadius\" )\
\
\
\
    self.backgroundObject = backgroundObject\
end\
\
function WindowButton:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function WindowButton.isEnabled:set( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function WindowButton.isPressed:set( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function WindowButton:onGlobalMouseUp( Event event, Event.phases phase )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled and self:hitTestEvent( event ) then\
            return self.event:handleEvent( event )\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function WindowButton:onMouseDown( Event event, Event.phases phase )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end",
  },
  Canvas = {
    [ "text/lua" ] = "\
class \"Canvas\" extends \"GraphicsObject\" {\
    fillColour = Graphics.colours.TRANSPARENT; -- The colour of the Canvas when it clears\
    buffer = {};\
    children = {};\
    owner = false; -- @property [View] - The view that owns this objects\
}\
\
--[[\
    @constructor\
    @desc Creates a canvas\
    @param [number] width -- the width of the canvas\
    @param [number] height -- the height of the canvas\
]]\
function Canvas:initialise( x, y, width, height, owner )\
    self:super( x, y, width, height )\
    self.owner = owner or false\
end\
\
--[[\
    @instance\
    @desc Sets the pixel colour and the given coordinates\
    @param [number] x -- the x coordinate of the pixel\
    @param [number] y -- the y coordinate of the pixel\
    @param [colour] colour -- the colour coordinate of the pixel\
]]\
function Canvas:setPixel( x, y, colour )\
    if colour ~= Graphics.colours.TRANSPARENT and x >= 1 and y >= 1 and x <= self.width and y <= self.height then\
        self.buffer[ ( y - 1 ) * self.width + x ] = colour\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Gets the pixel colour and the given coordinates\
    @param [number] x -- the x coordinate of the pixel\
    @param [number] y -- the y coordinate of the pixel\
    @return [colour] colour -- the colour of the pixel\
]]\
function Canvas:getPixel( x, y )\
    return self.buffer[ ( y - 1 ) * self.width + x ] or self.fillColour\
end\
\
--[[\
    @instance\
    @desc Clears the buffer\
    @return self\
]]\
function Canvas:clear()\
    self.buffer = {}\
    return self\
end\
\
--[[\
    @instance\
    @desc Adds a shader to screen area\
    @param [Canvas.shader] shader -- the shader to use\
    @param [number] x -- default 1, the x coordinate of the area\
    @param [number] y -- default 1, the y coordinate of the area\
    @param [number] width -- default canvas width, the width of the area\
    @param [number] height -- default canvas height, the height of the area\
    @return self\
]]\
function Canvas:map( shader, x, y, width, height )\
    local changes = {}\
    for _x = x or 1, ( x or 1 ) + ( width or self.width ) - 1 do\
        for _y = y or 1, ( x or 1 ) + ( height or self.height ) - 1 do\
            local colour = shader( _x, _y, self:getPixel( _x, _y ) )\
            if colour and colour ~= 0 then\
                changes[#changes + 1] = { _x, _y, colour }\
            end\
        end\
    end\
    local buffer = self.buffer\
    local width, height = self.width, self.height\
    local TRANSPARENT = Graphics.colours.TRANSPARENT\
    local function setPixel( x, y, colour )\
        if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= width and y <= height then\
            buffer[ ( y - 1 ) * width + x ] = colour\
        end\
        return self\
    end\
    for i = 1, #changes do\
        setPixel( unpack( changes[i] ) )\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Adds a graphics object to the canvas\
    @param [GraphicsObject] graphicsObject -- the graphics object to add\
    @return self\
]]\
function Canvas:insert( graphicsObject )\
    if not graphicsObject then\
        error( \"GraphicsObject not supplied in canvas:insert\", 3 )\
    end\
    self.hasChanged = true\
    if graphicsObject.parent then\
        graphicsObject.parent:remove( graphicsObject )\
    end\
    graphicsObject.raw.parent = self\
    log(\"insert \"..tostring(graphicsObject))\
    self.children[#self.children + 1] = graphicsObject\
    return graphicsObject\
end\
\
--[[\
    @instance\
    @desc Removes a graphics object from the canvas\
    @param [GraphicsObject] graphicsObject -- the graphics object to remove\
    @return self\
]]\
function Canvas:remove( graphicsObject )\
    local c = false\
    for i = #self.children, 1, -1 do\
        if self.children[i] == graphicsObject then\
            table.remove( self.children, i )\
            graphicsObject.raw.parent = false\
            c = true\
        end\
    end\
    if c then\
        self.hasChanged = true\
    end\
    return graphicsObject\
end\
\
--[[\
    @instance\
    @desc Clears the buffer then draws the objects of the canvas\
    @return self\
]]\
function Canvas:draw( isShadow )\
    if self.isVisible then\
        self.buffer = {}\
        local children = self.children\
        log(\"childred of \" .. tostring(self))\
        for i = 1, #children do\
            log(children[i])\
            children[i]:drawTo( self, isShadow )\
        end\
        self.hasChanged = false\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Draws the canvas to another canvas\
    @param [Canvas] canvas -- the canvas to draw to\
    @return self\
]]\
function Canvas:drawTo( canvas, isShadow )\
    local drawsShadow = self.drawsShadow\
    if self.isVisible then\
        if isShadow or self.hasChanged then\
            -- local drawdt = os.clock()\
            self:draw( isShadow )\
        end\
        \
        local width = self.width\
        local height = self.height\
        local fillColour = self.fillColour\
        local buffer = self.buffer\
        local _x = self.x - 1\
        local _y = self.y\
        \
\
        local setPixel\
        local TRANSPARENT = Graphics.colours.TRANSPARENT\
\
        local canvasWidth = canvas.width\
        local canvasHeight = canvas.height\
        local canvasBuffer = canvas.buffer\
        if isShadow then\
            local shadowColour\
            local owner = self.owner\
            if owner then\
                shadowColour = owner.theme.shadowColour\
            else\
                shadowColour = Graphics.colours.GREEN\
            end\
            setPixel = function( x, y, colour )\
                if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= canvasWidth and y <= canvasHeight then\
                    canvasBuffer[ ( y - 1 ) * canvasWidth + x ] = shadowColour\
                end\
            end\
        else\
            setPixel = function( x, y, colour )\
                if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= canvasWidth and y <= canvasHeight then\
                    canvasBuffer[ ( y - 1 ) * canvasWidth + x ] = colour\
                end\
            end\
        end\
\
        -- local start = os.clock()\
\
        for x = 1, width do\
            for y = 0, height - 1 do -- just so there's no need for y-1 below\
                local colour = buffer[y * width + x] or fillColour\
                local nx, ny = x + _x, y + _y\
                setPixel( nx, ny, colour )\
                -- if colour ~= TRANSPARENT and nx >= 1 and ny >= 1 and nx <= canvasWidth and ny <= canvasHeight then\
                --     canvasBuffer[( ny - 1 ) * canvasWidth + nx] = colour\
                -- end\
            end\
        end\
\
\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Hit tests the canvas' buffer to see if the colour is set (return false if transparent)\
    @param [number] x -- the x coordinate to hit test\
    @param [number] y -- the y coordinate to hit test\
    @return [boolean] didHit -- whether the colour was set/not transparent\
]]\
function Canvas:hitTest( x, y )\
    return self:getPixel( x, y ) ~= 0\
end",
  },
  EventManager = {
    [ "text/lua" ] = "\
class \"EventManager\" {\
\9owner = false;\
\9handles = {};\
\9handlesGlobal = {};\
}\
\
\
--[[\
\9@constructor\
\9@desc Creates an EventManager for the provided owner, with owner reverting to the EventManager instance\
\9@param [class] owner -- the owner of the EventManger (i.e. what self will be on function calls)\
]]\
function EventManager:initialise( owner )\
\9self.owner = owner or self\
\9self.owner = self.owner\
\9-- allow the class to be called as a shorthand for :connect\
\9self.metatable.__call = function(self, _, ...) return self:connect( ... ) end\
\9-- setmetatable( self, self.mt )\
end\
\
--[[\
\9@instance\
\9@desc Subscribes a function to the given event\
\9@param [Event.eventType] eventType -- the name of the event type\
\9@param [EventManager] eventManager -- the handle manager \
\9@param [function] func -- the function called when the event occurs\
\9@param [class] sender -- the value passed as self. defaults to eventManager.owner\
]]\
function EventManager:connect( Event eventType, Function func, Event.phases( Event.phases.BEFORE ) phase, EventManager.allowsNil eventManager, sender )\
\9eventManager = eventManager or self -- TODO: allow self in default values\
\9self:disconnect( eventType, func, phase, eventManager, sender ) -- ensure duplicates won't be made\
\
\9if not self.handles[eventType] then\
\9\9self.handles[eventType] = {}\
\9end\
\
\9table.insert( self.handles[eventType], { func, phase, eventManager, sender or eventManager.owner } )\
end\
\
--[[\
\9@instance\
\9@desc Unsubscribes a function to the given event\
\9@param [Event] eventType -- the name of the event type\
\9@param [function] func -- the function called when the event occurs\
\9@param [class] sender -- the value passed as self. defaults to eventManager.owner\
]]\
function EventManager:disconnect( eventType, func, phase, eventManager, sender )\
\9phase = phase or Event.phases.BEFORE\
\9eventManager = eventManager or self\
\9sender = sender or eventManager.owner\
\
\9if self.handles[eventType] then\
\9\9for i, handle in pairs( self.handles[eventType] ) do\
\9\9\9if handle[1] == func and handle[2] == phase and handle[3] == eventManager and handle[4] == sender then\
\9\9\9\9self.handles[eventType][i] = nil\
\9\9\9end\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Subscribes a function globally to the given event\
\9@param [Event.eventType] eventType -- the name of the event type\
\9@param [function] func -- the function called when the event occurs\
]]\
function EventManager:connectGlobal( eventType, func, phase, sender )\
\9if func and type( func ) == \"function\" then\
\9\9phase = phase or Event.phases.BEFORE\
\9\9sender = sender or self.owner\
\9\9self:disconnectGlobal( eventType, func, phase, sender ) -- ensure duplicates won't be made\
\
\9\9if not self.handlesGlobal[eventType] then\
\9\9\9self.handlesGlobal[eventType] = {}\
\9\9end\
\
\9\9table.insert( self.handlesGlobal[eventType], { func, phase, sender } )\
\9\9self.application.event:connect( eventType, func, phase, self, sender )\
\9else\
\9\9error( \"Attempted to connect non-function to global event: \" .. eventType .. ' for class: ' .. tostring( self.owner or nil ), 0 )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Unsubscribes a function to globally the given event\
\9@param [Event.eventType] eventType -- the name of the event type\
\9@param [function] func -- the function called when the event occurs\
]]\
function EventManager:disconnectGlobal( eventType, func, phase, sender, eventManager )\
\9phase = phase or Event.phases.BEFORE\
\9sender = sender or self.owner\
\9self.application.event:disconnect( eventType, func, phase, self, sender )\
\
\9if self.handlesGlobal[eventType] then\
\9\9for i, handle in pairs( self.handlesGlobal[eventType] ) do\
\9\9\9if handle[1] == func and handle[2] == phase and handle[3] == eventManager and handle[4] == sender then\
\9\9\9\9self.handlesGlobal[eventType][i] = nil\
\9\9\9end\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Unsubscribes all global events\
]]\
function EventManager:disconnectAllGlobals()\
\9for eventType, v in pairs( self.handlesGlobal ) do\
\9\9for i, handle in pairs( v ) do\
\9\9\9self.application.event:disconnect( eventType, handle[1], handle[2], handle[3], self)\
\9\9\9v[i] = nil\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the EventManager has any handles for the given type\
\9@param [Event.eventType] eventType -- the name of the even type\
\9@return [boolean] hasConnections\
]]\
function EventManager:hasConnections( eventType )\
\9return self.handles[eventType] and #self.handles[eventType] >= 1\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the EventManager has any global handles for the given type\
\9@param [Event.eventType] eventType -- the name of the even type\
\9@return [boolean] hasConnections\
]]\
function EventManager:hasConnectionsGlobal( eventType )\
\9return self.handlesGlobal[eventType] and #self.handlesGlobal[eventType] >= 1\
end\
\
--[[\
\9@instance\
\9@desc Perfoms the appropriate handles for the given event\
\9@param [Event] event -- the event to handle\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function EventManager:handleEvent( event )\
\9if self:handleEventPhase( event, Event.phases.BEFORE ) then\
\9\9return true\
\9end\
\
\9if self:handleEventPhase( event, Event.phases.AFTER ) then\
\9\9return true\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Performs the handles for a specific phase\
\9@param [Event] event -- the event to handle\
\9@param [EventManager.phase] phase -- the phase desired\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function EventManager:handleEventPhase( event, phase )\
\9local handles = self.handles[event.class]\
\9if handles then\
\9\9for i, handle in pairs( handles ) do\
\9\9\9if handle and phase == handle[2] then\
\9\9\9\9-- handle[1] is the handle function\
\9\9\9\9-- handle[2] is the phase\
\9\9\9\9-- handle[3] is the event manager\
\9\9\9\9-- handle[4] is the sender\
\9\9\9\9local response = handle[1]( handle[4], event, handle[2] ) -- if response is true stop propagation, if false continue\
\9\9\9\9-- TODO: maybe enforce returning boolean for event handler functions\
\9\9\9\9-- if response ~= true and response ~= false then\
\9\9\9\9-- \9error( \"Error handler for event '\" .. eventType .. \"' of instance '\" .. tostring( handle[4] ) .. \"' did not return boolean. If the event should not be sent to anything else (i.e. stop propagation) return true, otherwise, if it can continue being passed around, return false.\", 0 )\
\9\9\9\9-- end\
\
\9\9\9\9if response then\
\9\9\9\9\9return true\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
end\
\
function EventManager:dispose()\
\9self:disconnectAllGlobals()\
end",
  },
  FlowContainer = {
    [ "text/lua" ] = "\
local TOP_MARGIN = 5\
local BOTTOM_MARGIN = 5\
local SIDE_MARGIN = 6\
\
class \"FlowContainer\" extends \"Container\" {\
    \
    needsLayoutUpdate = false;\
    expandVertically = true;\
\
}\
\
function FlowContainer:initialise( ... )\
    self:super( ... )\
    self:event( ChildAddedInterfaceEvent, self.onChildAdded )\
    self:event( ChildRemovedInterfaceEvent, self.onChildRemoved )\
    self:event( ReadyInterfaceEvent, self.onReady )\
end\
\
function FlowContainer:initialiseCanvas()\
    self:super()\
\
    self.theme:connect( self.canvas, \"fillColour\" )\
end\
\
function FlowContainer:updateWidth( width )\
    self.needsLayoutUpdate = true\
end\
\
function FlowContainer:updateHeight( height )\
    -- self.needsLayoutUpdate = true\
end\
\
function FlowContainer:onReady( Event event, Event.phases phase )\
    self:updateLayout( true )\
end\
\
function FlowContainer:update( deltaTime )\
    self:super( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function FlowContainer:onChildAdded( Event event, Event.phases phase )\
    if event.childView:typeOf( IFlowItem ) then\
        self.needsLayoutUpdate = true\
    end\
end\
\
function FlowContainer:onChildRemoved( Event event, Event.phases phase )\
    self.needsLayoutUpdate = true\
end\
\
function FlowContainer:updateLayout( dontAnimate )\
    local width, height = self.width, self.height\
\
    local children = {}\
    for i, childView in ipairs( self.children ) do\
        if childView:typeOf( IFlowItem ) then\
            table.insert( children, childView )\
        end\
    end\
\
    local time, easing = 0.5, Animation.easings.SINE_IN_OUT\
\
    local nChildren = #children\
    local totalWidth = 0\
    local minWidths = {}\
    for i, childView in ipairs( children ) do\
        totalWidth = totalWidth + childView.idealWidth\
        minWidths[i] = childView.minWidth or 1\
    end\
\
    local averageWidth = math.min( math.floor( totalWidth / nChildren + 0.5 ), width - 2 * SIDE_MARGIN )\
    local maxItemsPerRow = math.floor( totalWidth / averageWidth + 0.5 )\
    local idealWidth = math.floor( totalWidth / maxItemsPerRow )\
\
    local y = TOP_MARGIN + 1\
\
    local _i = 0\
    for i = 1, nChildren do\
        if i > _i then\
            local rowWidth = 2 * SIDE_MARGIN\
            local x = SIDE_MARGIN + 1\
            local numberOfItems = 1\
\
            local totalMinWidths = 0\
            local spareWidth = width - rowWidth\
            for n = 1, math.min( maxItemsPerRow, nChildren - i + 1 ) do\
                local minWidth = minWidths[i + n - 1]\
                totalMinWidths = totalMinWidths + minWidth\
                if totalMinWidths + rowWidth > width then\
                    if n == 1 then\
                        spareWidth = spareWidth - minWidth\
                    end\
                    break\
                end\
                numberOfItems = n\
                spareWidth = spareWidth - minWidth\
            end\
\
            local itemWidth = spareWidth / numberOfItems\
            _i = _i + numberOfItems\
\
            local height = 1\
            for n = i, _i do\
                local childView = children[n]\
                local width = minWidths[n] + ( n == i and math.ceil or math.floor)(itemWidth)\
                local idealHeight = childView.idealHeight\
                local maxWidth = childView.maxWidth\
                width = (maxWidth and math.min( width, maxWidth ) or width)\
                if dontAnimate then\
                    childView.x = x\
                    childView.y = y\
                    childView.width = width\
                    childView.height = idealHeight\
                else\
                    childView:animateX( x, time, nil, easing )\
                    childView:animateY( y, time, nil, easing )\
                    childView:animateWidth( width, time, nil, easing )\
                    childView:animateHeight( idealHeight, time, nil, easing )\
                end\
                x = x + width\
                height = math.max( idealHeight, height )\
            end\
            y = y + height\
        end\
    end\
\
    self:animateHeight( y + BOTTOM_MARGIN, time, nil, easing )\
\
    self.needsLayoutUpdate = false\
end",
  },
  String = {
    [ "text/lua" ] = "\
class \"String\" {\
\9str = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a string object\
\9@param [string] str -- the string to use\
]]\
function String:initialise( str )\
\9self.str = str\
end\
\
--[[\
\9@instance\
\9@desc Splits a string in to an array with a delimeter\
\9@param [string] delimeter -- the delimeter\
\9@return [table] components -- the split string components\
]]\
function String:split( delimeter )\
\9local components = {}\
\9local t = string.format( \"([^%s]+)\", delimeter )\
\9self.str:gsub( t, function( t )\
\9\9components[#components+1] = t\
\9end )\
\9return components\
end\
\
--[[\
\9@instance\
\9@desc The file extension of the string\
\9@return [table] components -- a table with the directory path, file name and then extension\
]]\
function String:pathComponents()\
\9return string.match( self.str, \"(.-)([^/]-([^%.]+))$\" )\
end\
\
-- TODO: more string methods",
  },
  InterfaceOutlet = {
    [ "text/lua" ] = "\
-- This class allows you to connect a container's view to a property in the class definition and in code.\
-- It keeps track of the child view and changes the reference when removed/added\
-- Simply connect like so:\
-- {\
-- \9...\
-- \9myButton = InterfaceOutlet( \"ButtonUniqueIdentifier\" );\9\
-- \9...\
-- }\
\
-- TODO: update interface outlets when the .identifer of a view is changed\
\
class \"InterfaceOutlet\" {\
\9viewIdentifier = false;\
\9key = false;\
\9container = false;\
\9views = false;\
\9trackAll = false; -- whether the outlet keeps track of all views with the given identifier, or just one\
}\
\
--[[\
\9@constructor\
\9@desc Initialises the interface outlet\
\9@param [string] viewIdentifier -- the identifier of the desire view\
\9@param [boolean] trackAll -- whether to track all view with the identifier, or just one\
\9@param [Container] container -- the container that owns the outlet\
]]\
 -- if you change this you need to change it in class.lua uniqueTable() too\
function InterfaceOutlet:initialise( viewIdentifier, trackAll, key, container )\
\9trackAll = trackAll or false\
\9self.viewIdentifier = viewIdentifier or false\
\9self.trackAll = trackAll or false\
\9self.key = key or false\
\9self.container = container or false\
\9\
\9if trackAll then\
\9\9self.views = container and container:findChildren( self.viewIdentifier ) or false\
\9else\
\9\9self.views = container and container:findChild( self.viewIdentifier ) or false\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Sets the current views the outlet points to\
\9@param [table/View] views -- the view or views\
]]\
function InterfaceOutlet.views:set( views )\
\9local oldViews = self.views\
\9self.views = views\
\
\9local container = self.container\
\9if container then\
\9\9local event = container.event\
\9\9container[self.key] = views\
\9\9if event then event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, views, oldViews ) ) end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when a child was added to the container. If it's our identifier, track it (if we don't already have a view or we're tracking all)\
\9@param [View] childView -- the view that was just added\
\9@param [boolean] lookInChildren -- whether the\
\9@return [boolean] wasFound -- whether the view was found, only true if trackAll is false\
]]\
function InterfaceOutlet:childAdded( childView, lookInChildren )\
\9local viewIdentifier = self.viewIdentifier\
\9local trackAll = self.trackAll\
\9local didAdd = false\
\9local container, views = self.container, self.views\
\
\9local function search( view )\
\9\9if view.identifier == viewIdentifier then\
\9\9\9if trackAll then\
\9\9\9\9didAdd = true\
\9\9\9\9table.insert( views, view )\
\9\9\9elseif not views then\
\9\9\9\9self.views = view\
\9\9\9\9container.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, view, views ) )\
\9\9\9\9return true\
\9\9\9end\
\9\9end\
\9\9if lookInChildren and view:typeOf( Container ) then\
\9\9\9for i, v in ipairs( view.children ) do\
\9\9\9\9if search( v ) then return true end\
\9\9\9end\
\9\9end\
\9end\
\
\9local found = search( childView ) or false\
\
\9if trackAll and didAdd then\
\9\9container.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, views, views ) )\
\9end\
\
\9return found\
end\
\
--[[\
\9@instance\
\9@desc Called when a child was removed from the container. If it's our identifier stop tracking it.\
\9@param [View] childView -- the view that was just added\
]]\
function InterfaceOutlet:childRemoved( childView )\
\9if childView.identifier == self.viewIdentifier then\
\9\9local views = self.views\
\9\9if self.trackAll then\
\9\9\9local didRemove = false\
\9\9\9for i, trackedView in ipairs( views ) do\
\9\9\9\9if trackedView == childView then\
\9\9\9\9\9views[i] = nil\
\9\9\9\9\9didRemove = true\
\9\9\9\9end\
\9\9\9end\
\9\9\9self.container.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, views, views ) )\
\9\9elseif views then\
\9\9\9views = nil\
\9\9\9self.container.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, nil, views ) )\
\9\9end\
\9end\
end",
  },
  ContainerEventManager = {
    [ "text/lua" ] = "\
class \"ContainerEventManager\" extends \"EventManager\" {}\
\
--[[\
\9@instance\
\9@desc Perfoms the appropriate handles for the given event and then trickles them down through the owner's children\
\9@param [Event] event -- the event to handle\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function ContainerEventManager:handleEvent( event )\
\9local sender = event.sender\
\9local isSentToSender = not sender or ( self == sender and event.isSentToSender )\
\9if isSentToSender and self:handleEventPhase( event, Event.phases.BEFORE ) then\
\9\9return true\
\9end\
\
\9if event.isSentToChildren then\
\9\9local owner = self.owner\
\9\9local children = owner.children\
\9\9for i = #children, 1, -1 do\
\9\9\9local childView = children[i]\
\9\9\9if childView:typeOf( Container ) or childView.event:hasConnections( event.eventType ) then\
\9\9\9\9if childView:hitTestEvent( event, owner ) then\
\9\9\9\9\9event:makeRelative( childView )\
\9\9\9\9\9if childView.event:handleEvent( event ) then\
\9\9\9\9\9\9return true\
\9\9\9\9\9end\
\9\9\9\9\9event:makeRelative( owner )\
\9\9\9\9else\
\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9if isSentToSender and self:handleEventPhase( event, Event.phases.AFTER ) then\
\9\9return true\
\9end\
end",
  },
  ChildAddedInterfaceEvent = {
    [ "text/lua" ] = "\
class \"ChildAddedInterfaceEvent\" extends \"InterfaceEvent\" {\
    static = {\
        eventType = \"interface_child_added\";\
    };\
\9childView = false; -- the added child\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a child added event from the arguments\
\9@param [View] childView -- the added child\
]]\
function ChildAddedInterfaceEvent:initialise( childView )\
\9self.childView = childView\
end",
  },
  Text = {
    [ "text/lua" ] = "\
class \"Text\" extends \"GraphicsObject\" {\
\9font = false;\
\9text = false;\
\9textColour = false;\
\9alignment = false;\
}\
\
function Text:initialise( x, y, width, height, text, alignment, font )\
\9self:super( x, y, width, height )\
\9self.text = text or \"\"\
\9self.font = font or Font.systemFont\
\9self.alignment = alignment or Font.alignments.LEFT\
end\
\
--[[\
\9@instance\
\9@desc Sets the font of the text object\
\9@param [number] font -- the font of the text object\
]]\
function Text.font:set( font )\
\9self.hasChanged = true\
\9self.font = font\
end\
\
--[[\
\9@instance\
\9@desc Sets the text of the text object\
\9@param [number] text -- the text of the text object\
]]\
function Text.text:set( text )\
\9self.hasChanged = true\
\9self.text = text or \"\"\
end\
\
--[[\
\9@instance\
\9@desc Draws a the text to the canvas\
\9@param [Canvas] canvas -- the canvas to draw to\
\9@return self\
]]\
function Text:drawTo( canvas, isShadow )\
\9if self.isVisible and ( not isShadow or ( isShadow and self.drawsShadow ) ) then\
\9\9local font = self.font\
\9\9local width = self.width\
\9\9local text = self.text\
\9\9local hasEllipsis = false\
\
\9\9local fontWidth = font:getWidth( text )\
\9\9while fontWidth > width and #text > 1 do\
\9\9\9text = text:sub( 1, #text - 1 )\
\9\9\9fontWidth = font:getWidth( text .. \"...\" )\
\9\9\9hasEllipsis = true\
\9\9end\
\
\9\9if hasEllipsis then\
\9\9\9text = text .. \"...\"\
\9\9end\
\
\9\9local x = 1\
\9\9local alignment = self.alignment\
\9\9if alignment == Font.alignments.CENTRE then\
\9\9\9x = 1 + math.floor( (width - fontWidth ) / 2 )\
\9\9elseif alignment == Font.alignments.RIGHT then\
\9\9\9x = width - fontWidth + 1\
\9\9end\
        font:render( canvas, text, self.x + x - 1, self.y, width, self.height, self.textColour )\
\9end\
\9return self\
end",
  },
}}
local args = { ... }
if #args == 1 and args[1] == "contents" then
    return files
end

_G.__resourceTables = _G.__resourceTables or {}
_G.__resourceTables[#_G.__resourceTables + 1] = files
local loaded = {}
local classes = files["classes"]
local loadClass


local f, err = loadstring( classes["class"]["text/lua"], "class.lua" )
if err then error( err, 0 ) end
local ok, err = pcall( f )
if err then error( err, 0 ) end

table.insert( class.tables, classes )

for name, contents in pairs( classes ) do
    if name ~= "class" then
        class.get( name )
    end
end

