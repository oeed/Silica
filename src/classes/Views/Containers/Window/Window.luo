
local RESIZE_MARGIN_X, RESIZE_MARGIN_Y = 3, 4

class Window extends Container 

	property container
	property closeButton
	property maximiseButton
	property Boolean isEnabled = false

	property dragX
	property dragY
	property Boolean isDragging = false
	property Boolean isResizingX = false
	property Boolean isResizingY = false

	property Number minWidth = 60
	property Number minHeight = 40
	property Number maxWidth = math.huge
	property Number maxHeight = math.huge

}

--[[
	@constructor
	@desc Initialise a application container instance
	@param [table] properties -- the properties for the view
]]
	function initialise( ... )
		super( ... )
		self.closeButton = self:insert( CloseWindowButton( { x = 2, y = 1, window = self } ))
		self.maximiseButton = self:insert( MaximiseWindowButton( { x = 11, y = 1, window = self } ))

		self:loadInterface()
		
		self:event( MouseDownEvent, self.onMouseDownBefore, Event.phases.BEFORE )
		self:event( MouseDownEvent, self.onMouseDownAfter, Event.phases.AFTER )
		self.event:connectGlobal( MouseDragEvent, self.onGlobalMouseDrag )
		self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )
		self:event( LoadedInterfaceEvent, self.onInterfaceLoaded )
	end

	function onDraw()
		local width, height, theme, canvas = self.width - RESIZE_MARGIN_X, self.height - RESIZE_MARGIN_Y, self.theme, self.canvas

		local barHeight = 10
		local topCornerRadius, bottomCornerRadius = theme:value( "topCornerRadius" ), theme:value( "bottomCornerRadius" )
		local barRoundedRectangle = RoundedRectangleMask( 1, 1, width, barHeight, topCornerRadius, topCornerRadius, 0, 0 )
		canvas:fill( theme:value( "barFillColour" ), barRoundedRectangle )
		canvas:outline( theme:value( "separatorColour" ), barRoundedRectangle, 0, 0, 0, theme:value( "separatorThickness" ) )

		local contentMask = RoundedRectangleMask( 1, 1 + barHeight, width, height - barHeight, 0, 0, bottomCornerRadius, bottomCornerRadius )
		canvas:fill(  theme:value( "fillColour" ), contentMask )
		local combinedMask = contentMask:add( barRoundedRectangle )
		canvas:outline(	 theme:value( "outlineColour" ), combinedMask, theme:value( "outlineThickness" ) )

		self.shadowSize = theme:value( "shadowSize" )
		return combinedMask
	end

	--[[
		@desc Loads the interface specified by the self.interfaceName interface name
	]]
	function loadInterface()
		local interfaceName = self.interfaceName
		if interfaceName then
			local interface = Interface( interfaceName, WindowContainer )
			local container = interface.container
			self.container = self:insert( container )
			interface:ready()
		end
	end

	set height( height )
		super( math.max( math.min( height, self.maxHeight ), self.minHeight ) )
	end

	set width( width )
		super( math.max( math.min( width, self.maxWidth ), self.minWidth ) )
	end

	function onInterfaceLoaded( LoadedInterfaceEvent event, Event.phases phase )
		local currentContainer = self.container
		for i, childView in ipairs( self.children ) do
			if childView:typeOf( WindowContainer ) then
				if childView ~= currentContainer then
					self.container = childView
				end
				return
			end
		end
		self.container = self:insert( WindowContainer( { x = x, y = y, width = width, height = height } ) )
	end

	function updateThemeStyle()
		self.theme.style = self.isEnabled and "default" or "disabled"
	end

	set isEnabled( isEnabled )
		super( isEnabled )
		self:updateThemeStyle()
	end

	--[[
		@desc Centres the window relative to it's parent (which should be the application container)
	]]
	function centre()
		local parent = self.parent
		if parent then
			self.x = math.ceil( ( parent.width - self.width + RESIZE_MARGIN_X ) / 2 )
			self.y = math.ceil( ( parent.height - self.height + RESIZE_MARGIN_Y ) / 2 )
		end
	end

	Window:alias( Window.centre, "center" )

	--[[
		@desc Focus on the window, bringing it to the front and enabling controls whilst unfocusing other windows
	]]
	function focus()
		if not self.isEnabled then
			self.application:unfocusAll( Window )
			self.isEnabled = true
			self.parent:sendToFront( self )
			for i, sibling in ipairs( self:siblingsOfType( Window ) ) do
				sibling:unfocus()
			end
		end
	end

	--[[
		@desc Unfocus on the window, disabling controls
	]]
	function unfocus()
		self.isEnabled = false
	end

	--[[
		@desc Fired when the mouse is pushed on the window bar before children have recieved the event. Makes the window front most and active
		@param [MouseDownEvent] event -- the mouse down event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onMouseDownBefore( MouseDownEvent event, Event.phases phase )
		self:focus()
	end

	--[[
		@desc Fired when the mouse is pushed on the window bar after children have recieved the event. Starts dragging.
		@param [MouseDownEvent] event -- the mouse down event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onMouseDownAfter( MouseDownEvent event, Event.phases phase )
		if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then
			x = event.x
			y = event.y
			local width = self.width
			local height = self.height
			local isResizingX = x >= width - 2 * RESIZE_MARGIN_X
			local isResizingY = y >= height - 2 * RESIZE_MARGIN_Y
			log(isResizingX)
			self.isResizingX = isResizingX
			self.isResizingY = isResizingY
			self.isDragging = not ( isResizingX or isResizingY )
			self.dragX = isResizingX and width - x or x
			self.dragY = isResizingY and height - y or y
		end
		return true
	end

	--[[
		@desc Fired when the mouse is dragged anywhere on screen. Moves the window if dragging
		@param [Event] event -- the mouse drag event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onGlobalMouseDrag( MouseDragEvent event, Event.phases phase )
		if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then
			local preventPropagation = false
			if self.isDragging then
				self.x = event.x - self.dragX + 1
				self.y = event.y - self.dragY + 1
				preventPropagation = true
			else
				if self.isResizingX then
					self.width = event.x - self.x + self.dragX + 1
					preventPropagation = true
				end
				if self.isResizingY then
					self.height = event.y - self.y + self.dragY + 1
					preventPropagation = true
				end
			end
			return preventPropagation
		end
	end

	--[[
		@desc Fired when the mouse is released anywhere on screen. Stops dragging
		@param [Event] event -- the mouse up event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onGlobalMouseUp( MouseUpEvent event, Event.phases phase )
		if (self.isDragging or self.isResizingX or self.isResizingY ) and event.mouseButton == MouseEvent.mouseButtons.LEFT then
			self.dragX = false
			self.dragY = false
			self.isDragging = false
			self.isResizingX = false
			self.isResizingY = false
			return true
		end
	end

	--[[
		@desc Closes the window, removing it from the screen
	]]
	function close()
		self.isVisible = false
		self.parent:remove( self )
	end

end