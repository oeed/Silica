local SHADOW_RATIO = Canvas.shadows.SHADOW_RATIO

class Button extends View 

	property Number height = 16
	property Number width = 36
	property String text = ""

	property Boolean isPressed = false
	property Boolean isFocused = false
	property Boolean isAutosized = true
	property Boolean isFocusDismissable = true
	property Boolean needsAutosize = true
	property Boolean isCanvasHitTested = true

	property Cursor allowsNil cursor = ClickableCursor.static

	--[[
		@desc Creates a button object and connects the event handlers
	]]
	function initialise( ... )
		super( ... )

		self:event( MouseDownEvent, self.onMouseDown )
		self:event( KeyDownEvent, self.onKeyDown )
		self:event( KeyUpEvent, self.onKeyUp )
		self.event:connectGlobal( MouseUpEvent, self.onGlobalMouseUp, Event.phases.BEFORE )
	end

	function onDraw()
		local width, height, theme, canvas, isPressed = self.width, self.height, self.theme, self.canvas, self.isPressed

		-- get all the shadow size details so we can adjust the compression as needed
		local defaultShadowSize = theme:value( "shadowSize", "default" )
		local shadowPressedSize = theme:value( "shadowSize", "pressed" )
		local shadowSize = theme:value( "shadowSize" )
		local shadowOffset = defaultShadowSize - shadowSize
		local shadowPressedOffset = defaultShadowSize - shadowPressedSize
		local shadowX = math.floor( shadowOffset * SHADOW_RATIO + 0.5 )

		-- background shape
		local roundedRectangle = RoundedRectangleMask( shadowX + 1, shadowOffset + 1, width - math.floor( shadowPressedOffset * SHADOW_RATIO + 0.5 ), height - shadowPressedOffset, theme:value( "cornerRadius" ) )
		canvas:fill( theme:value( "fillColour" ), roundedRectangle )
		canvas:outline( theme:value( "outlineColour" ), roundedRectangle, theme:value( "outlineThickness" ) )

		local leftMargin, rightMargin, topMargin, bottomMargin = theme:value( "leftMargin" ), theme:value( "rightMargin" ), theme:value( "topMargin" ), theme:value( "bottomMargin" )
		-- text
		canvas:fill( theme:value( "textColour" ),  TextMask( leftMargin + shadowX + 1, topMargin + 1 + shadowOffset, width - leftMargin - rightMargin, height - topMargin - bottomMargin, self.text, theme:value( "font" ) ) )

		self.shadowSize = shadowSize
	end

	set text( text )
		self.text = text
		self.needsDraw = true
		self.needsAutosize = true
	end

	function update( deltaTime )
		super( deltaTime )
		if self.needsAutosize then
			self:autosize()
		end
	end

	--[[
		@desc Automatically resizes the button, regardless of isAutosized value, to fit the text
	]]
	function autosize()
		if self.isAutosized then
			local text, theme = self.text, self.theme
			local font = theme:value( "font" )
			local defaultShadowSize = theme:value( "shadowSize", "default" )
			local shadowSize = theme:value( "shadowSize", "pressed" )
			local shadowOffset = defaultShadowSize - shadowSize
			local shadowX = math.floor( shadowOffset * SHADOW_RATIO + 0.5 )
			self.width = font:getWidth( self.text ) + theme:value( "leftMargin" ) + theme:value( "rightMargin" ) + shadowX
			self.height = font.height + theme:value( "topMargin" ) + theme:value( "bottomMargin" ) + shadowOffset
		end
		self.needsAutosize = false
	end

	function updateThemeStyle()
		self.theme.style = self.isEnabled and ( self.isPressed and "pressed" or ( self.isFocused and "focused" or "default" ) ) or "disabled"
	end

	set isEnabled( isEnabled )
		self.isEnabled = isEnabled
		self.cursor = isEnabled and ClickableCursor.static or Cursor.static
		self:updateThemeStyle()
	end

	set isPressed( isPressed )
		self.isPressed = isPressed
		self:updateThemeStyle()
	end

	set isFocused( isFocused )
		self.isFocused = isFocused
		self:updateThemeStyle()
	end

	--[[
		@desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.
		@param [Event] event -- the mouse up event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onGlobalMouseUp( MouseUpEvent event, Event.phases phase )
		if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then
			self.isPressed = false
			if self.isEnabled and self:hitTestEvent( event ) then
				self.event:handleEvent( ActionInterfaceEvent( self ) )
				local result = self.event:handleEvent( event )
				return result == nil and true or result
			end
		end
	end

	--[[
		@desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.
		@param [MouseDownEvent] event -- the mouse down event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onMouseDown( MouseDownEvent event, Event.phases phase )
		if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then
			self.isPressed = true
		end
		return true
	end

	--[[
		@desc Fired when a key is pressed down. Presses the button down if it isin focus and it was the enter key.
		@param [KeyDownEvent] event -- the key down event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onKeyDown( KeyDownEvent event, Event.phases phase )
		if self.isEnabled and self.isFocused and event.keyCode == keys.enter then
			self.isPressed = true
			return true
		end
	end

	--[[
		@desc Fired when a key is pressed released. Fires the button action if the button is pressed, in focus and it was the enter key.
		@param [KeyUpEvent] event -- the key down event
		@return [boolean] preventPropagation -- prevent anyone else using the event
	]]
	function onKeyUp( KeyUpEvent event, Event.phases phase )
		if self.isEnabled and self.isPressed and self.isFocused and event.keyCode == keys.enter then
			self.isPressed = false
			self.event:handleEvent( ActionInterfaceEvent( self ) )
			return true
		end
	end

end