local files = {interfaces = {["alert.sinterface"] = "<WindowContainer>\
\
\9<Label x=6  width=\"100%-6\" y=5 text=\"Self-destruct?\" />\
\9<Button identifier=okayButton right=\"100%-6\" bottom=\"100%-5\" text=Okay />\
\9\
</WindowContainer>",},["loadfirst.scfg"] = "class.lua\
Graphics.lua\
Application.lua\
InterfaceOutlet.lua\
Animation.lua\
View.lua",debug = "\
local _log, debug, last, need_ellipsis, count\
\
local Lua_keywords = {}\
Lua_keywords[\"if\"] = true\
Lua_keywords[\"elseif\"] = true\
Lua_keywords[\"else\"] = true\
Lua_keywords[\"while\"] = true\
Lua_keywords[\"for\"] = true\
Lua_keywords[\"repeat\"] = true\
Lua_keywords[\"until\"] = true\
Lua_keywords[\"do\"] = true\
Lua_keywords[\"then\"] = true\
Lua_keywords[\"function\"] = true\
Lua_keywords[\"return\"] = true\
Lua_keywords[\"break\"] = true\
Lua_keywords[\"end\"] = true\
Lua_keywords[\"local\"] = true\
Lua_keywords[\"not\"] = true\
Lua_keywords[\"true\"] = true\
Lua_keywords[\"false\"] = true\
\
local function _serialize( v, t )\
\9if type( v ) == \"table\" and pcall( function() if type( getmetatable( v ).__tostring ) ~= \"function\" then error \"\" end end ) then\
\9\9return tostring( v )\
\9elseif type( v ) == \"table\" then\
\9\9if not next( v ) then return \"{}\" end\
\9\9if t.serializing[v] then\
\9\9\9return \"recursion\"\
\9\9end\
\9\9if t.serialized[v] then\
\9\9\9return t.serialized[v]\
\9\9end\
\9\9t.serializing[v] = true\
\9\9local d = {}\
\9\9local s = \"{ \"\
\9\9for i, v in ipairs( v ) do\
\9\9\9d[i] = true\
\9\9\9s = s .. _serialize( v, t ) .. \", \"\
\9\9end\
\9\9for k, v in pairs( v ) do\
\9\9\9if not d[k] then\
\9\9\9\9if type( k ) == \"string\" and not k:find \"[^%w_]\" and not Lua_keywords[k] then\
\9\9\9\9\9s = s .. k .. \" = \" .. _serialize( v, t ) .. \", \"\
\9\9\9\9else\
\9\9\9\9\9s = s .. \"[\" .. _serialize( k, t ) .. \"] = \" .. _serialize( v, t ) .. \", \"\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9t.serializing[v] = false\
\9\9return s:sub( 1, -3 ) .. \" }\"\
\9elseif type( v ) == \"function\" and not tostring( v ):find \"^function: \" then -- lua functions, tostring( tostring ) = \"tostring\", now \"function: tostring\"\
\9\9return \"function: \" .. tostring( v )\
\9elseif type( v ) == \"function\" or type( v ) == \"thread\" then\
\9\9return tostring( v )\
\9elseif type( v ) == \"string\" then\
\9\9return textutils.serialize( v:gsub( \"\\n\", \" \" ) )\
\9else\
\9\9return textutils.serialize( v )\
\9end\
end\
local function timestamp()\
\9local t = tostring( os.clock() )\
\9if #t:match \"%.( %d+ )\" == 1 then\
\9\9return \"[\" .. t .. \"0]: \"\
\9elseif not t:find \"%.\" then\
\9\9return \"[\" .. t .. \".00]: \"\
\9end\
\9return \"[\" .. t .. \"]: \"\
end\
local function writeContent( content, include_time )\
\9if _log then\
\9\9if last == content and debug.no_repeats then\
\9\9\9need_ellipsis = true\
\9\9\9count = ( count or 0 ) + 1\
\9\9\9return\
\9\9else\
\9\9\9if need_ellipsis then\
\9\9\9\9need_ellipsis = false\
\9\9\9\9_log.writeLine( \" ... \" .. count .. \" repeats ...\" )\
\9\9\9end\
\9\9\9count = nil\
\9\9end\
\9\9last = content\
\9\9if include_time then\
\9\9\9content = timestamp() .. content\
\9\9end\
\9\9_log.writeLine( content )\
\9\9_log.flush()\
\9end\
end\
local function _traceback(ignore, level)\
\9level = type( level ) == \"number\" and level\
\9local errorLevel = 3 + ( type(ignore ) == \"number\" and ignore or 0)\
\9local errorDiff = errorLevel\
\9local errorPos, result = nil, {}\
\9repeat\
\9\9errorPos = select(2, pcall(error, \"@\", errorLevel)):match( \"^(.+ ): @$\")\
\9\9if errorPos then\
\9\9\9result[#result + 1] = errorPos\
\9\9\9errorLevel = errorLevel + 1\
\9\9\9if errorLevel - errorDiff == level then return result end\
\9\9end\
\9until not errorPos\
\9return result\
end\
\
debug = {}\
debug.no_repeats = true\
\
function debug.traceback( level, as_string )\
\9local t = _traceback( level or 1 )\
\9for i = #t, 1, -1 do\
\9\9if t[#t] == \"xpcall\" then\
\9\9\9t[#t] = nil\
\9\9\9break\
\9\9end\
\9\9t[#t] = nil\
\9end\
\9if as_string then\
\9\9return table.concat( t, \"\\n in \" )\
\9end\
\9return t\
end\
\
function debug.line( level )\
\9return tonumber( select( 2, pcall( error, \"@\", 2 + ( level or 1 ) ) ):match \"^.+:( %d+ ): @$\" ) or \"unknown\"\
end\
\
function debug.pos( level )\
\9return select( 2, pcall( error, \"@\", 2 + ( level or 1 ) ) ):match \"^( .+ ): @$\" or \"unknown\"\
end\
\
function debug.call( f )\
\9return xpcall( f, function( err )\
\9\9local t = _traceback( 2 )\
\9\9for i = #t, 1, -1 do\
\9\9\9if t[#t] == \"xpcall\" then\
\9\9\9\9t[#t] = nil\
\9\9\9\9break\
\9\9\9end\
\9\9\9t[#t] = nil\
\9\9end\
\9\9return table.concat( { tostring( err ), unpack( t ) }, \"\\n in \" )\
\9end )\
end\
\
function debug.open( file )\
\9if _log then\
\9\9_log.close()\
\9end\
\9_log = fs.open( file, \"w\" )\
end\
\
function debug.close()\
\9if _log then\
\9\9writeContent \" -- Closing log --\"\
\9\9_log.close()\
\9\9_log = nil\
\9end\
end\
\
function debug.log( ... )\
\9local t = { ... }\
\9for i = 1, #t do\
\9\9t[i] = _serialize( t[i], { serializing = {}, serialized = {} } ):gsub( \"\\n\", \" \" )\
\9end\
\9return writeContent( table.concat( t, \", \" ), true )\
end\
\
function debug.logf( fmt, ... )\
\9local t = { ... }\
\9for i = 1, #t do\
\9\9pcall( function()\
\9\9\9t[i] = getmetatable( t[i] ).__tostring( t[i] )\
\9\9end )\
\9end\
\9return writeContent( string.format( fmt, unpack( t ) ):gsub( \"\\n\", \" \" ), true )\
end\
\
function debug.logtraceback( level )\
\9local t = _traceback( level or 1 )\
\9for i = #t, 1, -1 do\
\9\9if t[#t] == \"xpcall\" then\
\9\9\9t[#t] = nil\
\9\9\9break\
\9\9end\
\9\9t[#t] = nil\
\9end\
\9return writeContent( \"Traceback: \" .. table.concat( t, \"  in \" ), true )\
end\
\
function debug.note( message )\
\9return writeContent( \" -- \" .. tostring( message ) .. \" --\" )\
end\
\
function debug.flag( message, level )\
\9return writeContent( \"Info: \" .. ( \"%q\" ):format( tostring( message ) ) .. \"  in \" .. debug.traceback( ( level or 1 ) + 1, true ):gsub( \"\\n\", \" \" ), true )\
end\
\
function debug.warning( message, level )\
\9return writeContent( \"WARNING: \" .. ( \"%q\" ):format( tostring( message ) ) .. \"  in \" .. debug.traceback( ( level or 1 ) + 1, true ):gsub( \"\\n\", \" \" ), true )\
end\
\
function debug.error( message, level )\
\9writeContent( \"FATAL: \" .. ( \"%q\" ):format( tostring( message ) ) .. \"  in \" .. debug.traceback( ( level or 1 ) + 1, true ):gsub( \"\\n\", \" \" ), true )\
\9return error( message, level )\
end\
\
return debug",themes = {["cyan.stheme"] = "<Theme extends=default>\
\9<Window>\
\9\9<topCornerRadius type=\"number\" default=\"4\" />\
\9\9<bottomCornerRadius type=\"number\" default=\"2\" />\
\9\9<barColour type=\"Graphics.colours\" default=\"CYAN\" disabled=\"LIGHT_GREY\" />\
\9\9<separatorColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" disabled=\"WHITE\" />\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"GREY\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" />\
\9</Window>\
\9\
\9<CloseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"CYAN\" pressed=\"RED\" disabled=\"TRANSPARENT\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"WHITE\" disabled=\"GREY\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</CloseWindowButton>\
\9\
\9<MinimiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"CYAN\" pressed=\"ORANGE\" disabled=\"TRANSPARENT\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"WHITE\" disabled=\"GREY\"/>\
\9\9<cornerRadius type=\"number\" default=\"0\" />\
\9</MinimiseWindowButton>\
\9\
\9<MaximiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"CYAN\" pressed=\"LIME\" disabled=\"TRANSPARENT\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"WHITE\" disabled=\"GREY\"/>\
\9\9<cornerRadius type=\"number\" default=\"0\" />\
\9</MaximiseWindowButton>\
</Theme>",["default.stheme"] = "<Theme>\
\9\
\9<Button>\
\9\9<cornerRadius type=\"number\" default=\"8\" />\
\9\9<leftMargin type=\"number\" default=\"7\" />\
\9\9<rightMargin type=\"number\" default=\"7\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"BLUE\" focused=\"BLUE\" disabled=\"WHITE\"/>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" pressed=\"WHITE\" focused=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" focused=\"TRANSPARENT\" disabled=\"LIGHT_GREY\" pressed=\"TRANSPARENT\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" disabled=\"TRANSPARENT\"/>\
\9</Button>\
\
\9<SegmentButton>\
\9\9<centerMargin type=\"number\" default=\"4\" />\
\9\9<separatorDotColour type=\"Graphics.colours\" default=\"LIGHT_GREY\"/>\
\9\9<separatorFillColour type=\"Graphics.colours\" default=\"WHITE\"/>\
\9\9<separatorOutlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\"/>\
\9</SegmentButton>\
\
\9<Menu>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" />\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" />\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" />\
\9</Menu>\
\9\
\9<MenuButton>\
\9\9<arrowColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\"/>\
\9\9<rightMargin type=\"number\" default=\"15\" />\
\9</MenuButton>\
\9\
\9<MenuItem>\
\9\9<fillColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"BLUE\" disabled=\"TRANSPARENT\"/>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" pressed=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9\9<shortcutColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\"/>\
\9</MenuItem>\
\
\9<MenuBar>\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" disabled=\"LIGHT_GREY\" />\
\9\9<separatorColour type=\"Graphics.colours\" default=\"GREY\" disabled=\"LIGHT_GREY\" />\
\9</MenuBar>\
\9\
\9<MenuBarItem>\
\9\9<fillColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"BLUE\" disabled=\"TRANSPARENT\"/>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" pressed=\"WHITE\" disabled=\"LIGHT_GREY\"/>\
\9</MenuBarItem>\
\
\9<Radio>\
\9\9<cornerRadius type=\"number\" default=\"4\" pressed=\"4\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"LIGHT_BLUE\" checked=\"BLUE\" disabledChecked=\"GREY\" disabled=\"WHITE\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" pressed=\"BLUE\" checked=\"TRANSPARENT\" disabledChecked=\"TRANSPARENT\" disabled=\"LIGHT_GREY\"/>\
\9</Radio>\
\
\9<Checkbox>\
\9\9<cornerRadius type=\"number\" default=\"2\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"LIGHT_BLUE\" checked=\"BLUE\" disabledChecked=\"GREY\" disabled=\"WHITE\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" pressed=\"BLUE\" checked=\"TRANSPARENT\" disabledChecked=\"TRANSPARENT\" disabled=\"LIGHT_GREY\"/>\
\9\9<checkColour type=\"Graphics.colours\" default=\"TRANSPARENT\" checked=\"WHITE\" disabledChecked=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9</Checkbox>\
\
\9<ProgressBar>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" disabled=\"WHITE\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" disabled=\"LIGHT_GREY\"/>\
\9\9<barColour type=\"Graphics.colours\" default=\"BLUE\" disabled=\"GREY\"/>\
\9\9<stripeColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" disabled=\"LIGHT_GREY\"/>\
\9\9<barOutlineColour type=\"Graphics.colours\" default=\"BLUE\" disabled=\"GREY\"/>\
\9</ProgressBar>\
\
\9<Window>\
\9\9<topCornerRadius type=\"number\" default=\"4\" />\
\9\9<bottomCornerRadius type=\"number\" default=\"2\" />\
\9\9<barColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" disabled=\"LIGHT_GREY\" />\
\9\9<separatorColour type=\"Graphics.colours\" default=\"GREY\" disabled=\"LIGHT_GREY\" />\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"GREY\"/>\
\9\9<shadowColour type=\"Graphics.colours\" default=\"GREY\" />\
\9</Window>\
\9\
\9<CloseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"RED\" pressed=\"RED\" disabled=\"TRANSPARENT\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"GREY\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</CloseWindowButton>\
\9\
\9<MinimiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"ORANGE\" pressed=\"ORANGE\" disabled=\"TRANSPARENT\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"GREY\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</MinimiseWindowButton>\
\9\
\9<MaximiseWindowButton>\
\9\9<fillColour type=\"Graphics.colours\" default=\"LIME\" pressed=\"LIME\" disabled=\"TRANSPARENT\"/>\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"GREY\"/>\
\9\9<symbolColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"WHITE\" disabled=\"TRANSPARENT\"/>\
\9\9<cornerRadius type=\"number\" default=\"4\" />\
\9</MaximiseWindowButton>\
\
\9<Scrollbar>\
\9\9<fillColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" />\
\9\9<scrollerColour type=\"Graphics.colours\" default=\"WHITE\" pressed=\"BLUE\" disabled=\"WHITE\" />\
\9\9<outlineColour type=\"Graphics.colours\" default=\"TRANSPARENT\" pressed=\"TRANSPARENT\" disabled=\"TRANSPARENT\" />\
\9\9<grabberColour type=\"Graphics.colours\" default=\"GREY\" pressed=\"WHITE\" disabled=\"LIGHT_GREY\" />\
\9\9<cornerRadius type=\"number\" default=\"2\" />\
\9</Scrollbar>\
\
\9<Label>\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"LIGHT_GREY\"/>\
\9\9<fillColour type=\"Graphics.colours\" default=\"TRANSPARENT\" disabled=\"TRANSPARENT\"/>\
\9</Label>\
\
\9<TextBox>\
\9\9<cornerRadius type=\"number\" default=\"8\" />\
\9\9<leftMargin type=\"number\" default=\"7\" />\
\9\9<rightMargin type=\"number\" default=\"7\" />\
\9\9<fillColour type=\"Graphics.colours\" default=\"WHITE\" disabled=\"WHITE\"/>\
\9\9<selectionColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\" />\
\9\9<textColour type=\"Graphics.colours\" default=\"BLACK\" disabled=\"LIGHT_GREY\"/>\
\9\9<cursorColour type=\"Graphics.colours\" default=\"BLACK\" />\
\9\9<outlineColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" focused=\"BLUE\" pressed=\"BLUE\" />\
\9\9<placeholderColour type=\"Graphics.colours\" default=\"LIGHT_GREY\" />\
\9</TextBox>\
\
\9<ApplicationContainer>\
\9\9<fillColour type=\"Graphics.colours\" default=\"LIGHT_BLUE\"/>\
\9</ApplicationContainer>\
\
</Theme>",},classes = {["Window.lua"] = "\
class \"Window\" extends \"Container\" {\
\9-- separatorObject = nil;\9\
\9-- shadowObject = nil;\
\9-- barObject = nil;\9\
\9barHeight = 7;\
\
\9container = false;\
    closeButton = false;\
    minimiseButton = false;\
    maximiseButton = false;\
    isEnabled = false;\
\
\9dragX = false;\
\9dragY = false;\
    isDragging = false;\
    isResizingX = false;\
\9isResizingY = false;\
\
    minWidth = 60;\
    minHeight = 40;\
    maxWidth = 300;\
    maxHeight = 150;\
\
\
    isCanvasHitTested = false;\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function Window:initialise( ... )\
\9self.super:initialise( ... )\
    self.closeButton = self:insert( CloseWindowButton( { x = 1, y = 1, window = self } ))\
    self.minimiseButton = self:insert( MinimiseWindowButton( { x = 9, y = 1, window = self } ))\
    self.maximiseButton = self:insert( MaximiseWindowButton( { x = 17, y = 1, window = self } ))\
\
    self:loadInterface()\
    \
    self:event( Event.MOUSE_DOWN, self.onMouseDownBefore, EventManager.phase.BEFORE )\
    self:event( Event.MOUSE_DOWN, self.onMouseDownAfter, EventManager.phase.AFTER )\
    self.event:connectGlobal( Event.MOUSE_DRAG, self.onGlobalMouseDrag )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
    self:event( Event.INTERFACE_LOADED, self.onInterfaceLoaded )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Window:initialiseCanvas()\
    self.super:initialiseCanvas()\
    -- self.canvas.fillColour = Graphics.colours.GREEN\
\9local barHeight = self.barHeight\
    local shadowObject = self.canvas:insert( RoundedRectangle( 3, 4, self.width - 2, self.height - 3 ) )\
    local barObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width - 2, barHeight ) )\
    local separatorObject = self.canvas:insert( Rectangle( 1, barHeight + 1, self.width - 2, 1 ) )\
\
    self.theme:connect( barObject, \"fillColour\", \"barColour\" )\
    self.theme:connect( barObject, \"topRadius\", \"topCornerRadius\" )\
    self.theme:connect( separatorObject, \"fillColour\", \"separatorColour\" )\
    self.theme:connect( shadowObject, \"topRadius\", \"topCornerRadius\" )\
    self.theme:connect( shadowObject, \"bottomRadius\", \"bottomCornerRadius\" )\
    self.theme:connect( shadowObject, \"fillColour\", \"shadowColour\" )\
    self.shadowObject = shadowObject\
\9self.barObject = barObject\
\9self.separatorObject = separatorObject\
end\
\
--[[\
    @instance\
    @desc Loads the interface specified by the self.interfaceName interface name\
]]\
function Window:loadInterface()\
    local interfaceName = self.interfaceName\
    if interfaceName then\
        local barHeight = self.barHeight\
        local x, y, width, height = 1, barHeight + 2, self.width - 2, self.height - barHeight - 5\
        local container = Interface( interfaceName, WindowContainer ).container\
        container.x = x\
        container.y = y\
        container.width = width\
        container.height = height\
        self.container = self:insert( container )\
    else\
        self.container = self:insert( WindowContainer( { x = x, y = y, width = width, height = height } ) )\
    end\
end\
\
function Window:setHeight( height )\
    height = math.max( math.min( height, self.maxHeight ), self.minHeight )\
    self.super:setHeight( height )\
    self.shadowObject.height = height - 3\
    local container = self.container\
    if container then container.height = height - self.barHeight - 5 end\
end\
\
function Window:setWidth( width )\
    width = math.max( math.min( width, self.maxWidth ), self.minWidth )\
    self.super:setWidth( width )\
    self.shadowObject.width = width - 2\
    self.barObject.width = width - 2\
    self.separatorObject.width = width - 2\
    local container = self.container\
    if container then container.width = width - 2 end\
end\
\
function Window:onInterfaceLoaded( event )\
    local currentContainer = self.container\
    for i, childView in ipairs( self.children ) do\
        if childView ~= currentContainer and childView:typeOf( WindowContainer ) then\
            childView.x = 1\
            childView.y = self.barHeight + 2\
            childView.width = self.width - 2\
            childView.height = self.height - self.barHeight - 5\
            self:remove( self.container )\
            self.container = childView\
            break\
        end\
    end\
end\
\
function Window:updateThemeStyle()\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
function Window:setIsEnabled( isEnabled )\
    self.super:setIsEnabled( isEnabled )\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Centres the window relative to it's parent (which should be the application container)\
]]\
function Window:centre()\
    local parent = self.parent\
    if parent then\
        self.x = math.ceil( ( parent.width - self.width ) / 2)\
        self.y = math.ceil( ( parent.height - self.height ) / 2)\
    end\
end\
\
--[[\
    @instance\
    @desc Synonym for Window:centre\
]]\
Window.center = Window.centre\
\
--[[\
    @instance\
    @desc Focus on the window, bringing it to the front and enabling controls whilst unfocusing other windows\
]]\
function Window:focus()\
    if not self.isEnabled then\
        self.application:clearFocus()\
        self.isEnabled = true\
        self.parent:sendToFront( self )\
        for i, sibling in ipairs( self:siblingsOfType( Window ) ) do\
            sibling:unfocus()\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Unfocus on the window, disabling controls\
]]\
function Window:unfocus()\
    self.isEnabled = false\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed on the window bar before children have recieved the event. Makes the window front most and active\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onMouseDownBefore( event )\
    self:focus()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed on the window bar after children have recieved the event. Starts dragging.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onMouseDownAfter( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        x = event.x\
        y = event.y\
        local width = self.width\
        local height = self.height\
        local isResizingX = x >= width - 6\
        local isResizingY = y >= height - 8\
        self.isResizingX = isResizingX\
        self.isResizingY = isResizingY\
        self.isDragging = not ( isResizingX or isResizingY )\
        self.dragX = isResizingX and width - x or x\
        self.dragY = isResizingY and height - y or y\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is dragged anywhere on screen. Moves the window if dragging\
    @param [Event] event -- the mouse drag event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onGlobalMouseDrag( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        local preventPropagation = false\
        if self.isDragging then\
            self.x = event.x - self.dragX + 1\
            self.y = event.y - self.dragY + 1\
            preventPropagation = true\
        else\
            if self.isResizingX then\
                self.width = event.x - self.x + self.dragX + 1\
                preventPropagation = true\
            end\
            if self.isResizingY then\
                self.height = event.y - self.y + self.dragY + 1\
                preventPropagation = true\
            end\
        end\
        return preventPropagation\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Stops dragging\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Window:onGlobalMouseUp( event )\
    if (self.isDragging or self.isResizingX or self.isResizingY ) and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.dragX = nil\
        self.dragY = nil\
        self.isDragging = false\
        self.isResizingX = false\
        self.isResizingY = false\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Closes the window, removing it from the screen\
]]\
function Window:close()\
    self.isVisible = false\
    self.parent:remove( self )\
end",["InterfaceOutlet.lua"] = "\
-- This class allows you to connect a container's view to a property in the class definition and in code.\
-- It keeps track of the child view and changes the reference when removed/added\
-- Simply connect like so:\
-- {\
-- \9...\
-- \9myButton = InterfaceOutlet( \"ButtonUniqueIdentifier\" );\9\
-- \9...\
-- }\
\
class \"InterfaceOutlet\" {\
\9viewIdentifier = false;\
\9key = false;\
\9container = false;\
\9views = false;\
\9trackAll = false; -- whether the outlet keeps track of all views with the given identifier, or just one\
}\
\
--[[\
\9@constructor\
\9@desc Initialises the interface outlet\
\9@param [string] viewIdentifier -- the identifier of the desire view\
\9@param [boolean] trackAll -- whether to track all view with the identifier, or just one\
\9@param [Container] owner -- the container that owns the outlet\
]]\
function InterfaceOutlet:initialise( viewIdentifier, trackAll, owner ) -- if you change this you need to change it in class.lua uniqueTable() too\
\9trackAll = trackAll or false\
\9self.viewIdentifier = viewIdentifier\
\9self.trackAll = trackAll\
\9self.owner = owner or false\
\
\9if trackAll then\
\9\9self.views = {}\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Connects the interface outlet to the given Container with the given key\
\9@param [string] key -- the key in the container of this interface outlet\
\9@param [Container] container -- the container to connect to\
]]\
function InterfaceOutlet:connect( key, container )\
\9self:disconnect()\
\
\9self.key = key\
\9self.container = container\
\9self.container.interfaceOutlets[key] = self\
\
\9-- see if there is a view with our identifier already present and bind it\
\9if self.trackAll then\
\9\9self.views = container:findChildren( self.identifier )\
\9else\
\9\9self.views = container:findChild( self.identifier )\
\9end\
\9-- When you index the the outlet it will return tracked view( s )\
\9self.container[\"get\" .. self.key:sub( 1, 1 ):upper() .. self.key:sub( 2, -1 )] = function( container )\
\9\9return self.views\
\9end\
end\
\
function InterfaceOutlet:setViews( views )\
\9local oldViews = self.views\
\9self.views = views\
\9local event = self.owner.event\
\9if event then event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, views, oldViews ) ) end\
end\
\
--[[\
\9@instance\
\9@desc Disconnects the interface outlet from the Container\
\9@param [string] key -- the key in the container of this interface outlet\
\9@param [Container] container -- the container to connect to\
]]\
function InterfaceOutlet:disconnect()\
\9self.container = false\
\9local key = self.key\
\9if key and container then\
\9\9self.container[\"get\" .. self.key:sub( 1, 1 ):upper() .. self.key:sub( 2, -1 )] = nil\
\9\9self.container.interfaceOutlets[self.key] = nil\
\9end\
\9self.key = nil\
\9self.views = nil\
end\
\
--[[\
\9@instance\
\9@desc Called when a child was added to the container. If it's our identifier, track it (if we don't already have a view or we're tracking all)\
\9@param [View] childView -- the view that was just added\
\9@param [boolean] lookInChildren -- whether the\
\9@return [boolean] wasFound -- whether the view was found, only true if trackAll is false\
]]\
function InterfaceOutlet:childAdded( childView, lookInChildren )\
\9local viewIdentifier = self.viewIdentifier\
\9local trackAll = self.trackAll\
\9local views = self.views\
\9local didAdd = false\
\
\9local function search( view )\
\9\9if view.identifier == viewIdentifier then\
\9\9\9if trackAll then\
\9\9\9\9didAdd = true\
\9\9\9\9table.insert( views, view )\
\9\9\9elseif not views then\
\9\9\9\9self.views = view\
\9\9\9\9self.owner.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, view, views ) )\
\9\9\9\9return true\
\9\9\9end\
\9\9end\
\9\9if lookInChildren and view:typeOf( Container ) then\
\9\9\9for i, v in ipairs( view.children ) do\
\9\9\9\9if search( v ) then return true end\
\9\9\9end\
\9\9end\
\9end\
\
\9local found = search( childView ) or false\
\
\9if trackAll and didAdd then\
\9\9self.owner.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, views, views ) )\
\9end\
\
\9return found\
end\
\
--[[\
\9@instance\
\9@desc Called when a child was removed from the container. If it's our identifier stop tracking it.\
\9@param [View] childView -- the view that was just added\
]]\
function InterfaceOutlet:childRemoved( childView )\
\9if childView.identifier == self.viewIdentifier then\
\9\9local views = self.views\
\9\9if self.trackAll then\
\9\9\9local didRemove = false\
\9\9\9for i, trackedView in ipairs( views ) do\
\9\9\9\9if trackedView == childView then\
\9\9\9\9\9views[i] = nil\
\9\9\9\9\9didRemove = true\
\9\9\9\9end\
\9\9\9end\
\9\9\9self.owner.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, views, views ) )\
\9\9elseif views then\
\9\9\9views = nil\
\9\9\9self.owner.event:handleEvent( InterfaceOutletChangedInterfaceEvent( self, nil, views ) )\
\9\9end\
\9end\
end",["MenuButton.lua"] = "\
class \"MenuButton\" extends \"Button\" {\
\
    width = 45;\
\
    menu = false;\
    menuName = false;\
\
    menuMargin = 5;\
\
    closeArrowObject = false;\
    openArrowObject = false;\
    needsArrowUpdate = false;\
}\
\
--[[\
    @constructor\
    @desc Creates a MenuButton object and connects the event handlers\
]]\
function MenuButton:initialise( ... )\
    self.super:initialise( ... )\
    local menuName = self.menuName\
    if not menuName then error( \"MenuButtons must specify the property menuName (the name of the interface file to use).\", 0 ) end\
    menu = Menu.fromInterface( menuName )\
    menu.owner = self\
    menu.isSingleShot = false\
    menu.isVisible = false\
    menu.hitTestOwner = true\
    menu.topMargin = Menu.topMargin + 8\
    self.menu = menu\
    self:event( Event.MENU_CHANGED, self.onMenuChanged )\
    self:event( Event.PARENT_CHANGED, self.onParentChanged )\
end\
\
function MenuButton:onParentChanged( event )\
    local menu = self.menu\
    if menu then\
        menu = self.menu\
        if menu.parent then\
            menu.parent:removeChild( menu )\
        end\
        menu.x = self.x - 5\
        menu.y = self.y + 7\
        self.parent:insert( menu )\
    end\
end\
\
function MenuButton:updateX( x )\
    local menu = self.menu\
    if menu then\
        menu.x = self.x - 5\
    end\
end\
\
function MenuButton:updateY( y )\
    local menu = self.menu\
    if menu then\
        menu.y = self.y + 5\
    end\
end\
\
function MenuButton:updateHeight( height )\
    self.needsArrowUpdate = true\
end\
\
function MenuButton:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local arrowX, arrowY = self.width - 12, math.ceil( ( self.height - 4 ) / 2 )\
\
    local closeArrowObject = Path( 1, 1, 7, 4, 1, 4 )\
    closeArrowObject:lineTo( 4, 1 )\
    closeArrowObject:lineTo( 7, 4 )\
    closeArrowObject:close( false )\
    closeArrowObject.isVisible = false\
    self.closeArrowObject = closeArrowObject\
    self.canvas:insert( closeArrowObject )\
\
    local openArrowObject = Path( 1, 1, 7, 4, 1, 1 )\
    openArrowObject:lineTo( 4, 4 )\
    openArrowObject:lineTo( 7, 1 )\
    openArrowObject:close( false )\
    self.openArrowObject = openArrowObject\
    self.canvas:insert( openArrowObject )\
\
    self.theme:connect( closeArrowObject, \"outlineColour\", \"arrowColour\" )\
    self.theme:connect( openArrowObject, \"outlineColour\", \"arrowColour\" )\
    self.needsArrowUpdate = true\
end\
\
--[[\
    @instance\
    @desc Whether the button is pressed or open\
    @return [boolean] isActive -- whether the button is active\
]]\
function MenuButton:getIsActive()\
    return self.isPressed or self.menu.isOpen\
end\
\
function MenuButton:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isActive and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function MenuButton:update()\
    self.super:update()\
    if self.needsArrowUpdate then\
        self:updateArrows()\
    end\
end\
\
--[[\
    @instance\
    @desc Description\
    @param [type] arg1 -- description\
    @param [type] arg2 -- description\
    @param [type] arg3 -- description\
    @return [type] returnedValue -- description\
]]\
function MenuButton:updateArrows()\
    local menu = self.menu\
    local isOpen = menu and menu.isOpen\
    local arrowX, arrowY = self.width - 12, math.ceil( ( self.height - 4 ) / 2 ) + 1\
    local activeArrow = isOpen and self.closeArrowObject or self.openArrowObject\
    local inactiveArrow = isOpen and self.openArrowObject or self.closeArrowObject\
    activeArrow.isVisible = true\
    inactiveArrow.isVisible = false\
    activeArrow.x = arrowX + ( self.isPressed and 1 or 0 )\
    activeArrow.y = arrowY + ( self.isPressed and 1 or 0 )\
    self.needsArrowUpdate = false\
end\
\
function MenuButton:setIsPressed( isPressed )\
    self.super:setIsPressed( isPressed )\
    self.needsArrowUpdate = true\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released while over the button. Toggles the menu if it hit tests.\
    @param [Event] event -- the mouse up event\
]]\
function MenuButton:onGlobalMouseUp( event )\
    if self.isEnabled and self.isPressed then\
        self.isPressed = false\
        if self:hitTestEvent( event ) then\
            self.menu:toggle()\
            return self.event:handleEvent( event )\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the owned menu opens or closes\
    @param [Event] event -- the menu changed event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuButton:onMenuChanged( event )\
    self:updateArrows()\
    self:updateThemeStyle()\
\
    if self.menu.isOpen then\
        self.parent:sendToFront( self.menu )\
        self.parent:sendToFront( self )\
    end\
    return true\
end",["MenuBar.lua"] = "\
class \"MenuBar\" extends \"Container\" {\
\9needsLayoutUpdate = false;\9\
    separatorObject = false;\
}\
\
function MenuBar:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local separatorObject = self.canvas:insert( Rectangle( 1, self.height, self.width, 1 ) )\
    self.theme:connect( separatorObject, \"fillColour\", \"separatorColour\" )\
    self.theme:connect( self.canvas, \"fillColour\" )\
    self.separatorObject = separatorObject\
end\
\
function MenuBar:updateThemeStyle()\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
--[[\
\9@instance\
\9@desc Updates the location of the menu bar items\
]]\
function MenuBar:updateLayout()\
\9local x = 6\
\9local height = 1\
\9for i, childView in ipairs( self.children ) do\
\9\9childView.x = x\
\9\9x = x + childView.width\
\9\9height = math.max( height, childView.height )\
\9end\
\9self.height = height\
\9self.needsLayoutUpdate = false\
end\
\
function MenuBar:update( deltaTime )\
    self.super:update( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function MenuBar:updateWidth( width )\
\9self.separatorObject.width = width\
end\
\
function MenuBar:updateHeight( Height )\
\9self.separatorObject.y = Height\
end\
\
function MenuBar:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function MenuBar:setIsVisible( isVisible )\
\9self.super:setIsVisible( isVisible )\
\9if isVisible then\
\9\9self.needsLayoutUpdate = true\
\9end\
end\
\
function MenuBar:insert( ... )\
\9self.super:insert( ... )\
\9self.needsLayoutUpdate = true\
end\
\
function MenuBar:removeChild( ... )\
\9self.super:removeChild( ... )\
\9self.needsLayoutUpdate = true\
end",["TimerEvent.lua"] = "\
class \"TimerEvent\" extends \"Event\" {\
\9eventType = Event.TIMER;\
\9timer = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a timer event from the arguments\
\9@param [number] time -- the ID of the timer\
]]\
function TimerEvent:initialise( timer )\
\9self.timer = timer\
end",["SegmentContainer.lua"] = "\
class \"SegmentContainer\" extends \"Container\" {\
\9needsLayoutUpdate = false;\9\
}\
\
--[[\
\9@instance\
\9@desc Updates the location and size of the menu as well as the location and size of the menu items\
]]\
function SegmentContainer:updateLayout()\
\9if self.isVisible then\
\9\9local width = 0\
\9\9local height = 0\
\9\9for i, childView in ipairs( self.children ) do\
\9\9\9height = math.max( height, childView.height )\
\9\9end\
\
\9\9for i, childView in ipairs( self.children ) do\
\9\9\9childView.x = width + 1\
\9\9\9childView.y = 1\
\9\9\9width = width + childView.width\
\9\9end\
\9\9self.width = width\
\9\9self.height = height\
\9end\
end\
\
function SegmentContainer:update( deltaTime )\
    self.super:update( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function SegmentContainer:insert( ... )\
\9self.super:insert( ... )\
\9self.needsLayoutUpdate = true\
end\
\
function SegmentContainer:removeChild( ... )\
\9self.super:removeChild( ... )\
\9self.needsLayoutUpdate = true\
end",["Interface.lua"] = "\
class \"Interface\" {\
\9name = false; -- the name of the interface (the file name without the extension)\
\9container = false; -- if you want to generate a container based on the interface (i.e. not use the properties and children for an already made interface) you can use the value\
\9properties = false; -- the properties given to the root element\
\9children = false; -- the children of the interface\
\9containerClass = false; -- the class type of the interface\
\9childNodes = false; -- the nodes from the root elements XML\
}\
\
--[[\
\9@constructor\
\9@desc Creates and loads an interface with the given name\
\9@param [string] interfaceName -- the file name of the interface\
]]\
function Interface:initialise( interfaceName, extend )\
\9self.name = interfaceName\
\9extend = extend or ApplicationContainer\
\
\9-- TODO: dynamic path resolving for interfaces and other files\
\9local resource = Resource( interfaceName .. \".sinterface\", \"interfaces\" )\
\9local contents = resource.contents\
\9if contents then\
\9\9local nodes, err = XML.fromText( contents )\
\9\9if not err and #nodes ~= 1 then err = \"Interfaces must only have 1 root element.\" end\
\9\9if not nodes or err then\
\9\9\9error( \"Interface XML invaid: \" .. interfaceName .. \".sinterface. Error: \" .. tostring( err ), 0 )\
\9\9end\
\
\9\9local rootNode = nodes[1]\
\9\9local containerClass = class.get( rootNode.type )\
\9\9local err\
\
\9\9if not containerClass then\
\9\9\9err = \"Container class not found: \" .. rootNode.type\
\9\9elseif not containerClass:typeOf( extend ) then\
\9\9\9err = \"Container class does not extend '\" .. extend.className .. \"': \" .. rootNode.type\
\9\9else\
\9\9\9self.containerClass = containerClass\
\9\9\9self.properties = rootNode.attributes\
\9\9\9self.childNodes = rootNode.body\
\9\9end\
\
\9\9if err then\
\9\9\9error( \"Interface XML invaid: \" .. interfaceName .. \".sinterface. Error: \" .. err, 0 )\
\9\9end\
\9else\
\9\9error( \"Interface file not found: \" .. interfaceName .. \".sinterface\", 0 )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns and generates if needed a container from the interface.\
\9@return [Container] container -- the container\
]]\
function Interface:getContainer()\
\9local container = self.container\
\9if container then return container end\
\
\9local properties = self.properties\
\9container = self.containerClass( properties )\
\9container.interfaceProperties = properties\
\9if not container then\
\9\9error( \"Interface XML invaid: \" .. self.name .. \".sinterface. Error: Failed to initialise Container class: \" .. tostring( self.class ) .. \". Identifier: \" .. tostring( properties.identifier ), 0 )\
\9end\
\
\9local children = self.children\
\9for i, childView in ipairs( children ) do\
\9\9container:insert( childView )\
\9end\
\
\9self.container = container\
\9self.container.event:handleEvent( LoadedInterfaceEvent( self.container ) )\
\9return container\
end\
\
--[[\
\9@instance\
\9@desc Creates a table of children from the interface file\
\9@return [table] children -- the table of child views\
]]\
function Interface:getChildren()\
\9local function insertTo( childNode, parentContainer )\
\9\9local childClass = class.get( childNode.type )\
\
\9\9if not childClass then\
\9\9\9return \"Class not found: \" .. childNode.type\
\9\9elseif not childClass:typeOf( View ) then\
\9\9\9return \"Class does not extend 'View': \" .. childNode.type\
\9\9end\
\
\9\9local interfaceProperties = {}\
\9\9for k, v in pairs( childNode.attributes ) do\
\9\9\9interfaceProperties[k] = v\
\9\9end\
\9\9childNode.attributes.interfaceProperties = interfaceProperties\
\9\9local childView = childClass( childNode.attributes )\
\
\9\9if not childView then\
\9\9\9return \"Failed to initialise \" .. childNode.type .. \". Identifier: \" .. tostring( childNode.attributes.identifier )\
\9\9end\
\
\
\9\9if childNode.body and #childNode.body > 0 then\
\9\9\9if not childClass:typeOf( Container ) then\
\9\9\9\9return \"Class does not extend 'Container' but has children: \" .. childNode.type\
\9\9\9else\
\9\9\9\9for i, _childNode in ipairs( childNode.body ) do\
\9\9\9\9\9local child, err = insertTo( _childNode, childView )\
\9\9\9\9\9if err then return nil, err end\
\9\9\9\9\9if child then childView:insert( child ) end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9return childView\
\9end\
\
\9local children = {}\
\9for i, childNode in ipairs( self.childNodes ) do\
\9\9local childView, err = insertTo( childNode )\
\9\9if err then error( \"Interface XML invaid: \" .. self.name .. \".sinterface. Error: \" .. err, 0 ) end\
\9\9if childView then table.insert( children, childView ) end\
\9end\
\9return children\
end",["Application.lua"] = "\
-- need to fix scheduling ... cancelling them won't work right now\
-- each one needs to have its own ID and return that ID\
\
class \"Application\" {\
\9name = false;\
\9path = false;\
\9updateTimer = false;\
\9lastUpdate = 0;\
\9arguments = {};\
\9isRunning = false;\
\9container = false;\
\9document = false;\
\9event = false;\
\9schedules = {};\
\9resourceDirectories = { _ = true }; -- the folders in which the applications resources are\
\9resourceTables = false; -- the tables of files where resources are\
\9keyboardShortcutManager = false;\
\9focus = false;\
\
\9interfaceName = false;\
\
\9-- TODO: exit codes\
\9exitCode = {\
\9\9OKAY = 1;\
\9\9ERROR = 2;\
\9\9-- etc\
\9};\
}\
\
--[[\
\9@static\
\9@desc Adds the given directory to the resource listing and loads any classes\
\9@param [string] path -- the path to the directory of resources\
]]\
function Application.load( path )\
\9-- TODO: path tidying\
\9path = path:gsub( \"/$\", \"/\" )\
\
\9table.insert( Application.resourceDirectories, path )\
\9local loaded = {}\
\9local loadClass\
\9function _G.__loadClassNamed( name )\
\9\9local function checkDir( _path )\
\9\9\9if fs.exists( _path .. \"/\" .. name .. \".lua\" ) then\
\9\9\9\9loadClass( _path .. \"/\" .. name .. \".lua\" )\
\9\9\9\9return true\
\9\9\9end\
\
\9\9\9local list = fs.list( _path )\
\9\9\9for i, v in ipairs( list ) do\
\9\9\9\9if fs.isDir( _path .. '/' .. v ) then\
\9\9\9\9\9if checkDir( _path .. '/' .. v) then return true end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9checkDir( path .. \"/classes\" )\
\9end\
\
\9loadClass = function( _path, content )\
\9\9local name = fs.getName( _path )\
\9\9if not loaded[name] then\
\9\9\9local f, err = loadfile( _path, name )\
\9\9\9if err then error( err, 0 ) end\
\9\9\9local ok, err = pcall( f )\
\9\9\9if err then error( err, 0 ) end\
\9\9\9loaded[name] = true\
\9\9end\
\9end\
\
\9if fs.exists( path .. \"/loadfirst.scfg\") then\
\9\9local f = fs.open( path .. \"/loadfirst.scfg\", \"r\" )\
\9\9if not f then error( \"Failed to read loadfirst.scfg\", 2 ) end\
\
\9\9local line\
\9\9repeat\
\9\9\9line = h.readLine()\
\9\9\9if line and #line > 0 then\
\9\9\9\9__loadClassNamed( line )\
\9\9\9end\
\9\9until not line\
\9\9f.close()\
\9end\
\
\9local function loadDir( _path )\
\9\9local list = fs.list( _path )\
\9\9for i, v in ipairs( list ) do\
\9\9\9if v ~= '.DS_Store' then\
\9\9\9\9local fpath = _path .. '/' .. v\
\9\9\9\9if fs.isDir( fpath ) then\
\9\9\9\9\9loadDir( fpath )\
\9\9\9\9else\
\9\9\9\9\9loadClass( fpath )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9loadDir( path .. \"/classes\" )\
\
\9_G.__loadClassNamed = nil\
end\
\
--[[\
\9@constructor\
\9@desc Creates the application runtime for the Silica program. Call :run() on this to start it.\
\9@param [table] resourceDirectories -- a table of paths in which the applications resources are (classes, themes, etc.)\
]]\
function Application:initialise()\
\9self.resourceTables = __resourceTables or {}\
\9_G.__resourceTables = nil\
\9class.application = self\
\
\9self.event = ApplicationEventManager( self )\
\9self.keyboardShortcutManager = KeyboardShortcutManager( self )\
\9\
\9Font.initialisePresets()\
\9\
\9self:reloadInterface()\
\
\9self.event:connect( Event.TIMER, self.onTimer )\
\
end\
\
--[[\
\9@instance\
\9@desc Changes the interface name, reloading the interface\
\9@param [string] interfaceName -- the name of the interface (the file name without extension)\
]]\
function Application:setInterfaceName( interfaceName )\
\9self.interfaceName = interfaceName\
\9self:reloadInterface()\
end\
\
--[[\
\9@instance\
\9@desc Loads the application container or changes it if there is one.\
]]\
function Application:reloadInterface()\
\9local interfaceName = self.interfaceName\
\
\9local oldContainer = self.container\
\9if oldContainer then\
\9\9oldContainer:dispose()\
\9end\
\
\9if interfaceName then\
\9\9self.container = Interface( interfaceName ).container\
\9else\
\9\9self.container = ApplicationContainer()\
\9end\
\9self.event:handleEvent( ReadyInterfaceEvent( true ) )\
end\
\
function Application:setContainer( container )\
\9self.container = container\
end\
\
--[[\
\9@instance\
\9@desc Update all application's views\
]]\
function Application:update()\
\9-- TODO: not exactally sure how to handle deltaTime for the first one. for now it's zero\
\9local lastUpdate = self.lastUpdate or 0\
\9local deltaTime = os.clock() - lastUpdate\
\9self.updateTimer = os.startTimer( 0.05 )\
\9self.lastUpdate = os.clock()\
\
\9self:checkScheduled( lastUpdate )\
\
\9self.container:update( deltaTime )\
\9self.container:draw()\
end\
\
--[[\
\9@instance\
\9@desc Sets the view that is currently focused (i.e. the selected text box). Do NOT use this when unsetting/remove the focus, use :clearFocus instead\
\9@param [view] newFocus -- the view that is to be focused upon\
]]\
function Application:setFocus( newFocus )\
\9local oldFocus = self.focus\
\9if oldFocus ~= newFocus then\
\9\9self.focus = newFocus\
\9\9self.event:handleEvent( FocusChangedInterfaceEvent( newFocus ) )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Unfocuses the view that is currently focused (i.e. the selected text box)\
]]\
function Application:clearFocus()\
\9self.focus = false\9\
end\
\
--[[\
\9@instance\
\9@desc Schedules a function to be called at a specified time in the future\
\9@param [number] time -- in how many seconds the function should be run\
\9@param [function] func -- the function to call\
\9@param [class] _class -- the class to call the function on ( optional )\
\9@param ... -- any values you want. will be passed as the parameters (other than self)\
\9@return [number] scheduleId -- the ID of the scheduled task\
]]\
function Application:schedule( func, time, ... )\
\9time = time or 0.05\
\9table.insert( self.schedules, { func, os.clock() + time, ... } )\
end\
\
--[[\
\9@instance\
\9@desc Unschedule a scheduled task\
\9@param [number] scheduleId -- the ID of the scheduled task\
\9@return [boolean] didUnschedule -- whether the task was unscheduled. this is only false if the task no longer exists or never existed\
]]\
function Application:unschedule( scheduleId )\
\9if self.schedules[scheduleId] then\
\9\9self.schedules[scheduleId] = nil\
\9\9return true\
\9else return false end\
end\
\
--[[\
\9@instance\
\9@desc Run any scheduled tasks that need to be run\
\9@param [number] lastUpdate -- the time of the last update\
]]\
function Application:checkScheduled( lastUpdate )\
\9local now = os.clock()\
\9for scheduleId, task in ipairs( self.schedules ) do\
\9\9if task[2] <= now then\
\9\9\9local func = task[1]\
\9\9\9table.remove( task, 2 )\
\9\9\9table.remove( task, 1 )\
\9\9\9func( unpack( task ) )\
\9\9\9self.schedules[scheduleId] = nil\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when a timer is fired\
\9@param [TimerEvent] event -- the timer event\
\9@return [boolean] stopPropagation -- whether following handlers should not recieve this event\
]]\
function Application:onTimer( event )\
\9if event.timer and event.timer == self.updateTimer then\
\9\9self:update()\
\9\9return true\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Runs the application runtime with the supplied arguments\
\9@param ... -- the arguments feed to the program (simply use ... for the arguments)\
\9@return [number] exitCode -- returns the exit code of the application\
]]\
function Application:run( ... )\
\9self.arguments = { ... }\
\9self.isRunning = true\
\
\9self:update()\
\
\9while self.isRunning do\
\9\9local event = Event.create( coroutine.yield() )\
\9\9event.relativeView = self.container\
\9\9self.event:handleEvent( event )\
\9end\
end",["Theme.lua"] = "\
class \"Theme\" {\
\9name = false;\
\9extends = false; -- the name of the theme this one extends\
\9classes = {};\
\9active = false; -- @static  the current theme\
\9themes = { 1 }; -- @static  a cache of already created themes\
}\
\
--[[\
\9@constructor\
\9@desc Loads a theme from name\
\9@param [string] themeName -- the name of the theme\
\9@table [table] cantExtend -- a table of the theme names that the theme can't extend (as they are currently extending, which would cause recussursion)\
]]\
function Theme:initialise( themeName, cantExtend )\
\9cantExtend = cantExtend or {}\
\9if cantExtend[themeName] then\
\9\9error( \"Unabled to extend with theme: \" .. themeName .. \". It is already extended higher up, which would cause recussursion.\", 0 )\
\9end\
\9\
\9self.name = themeName\
\
\9-- TODO: dynamic path resolving for interfaces and other files\
\9local resource = Resource( themeName .. \".stheme\", \"themes\" )\
\9local contents = resource.contents\
\9if contents then\
\9\9local nodes, err = XML.fromText( contents )\
\9\9if not nodes then\
\9\9\9error( \"Theme XML invaid: \" .. themeName .. \".stheme. Error: \" .. err, 0 )\
\9\9end\
\9\9cantExtend[themeName] = true\
\9\9local err = self:initialiseTheme( nodes[1], cantExtend )\
\9\9if err then\
\9\9\9error( \"Theme XML invaid: \" .. themeName .. \".stheme. Error: \" .. err, 0 )\
\9\9end\
\9else\
\9\9error( \"Theme file not found: \" .. themeName .. \".stheme\", 0 )\
\9end\
\
\9Theme.themes[themeName] = self\
end\
\
--[[\
\9@static\
\9@desc Returns the theme with the given name. This retireves the theme from a cache if it's already been defined and should be used instead of just Theme()\
\9@param [string] themeName -- the name of the theme\
\9@table [table] cantExtend -- a table of the theme names that the theme can't extend (as they are currently extending, which would cause recussursion)\
\9@return [Theme] theme -- the theme with the given name\
]]\
function Theme.named( themeName, cantExtend )\
\9return Theme.themes[themeName] or Theme( themeName, cantExtend )\
end\
\
--[[\
\9@instance\
\9@desc Creates the container from the interface file\
\9@param [table] nodes -- the nodes from the XML file\
\9@table [table] cantExtend -- a table of the theme names that the theme can't extend (as they are currently extending, which would cause recussursion)\
]]\
function Theme:initialiseTheme( nodes, cantExtend )\
\9if not nodes then\
\9\9return \"Format invalid.\"\
\9elseif nodes.type ~= \"Theme\" then\
\9\9return \"Root element must be 'Theme', got '\" .. tostring( nodes.type ) .. \"'.\"\
\9end\
\
\9local extends = nodes.attributes.extends\
\
\9local classes = {}\
\9if extends then\
\9\9local extendingTheme = Theme.named( extends, cantExtend )\
\9\9if not extendingTheme then return \"Tried to extend a non-existant theme: \" .. extends\
\9\9elseif extendingTheme == self.name then return \"Tried to extend self\" end\
\9\9local extendsClasses = extendingTheme.classes\
\
\9\9for className, classNode in pairs( extendsClasses ) do\
\9\9\9local classTheme = {}\
\9\9\9for propertyName, propertyNode in pairs( classNode ) do\
\9\9\9\9local propertyTheme = {}\
\9\9\9\9for styleName, styleValue in pairs( propertyNode ) do\
\9\9\9\9\9propertyTheme[styleName] = styleValue\
\9\9\9\9end\
\9\9\9\9classTheme[propertyName] = propertyTheme\
\9\9\9end\
\9\9\9classes[className] = classTheme\
\9\9end\
\9\9self.extends = extends\
\9end\
\
\9for i, classNode in ipairs( nodes.body ) do\
\9\9local classTheme = classes[classNode.type] or {}\
\9\9for i2, propertyNode in ipairs( classNode.body ) do\
\9\9\9local propertyTheme = classTheme[propertyNode.type] or {}\
\9\9\9local validationTypeName = propertyNode.attributes.type\
\9\9\9for styleName, styleValue in pairs( propertyNode.attributes ) do\
\9\9\9\9if styleName ~= \"type\" then\
\9\9\9\9\9if Validator.isValid( styleValue, validationTypeName ) then\
\9\9\9\9\9\9propertyTheme[styleName] = Validator.parse( styleValue, validationTypeName )\
\9\9\9\9\9else\
\9\9\9\9\9\9return \"Style value '\" .. tostring( styleValue ) .. \"' is invalid: '\" .. styleName .. \"' (of property: \" .. propertyNode.name .. \" and of class: \" .. classNode.name .. \")\" \
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9\9classTheme[propertyNode.type] = propertyTheme\
\9\9end\
\9\9classes[classNode.type] = classTheme\
\9end\
\9self.classes = classes\
end\
\
--[[\
\9@instance\
\9@desc Gets a value from the theme with the given style for the given class\
\9@param [string] _class -- the name of the class to get the value for\
\9@param [string] propertyName -- the name of the property\
\9@param [string] styleName -- default is \"default\", the style of the value (e.g. disabled, pressed, etc.)\
\9@param [boolean] noError -- whether the function should return false instead of erroring\
\9@return themeValue -- the theme value\
]]\
function Theme:value( _class, propertyName, styleName, noError )\
\9if styleName == \"type\" then\
\9\9error( \"Reserverd style name: \" .. styleName, 0 )\
\9end\
\9styleName = styleName or \"default\"\
\9local className = _class.className\
\
\9local err\
\9local classTheme = self.classes[className]\
\9if classTheme then\
\9\9local propertyTheme = classTheme[propertyName]\
\9\9if propertyTheme then\
\9\9\9local styleValue = propertyTheme[styleName] or propertyTheme[\"default\"]\
\9\9\9if styleValue then\
\9\9\9\9return styleValue\
\9\9\9else\
\9\9\9\9err = \"Theme '\" .. self.name .. \"' does not have any definition for style: '\" .. styleName .. \"' or 'default' (of property: \" .. propertyName .. \" and of class: \" .. _class.className .. \")\"\
\9\9\9end\
\9\9else\
\9\9\9err = \"Theme '\" .. self.name .. \"' does not have any definitions for property: '\" .. propertyName .. \" '(of class: \" .. className .. \")\"\
\9\9end\
\9else\
\9\9err = \"Theme '\" .. self.name .. \"' does not have any definitions for class: '\" .. className .. \"'\"\
\9end\
\
\9-- an error occured, try to see if the value was defined for a super class\
\9if _class._extends then\
\9\9local themeValue = self:value( _class._extends, propertyName, styleName, true )\
\9\9if themeValue then\
\9\9\9return themeValue\
\9\9end\
\9end\
\
\9-- there was no value defined for a super class\
\9if noError then\
\9\9return false\
\9else\
\9\9error( err, 0 )\
\9end\
end",["ReadyInterfaceEvent.lua"] = "\
class \"ReadyInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.INTERFACE_READY;\
\9isInit = false; -- whether the event is the first one called in Application:initialise\
}\
\
--[[\
\9@constructor\
\9@desc Creates a ready event from the arguments\
\9@param isInit -- whether the event is the first one called in Application:initialise\
]]\
function ReadyInterfaceEvent:initialise( isInit )\
\9self.isInit = isInit or false\
end\
",["View.lua"] = "\
local DEFAULT_TIME = .3\
local DEFAULT_EASING = Animation.easing.IN_OUT_SINE\
\
local function newAnimation( self, label, time, values, easing, onFinish )\
\9local animation = Animation( time, self, values, easing, true )\
\9for i = #self.animations, 1, -1 do\
\9\9if self.animations[i].label == label then\
\9\9\9table.remove( self.animations, i )\
\9\9end\
\9end\
\9self.animations[#self.animations + 1] = { label = label, animation = animation, onFinish = onFinish }\
end\
\
class \"View\" {\
\9x = false;\
\9y = false;\
\9width = false;\
\9height = false;\
\9index = false; -- its index in its parent\
\9parent = false;\
\9siblings = false;\
\9identifier = false;\
\9interfaceProperties = false; -- the properties the view was given in the interface XML file\
\
\9animations = {};\
\
\9event = false;\
\9canvas = false;\
\9theme = false;\
\9isCanvasHitTested = true;\
\9isVisible = true;\
\9isFocusDismissable = true; -- whether clicking away from the view when focused will unfocus it\
\9isEnabled = true;\
\
\9stringConstraints = {}; -- the constraints strings\
\9loadedConstraints = {}; -- the parsed constraints\
\9constraintsNeedingUpdate = {}; -- the constraints that need to be refreshed next update\
\9needsConstraintUpdate = {}; -- whether the constraint values have changed and the view needs to be informed\
\9references = {};\
\9--[[ format:\
\9\9{\
\9\9\9[property] = {\
\9\9\9\9[reference1 (string)] = true;\
\9\9\9\9[reference2 (string)] = true;\
\9\9\9}\
\9\9}\
\9]]\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a view instance\
\9@param [table] properties -- the properties for the view\
]]\
function View:initialise( properties )\
\9self.animations.names = {} \
\9self:initialiseEventManager()\
\9self:initialiseTheme()\
\9self:initialiseCanvas()\
\
\9setmetatable( self.stringConstraints, {\
\9\9__index = { parent = self }, __newindex = function( t, k, v )\
\9\9\9if t.parent.identifier == \"testview\" then\
\9\9\9\9-- log( \"Setting \" .. k .. \" to \" .. tostring( v ) )\
\9\9\9\9-- logtraceback()\
\9\9\9end\
\9\9\9rawset( t, k, v )\
\9\9end\
\9} )\
\9\
\9if properties and type( properties ) == \"table\" then\
\9\9self:properties( properties )\
\9end\
\
    self:event( Event.PARENT_RESIZED, self.onParentResizedConstraintUpdate )\
    self:event( Event.PARENT_CHANGED, self.onParentChangedConstraintUpdate )\
    self:event( Event.INTERFACE_READY, self.onReadyConstraintUpdate )\
end\
\
function View:initialiseTheme()\
\9self.theme = ThemeOutlet( self )\
end\
\
--[[\
\9@instance\
\9@desc Initialises the view's event manager (used for overriding)\
]]\
function View:initialiseEventManager()\
\9self.event = EventManager( self )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function View:initialiseCanvas()\
\9self.canvas = Canvas( self.x, self.y, self.width, self.height )\
end\
\
--[[\
\9@instance\
\9@desc Returns the view's siblings in it's container\
\9@return [table] siblings -- an array of the siblings\
]]\
function View:getSiblings()\
\9local siblings = {}\
\
\9if self.parent then\
\9\9for i, child in ipairs( self.parent.children ) do\
\9\9\9if child ~= self then\
\9\9\9\9siblings[#siblings + 1] = child\
\9\9\9end\
\9\9end\
\9end\
\
\9return siblings\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the view is the first child of it's parent\
\9@return [boolean] isFirst -- whether  the view is the first child of it's parent\
]]\
function View:getIsFirst()\
    return self.index == 1\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the view is the last child of it's parent\
\9@return [boolean] isLast -- whether  the view is the last child of it's parent\
]]\
function View:getIsLast()\
    local parent = self.parent\
    return parent and (self.index == #parent.children) or false\
end\
\
--[[\
\9@instance\
\9@desc Returns whether the control is enabled, rising up to the parent containers as well\
\9@return [boolean] isEnabled -- whether the view is enabled\
]]\
function View:getIsEnabled()\
\9if not self.isEnabled then\
\9\9return false\
\9else\
\9\9local parent = self.parent\
\9\9if parent and not parent.isEnabled then\
\9\9\9return false\
\9\9else\
\9\9\9return true\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns the index of the view in it's parent. 1 is the bottom most view\
\9@return [number] index -- an array of the siblings\
]]\
function View:getIndex()\
\9if self.parent then\
\9\9for i, child in ipairs( self.parent.children ) do\
\9\9\9if child == self then\
\9\9\9\9return i\
\9\9\9end\
\9\9end\
\9end\
\9return 1\
end\
\
--[[\
\9@instance\
\9@desc Returns the view's siblings in it's container that are of or inherit from the given class\
\9@param [class] _class -- the class type\
\9@return [table] siblings -- an array of the siblings\
]]\
function View:siblingsOfType( _class )\
\9local siblings = {}\
\
\9for i, sibling in ipairs( self.siblings ) do\
\9\9if sibling:typeOf( _class ) then\
\9\9\9siblings[#siblings + 1] = sibling\
\9\9end\
\9end\
\
\9return siblings\
end\
\
View:alias( \"x\", \"left\" )\
View:alias( \"y\", \"top\" )\
\
-- object.left is the raw left value (i.e. a number, or nil if not yet calculated)\
-- object.loadedConstraints.left is the parsed and simplified left value\
-- object.stringConstraints.left is the string constraint\
\
--[[\
\9@instance\
\9@desc Parses a constraint and simplifies it\
\9@param [string] property - the constraint to parse and simplify\
\9@return [table] parsed - the parsed and simplified constraint\
]]\
function View:parseConstraint( property )\
\9local loaded = self.loadedConstraints\
\9if loaded[property] then return loaded[property] end\
\
\9local constraints = self.stringConstraints\
\9local constraintString = constraints[property]\
\9\
\9if not constraintString then\
\9\9-- solve it based on other constraints\
\9\9local left, right, top, bottom, width, height = constraints.left or \"1\", constraints.right or \"1\", constraints.top or \"1\", constraints.bottom or \"1\", constraints.width or \"1\", constraints.height or \"1\"\
\
\9\9if property == \"width\" then\
\9\9\9constraintString = \"(\" .. right .. \")-(\" .. left .. \")+1\"\
\9\9elseif property == \"height\" then\
\9\9\9constraintString = \"(\" .. bottom .. \")-(\" .. top .. \")+1\"\
\9\9elseif property == \"left\" then\
\9\9\9constraintString = \"(\" .. right .. \")-(\" .. width .. \")+1\"\
\9\9elseif property == \"right\" then\
\9\9\9constraintString = \"(\" .. width .. \")+(\" .. left .. \")-1\"\
\9\9elseif property == \"top\" then\
\9\9\9constraintString = \"(\" .. bottom .. \")-(\" .. height .. \")+1\"\
\9\9elseif property == \"bottom\" then\
\9\9\9constraintString = \"(\" .. top .. \")+(\" .. height .. \")-1\"\
\9\9else\
\9\9\9constraintString = \"0\"\
\9\9end\
\9end\
\
\9local parsed = MathParser.parseString( tostring( constraintString ) )\
\9MathParser.simplify( parsed )\
\
\9loaded[property] = parsed\
\9return parsed\
end\
\
--[[\
\9@instance\
\9@desc Evaluates the numerical value of a constraint\
\9@param [string] property -- the name of the property (i.e. left, width, etc.)\
\9@return [number] value -- the numerical value\
]]\
function View:evalConstraint( property )\
\9local references = {}\
\9local parsed = self:parseConstraint( property )\
\9local resolved = MathParser.resolve( parsed, self, property, references )\
\9local value = MathParser.eval( resolved )\
\
\9self.raw[property] = value\
\9self.references[property] = references\
\9\
\9self.needsConstraintUpdate[self:updateConstraint( property, value )] = true\
\9return value\
end\
\
function View:updateConstraint( property, value )\
\9local stringConstraints = self.stringConstraints\
\9local canvas = self.canvas\
\9if property == \"top\" then\
\9\9self.raw.y = value\
\9\9if canvas then canvas.y = value end\
\9\9return \"y\"\
\9elseif property == \"bottom\" then\
\9\9if stringConstraints.height then\
\9\9\9value = value - self.height + 1\
\9\9\9self.raw.y = value\
\9\9\9if canvas then canvas.y = value end\
\9\9\9return \"y\"\
\9\9else\
\9\9\9value = value - self.y + 1\
\9\9\9self.raw.height = value\
\9\9\9if canvas then canvas.height = value end\
\9\9\9return \"height\"\
\9\9end\
\9elseif property == \"left\" then\
\9\9self.raw.x = value\
\9\9if canvas then canvas.x = value end\
\9\9return \"x\"\
\9elseif property == \"right\" then\
\9\9if stringConstraints.width then\
\9\9\9value = value - self.width + 1\
\9\9\9self.raw.x = value\
\9\9\9if canvas then canvas.x = value end\
\9\9\9return \"x\"\
\9\9else\
\9\9\9value = value - self.x + 1\
\9\9\9self.raw.width = value\
\9\9\9if canvas then canvas.width = value end\
\9\9\9return \"width\"\
\9\9end\
\9elseif property == \"width\" then\
\9\9self.raw.width = value\
\9\9if canvas then canvas.width = value end\
\9\9return \"width\"\
\9elseif property == \"height\" then\
\9\9self.raw.height = value\
\9\9if canvas then canvas.height = value end\
\9\9return \"height\"\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the parent changes. This updates constraints.\
\9@param [ParentChangedInterfaceEvent] event -- the event\
]]\
function View:onParentChangedConstraintUpdate( event )\
\9for k, v in pairs( self.stringConstraints ) do\
\9\9self.constraintsNeedingUpdate[k] = true\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the interface is loaded and ready. This updates constraints.\
\9@param [ReadyInterfaceEvent] event -- the event\
]]\
function View:onReadyConstraintUpdate( event )\
\9if event.isInit then\
\9\9for k, v in pairs( self.stringConstraints ) do\
\9\9\9self.constraintsNeedingUpdate[k] = true\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the parent resizes. This updates constraints.\
\9@param [ParentResizeInterfaceEvent] event -- the event\
]]\
function View:onParentResizedConstraintUpdate( event )\
\9local isHorizontal = event.isHorizontal\
\9local isVertical = event.isVertical\
\9local ident = self.identifier\
\9for k, v in pairs( self.stringConstraints ) do\
\9\9local isKHorizontal = ( k == \"left\" or k == \"right\" or k == \"width\" )\
\9\9if isHorizontal and isKHorizontal then\
\9\9\9self.constraintsNeedingUpdate[k] = true\
\9\9elseif isVertical and not isKHorizontal then\
\9\9\9self.constraintsNeedingUpdate[k] = true\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Re-evaluates a constraint, reparsing if necessary.\
\9@param [string] property -- the name of the property (i.e. left, width, etc.)\
\9@param [boolean] isReferenceChange -- false if it should re-parse the constraint\
\9@return [number] value\
\
\9@note - call when a reference changes with true\
\9@note - call when the constraint changes with false\
]]\
function View:reloadConstraint( property, isReferenceChange )\
\9if not isReferenceChange then\
\9\9self.loadedConstraints[property] = nil\
\9end\
\9return self:evalConstraint( property )\
end\
\
-- @instance\
function View:getTop()\
\9return self.top or self:evalConstraint \"top\"\
end\
\
-- @instance\
function View:setTop( top )\
\9if top then\
\9\9self.stringConstraints.top = top\
\9\9self:reloadConstraint \"top\"\
\9else\
\9\9self.stringConstraints.top = nil\
\9end\
end\
\
-- @instance\
function View:getBottom()\
\9return self.bottom or self:evalConstraint \"bottom\"\
end\
\
-- @instance\
function View:setBottom( bottom )\
\9if bottom then\
\9\9local stringConstraints = self.stringConstraints\
\9\9stringConstraints.bottom = bottom\
\9\9self:reloadConstraint \"bottom\"\
\9\9if stringConstraints.height then\
\9\9\9stringConstraints.top = nil\
\9\9elseif stringConstraints.top then\
\9\9\9stringConstraints.height = nil\
\9\9end\
\9else\
\9\9self.stringConstraints.top = nil\
\9end\
end\
\
-- @instance\
function View:getLeft()\
\9return self.left or self:evalConstraint \"left\"\
end\
\
-- @instance\
function View:setLeft( left )\
\9local value\
\9if left then\
\9\9local stringConstraints = self.stringConstraints\
\9\9stringConstraints.left = left\
\9\9value = self:reloadConstraint \"left\"\
\9\9if stringConstraints.width then\
\9\9\9stringConstraints.right = nil\
\9\9elseif stringConstraints.right then\
\9\9\9stringConstraints.width = nil\
\9\9end\
\9else\
\9\9self.stringConstraints.left = nil\
\9end\
\9return value\
end\
\
-- @instance \
function View:getRight()\
\9return self.right or self:evalConstraint \"right\"\
end\
\
-- @instance \
function View:setRight( right )\
\9local value\
\9if right then\
\9\9local stringConstraints = self.stringConstraints\
\9\9stringConstraints.right = right\
\9\9value = self:reloadConstraint \"right\"\
\9\9if stringConstraints.width then\
\9\9\9stringConstraints.left = nil\
\9\9elseif stringConstraints.left then\
\9\9\9stringConstraints.width = nil\
\9\9end\
\9else\
\9\9self.stringConstraints.right = nil\
\9end\
\9return value\
end\
\
-- @instance \
function View:getWidth()\
\9return self.width or self:evalConstraint \"width\"\
end\
\
-- @instance \
function View:setWidth( width )\
\9local value\
\9if width then\
\9\9local stringConstraints = self.stringConstraints\
\9\9stringConstraints.width = width\
\9\9value = self:reloadConstraint \"width\"\
\9\9if stringConstraints.left then\
\9\9\9stringConstraints.right = nil\
\9\9elseif stringConstraints.right then\
\9\9\9stringConstraints.left = nil\
\9\9end\
\9else\
\9\9self.stringConstraints.width = nil\
\9end\
\9return value\
end\
\
-- @instance \
function View:getHeight()\
\9return self.height or self:evalConstraint \"height\"\
end\
\
-- @instance \
function View:setHeight( height )\
\9local value\
\9if height then\
\9\9local stringConstraints = self.stringConstraints\
\9\9stringConstraints.height = height\
\9\9value = self:reloadConstraint \"height\"\
\9\9if stringConstraints.top then\
\9\9\9stringConstraints.bottom = nil\
\9\9elseif stringConstraints.bottom then\
\9\9\9stringConstraints.top = nil\
\9\9end\
\9else\
\9\9self.stringConstraints.height = nil\
\9end\
\9return value\
end\
\
function View:setIsVisible( isVisible )\
\9self.canvas.isVisible = isVisible\
\9self.isVisible = isVisible\
end\
\
function View:getIsVisible()\
\9return self.parent and self.isVisible -- if we don't have a parent we're effectively not visible\
end\
\
--[[\
\9@instance\
\9@desc Converts the local coordinates to local coordinates of a parent (or global if nil) to.\
\9@param [number] x -- the local x coordinate\
\9@param [number] y -- the local y coordinate\
\9@param [View] parent -- the parent to convert to\
\9@return [number] x -- the x coordinate in the parent's coordinate system\
\9@return [number] y -- the x coordinate in the parent's coordinate system\
]]\
function View:coordinatesTo( x, y, parent )\
\9parent = parent or self.application.container\
\
\9local currentParrent = { parent = self }\
\9while currentParrent.parent and currentParrent.parent ~= parent do\
\9\9currentParrent = currentParrent.parent\
\9\9x = x + currentParrent.x - 1\
\9\9y = y + currentParrent.y - 1\
\9end\
\9return x, y\
end\
\
--[[\
\9@instance\
\9@desc Converts the position of the view to the coordinates in a parent (or global if nil)\
\9@param [View] parent -- the parent to convert to\
\9@return [number] x -- the x coordinate in the parent's coordinate system\
\9@return [number] y -- the x coordinate in the parent's coordinate system\
]]\
function View:position( parent )\
\9if not self.parent or parent == self.parent then\
\9\9return self.x, self.y\
\9else\
\9\9local x, y = self:coordinatesTo( 1, 1, parent )\
\9\9return x, y\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Converts the coordinates of a parent (or global if nil) to local coordinates.\
\9@param [number] x -- the x coordinate\
\9@param [number] y -- the y coordinate\
\9@param [View] parent -- the parent to convert from\
\9@return [number] x -- the local x coordinate\
\9@return [number] y -- the local x coordinate\
]]\
function View:coordinates( x, y, parent )\
\9parent = parent or self.application.container\
\9\
\9local currentParrent = self\
\9while currentParrent and currentParrent ~= parent do\
\9\9x = x - currentParrent.x + 1\
\9\9y = y - currentParrent.y + 1\
\9\9currentParrent = currentParrent.parent\
\9end\
\
\9return x, y\
end\
\
--[[\
\9@instance\
\9@desc Hit test the view realative to the parent's coordinates (or globally if not specified)\
\9@param [number] x -- the x coordinate to hit test\
\9@param [number] y -- the y coorindate to hit test\
\9@param [View] parent -- the parent\
\9@return [boolean] isHit -- whether the hit test hit\
]]\
function View:hitTest( x, y, parent )\
\9return self.isVisible and self.x <= x\
\9   and x <= self.x + self.width - 1\
\9   and self.y <= y and y <= self.y + self.height - 1\
\9   and ( not self.isCanvasHitTested or self.canvas:hitTest( x - self.x + 1, y - self.y + 1 ))\
end\
\
--[[\
\9@instance\
\9@desc Hit tests the view with an event relative to the parent, uses the coordinates if it's a MouseEvent, otherwise it will always return true\
\9@param [Event] event -- the event\
\9@param [View] parent -- the parent\
\9@return [boolean] isHit -- whether the hit test hit\
]]\
function View:hitTestEvent( event, parent )\
\9parent = parent or self.parent\
\9if not parent then return false\
\9elseif event:typeOf( MouseEvent ) then\
\9\9event:makeRelative( parent )\
\9\9local x, y = event.x, event.y\
\9\9return self:hitTest( x, y, parent )\
\9else\
\9\9return true\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Update the animation\
\9@param [number] deltaTime -- time since last update\
]]\
function View:update( dt )\
\9local animations = self.animations\
\9for i = #animations, 1, -1 do\
\9\9local animation = animations[i]\
\9\9animation.animation:update( dt )\
\9\9if animation.animation.time >= animation.animation.duration then\
\9\9\9if animation.onFinish then\
\9\9\9\9animation.onFinish( self )\
\9\9\9end\
\9\9\9table.remove( animations, i )\
\9\9end\
\9end\
\
\9local constraintsNeedingUpdate = self.constraintsNeedingUpdate\
\9local constraintOrder = { \"width\", \"height\", \"left\", \"top\", \"bottom\", \"right\" }\
\9for i, v in ipairs( constraintOrder ) do\
\9\9if constraintsNeedingUpdate[v] then\
\9\9\9self:reloadConstraint( v, true )\
\9\9\9constraintsNeedingUpdate[v] = nil\
\9\9end\
\9end\
\
\9if self.hasInitialised then\
\9\9local needsConstraintUpdate = self.needsConstraintUpdate\
\9\9for k, isChanged in pairs( needsConstraintUpdate ) do\
\9\9\9if isChanged then\
\9\9\9\9local constraintUpdate = self[k == \"x\" and \"updateX\" or k == \"y\" and \"updateY\" or k == \"width\" and \"updateWidth\" or k == \"height\" and \"updateHeight\"]\
\9\9\9\9if constraintUpdate then\
\9\9\9\9\9constraintUpdate( self, self.raw[k] )\
\9\9\9\9end\
\9\9\9\9needsConstraintUpdate[k] = false\
\9\9\9end\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in a certain property\
\9@param [string] propertyName -- the name of the property\
\9@param [number] value -- the target value\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animate( propertyName, value, time, onFinish, easing )\
\9newAnimation( self, propertyName, time or DEFAULT_TIME, { [propertyName] = value }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the x coordinate\
\9@param [number] x -- the target x coordinate\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateX( x, time, onFinish, easing )\
\9newAnimation( self, \"x\", time or DEFAULT_TIME, { x = x }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the y coordinate\
\9@param [number] y -- the target y coordinate\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateY( y, time, onFinish, easing )\
\9newAnimation( self, \"y\", time or DEFAULT_TIME, { y = y }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the width\
\9@param [number] width -- the target width\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateWidth( width, time, onFinish, easing )\
\9newAnimation( self, \"width\", time or DEFAULT_TIME, { width = width }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the height\
\9@param [number] height -- the target height\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:animateHeight( height, time, onFinish, easing )\
\9newAnimation( self, \"height\", time or DEFAULT_TIME, { height = height }, easing or DEFAULT_EASING, type( onFinish ) == \"function\" and onFinish )\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the position\
\9@param [number] x -- the target x coordinate\
\9@param [number] y -- the target y coordinate\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:move( x, y, time, onFinish, easing )\
\9local d = false\
\9local function f()\
\9\9if not d then d = true return onFinish() end -- stops the function being called twice\
\9end\
\9self:animateX( x, time, type( onFinish ) == \"function\" and f, easing )\
\9self:animateY( y, time, type( onFinish ) == \"function\" and f, easing )\
end\
\
--[[\
\9@instance\
\9@desc Animate a change in the size\
\9@param [number] width -- the target width\
\9@param [number] height -- the target height\
\9@param [number] time -- the duration of the animation\
\9@param [function] onFinish -- the function called on completion of the animation\
\9@param [Animation.easing] easing -- the easing function of the animation\
]]\
function View:resize( width, height, time, onFinish, easing )\
\9local d = false\
\9local function f()\
\9\9if not d then d = true return onFinish() end -- stops the function being called twice\
\9end\
\9self:animateWidth( width, time, type( onFinish ) == \"function\" and f, easing )\
\9self:animateHeight( height, time, type( onFinish ) == \"function\" and f, easing )\
end\
\
function View:dispose()\
\9self.event:dispose()\
end",["KeyboardShortcut.lua"] = "\
class \"KeyboardShortcut\" {\
\9keys = {};\
}\
\
--[[\
\9@constructor\
\9@desc Creates a keyboard shortcut\
\9@param ... -- all the keys for the shortcut\
]]\
function KeyboardShortcut:initialise( ... )\
\9self.keys = { ... }\
end\
\
--[[\
\9@instance\
\9@desc Returns the symbol string to be used on menus and elsewhere to represent the shortcut\
\9@return [string] symbols -- the symbols string\
]]\
function KeyboardShortcut:symbols()\
\9local symbols = \"\"\
\9local symbol = KeyboardShortcutManager.symbol\
\9for i, keyString in ipairs( self.keys ) do\
\9\9symbols = symbols .. symbol( keyString )\
\9end\
\9return symbols\
end\
\
--[[\
\9@instance\
\9@desc Creates a keyboard shortcut from a string. Each key is separated by a space. Keys represented by a character (i.e. a, 5, /) should be written as the character. Other posibilities are: ctrl (also acts as command on OS X), alt, shift, tab, esc, delete, backspace, enter, left, right, up, down, fn, home, end, f1, f2 .. f12\
\9@param [string] keys -- the shortcut string\
\9@return [KeyboardShortcut] keyboardShortcut -- the keyboard shortcut\
]]\
function KeyboardShortcut.fromString( str )\
\9local parts = String( str ):split( \" \" )\
\9local keys = {}\
\
\9local isValid = KeyboardShortcutManager.isValid\9\
\9for i, key in ipairs( parts ) do\
\9\9if #key > 0 then\
\9\9\9if isValid( key ) then\
\9\9\9\9table.insert( keys, key )\
\9\9\9else\
\9\9\9\9error( \"Invalid keyboard shortcut '\" .. str ..\"'. The key '\" .. key .. \"' is not valid. Omit sides (i.e. leftShift is just shift) and use the character where possible (i.e. / not slash)\", 0 )\
\9\9\9end\
\9\9end\
\9end\
\
\9return KeyboardShortcut( unpack( keys ) )\
end\
\
--[[\
\9@instance\
\9@desc Compares the shortcut to a keyboard shortcut event\
\9@param [KeyboardShortcutEvent] event -- the keyboard shortcut event\
\9@return [boolean] isMatch -- whether the keyboard shortcut was a match (i.e. the keys are down)\
]]\
function KeyboardShortcut:matchesEvent( event )\
\9return event:matchesKeys( self.keys )\
end",["SiblingAddedInterfaceEvent.lua"] = "\
class \"SiblingAddedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.SIBLING_ADDED;\
\9view = false; -- the new sibling that was added\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a siblings changed event from the arguments\
\9@param [View] view -- the new sibling view\
]]\
function SiblingAddedInterfaceEvent:initialise( view )\
\9self.view = view\
end",["FontWindowContainer.lua"] = "\
class \"FontWindowContainer\" extends \"WindowContainer\" {\
\9backgroundObject = nil;\
}\
\
function FontWindowContainer:initialiseCanvas()\
\9self.canvas = FontWindowCanvas( self.x, self.y, self.width, self.height )\
\9self.backgroundObject = self.canvas:insert( Rectangle( 1, 1, self.width, self.height, Graphics.colours.WHITE ) )\
end",["String.lua"] = "\
class \"String\" {\
\9str = nil;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a string object\
\9@param [string] str -- the string to use\
]]\
function String:initialise( str )\
\9self.str = str\
end\
\
--[[\
\9@instance\
\9@desc Splits a string in to an array with a delimeter\
\9@param [string] delimeter -- the delimeter\
\9@return [table] components -- the split string components\
]]\
function String:split( delimeter )\
\9local components = {}\
\9local t = string.format( \"([^%s]+)\", delimeter )\
\9self.str:gsub( t, function( t )\
\9\9components[#components+1] = t\
\9end )\
\9return components\
end\
\
--[[\
\9@instance\
\9@desc The file extension of the string\
\9@return [table] components -- a table with the directory path, file name and then extension\
]]\
function String:pathComponents()\
\9return string.match( self.str, \"(.-)([^/]-([^%.]+))$\" )\
end\
\
-- TODO: more string methods",["CharacterEvent.lua"] = "\
class \"CharacterEvent\" extends \"Event\" {\
\9eventType = Event.CHARACTER;\
\9character = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a char event from the arguments\
\9@param [string] character -- the event character\
]]\
function CharacterEvent:initialise( character )\
\9self.character = character\
end",["WindowCanvas.lua"] = "\
class \"WindowCanvas\" extends \"Canvas\" { }\
\
-- function WindowCanvas:drawTo( ... )\
--     if self.isVisible then\
--         local hasChanged = self.hasChanged\
--         self.super:drawTo( ... )\
--         if hasChanged then\
--         \9self.\
--         end\
--     end\
--     return self\
-- end\
\
\
\
function WindowCanvas:draw( ... )\
    if self.isVisible then\
    \9self.super:draw( ... )\
       \
    \9local y = self.height - 1\
    \9local width = self.width\
    \9local buffer = self.buffer\
    \9local transparent = Graphics.colours.TRANSPARENT\
    \9buffer[y * width + 1] = transparent\
    \9buffer[y * width + width] = transparent\
    end\
    return self\
end",["ThemeOutlet.lua"] = "\
class \"ThemeOutlet\" {\
\9style = \"default\";\
\9owner = false;\
\9ownerClass = false;\
\9connections = {};\
}\
\
--[[\
\9@constructor\
\9@desc Creates a ThemeOutlet\
\9@param [class] owner -- the outlet owner\
]]\
function ThemeOutlet:initialise( owner )\
\9self.owner = owner\
\9self.ownerClass = owner.class\
\9owner.event:connectGlobal( Event.THEME_CHANGED, self.onThemeChange, nil, self )\
end\
\
--[[\
\9@instance\
\9@desc Returns the value for the given key, using the current theme style\
\9@param [string] key -- the key of the value\
\9@return value -- the value\
]]\
function ThemeOutlet:get( key )\
\9if key == \"themeValue\" or key == \"identifier\" or key == \"instance\" or key == \"style\" or self[key] then return false end\
\9return true, self:themeValue( key, self.style )\
end\
\
--[[\
\9@instance\
\9@desc Connect a class value to a theme value, updating it each time the style is changed\
\9@param [class] _class -- the class to connect the value to\
\9@param [string] classKey -- the key of the class' value\
\9@param [string] key -- the key of the value\
]]\
function ThemeOutlet:connect( _class, classKey, key )\
\9self:disconnect( _class, classKey, key )\
\9key = key or classKey\
\9table.insert( self.connections, { _class, classKey, key, _class[classKey] } )\
\9_class[classKey] = self:themeValue( key, style )\
end\
\
--[[\
\9@instance\
\9@desc Disconnect a class value from a theme value\
\9@param [class] _class -- the class that was connected\
\9@param [string] classKey -- the key of the class' value\
\9@param [string] key -- the key of the value\
]]\
function ThemeOutlet:disconnect( _class, classKey, key )\
\9key = key or classKey\
\9for i, connection in pairs( self.connections ) do\
\9\9if _class == connection[1] and classKey == connection[2] and key == connection[3] then\
\9\9\9self.connections[i] = nil\
\9\9\9_class[classKey] = connection[4]\
\9\9\9return\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Fired when the theme changes, updates the value\
\9@param [string] style -- the style name\
]]\
function ThemeOutlet:onThemeChange( event )\
\9local style = self.style\
\9for i, connection in pairs( self.connections ) do\
\9\9connection[1][connection[2]] = self:themeValue( connection[3], style )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Sets the current style (pressed, checked, disabled, etc) for the owner\
\9@param [string] style -- the style name\
]]\
function ThemeOutlet:setStyle( style )\
\9self.style = style\
\9for i, connection in pairs( self.connections ) do\
\9\9connection[1][connection[2]] = self:themeValue( connection[3], style )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns the value for the current theme given the property name and style)\
\9@param [string] propertyName -- the name of the property\
\9@param [string] styleName -- default is \"default\", the name of the style\
\9@return themeValue -- the theme value\
]]\
function ThemeOutlet:themeValue( valueName, styleName )\
\9return Theme.active:value( self.ownerClass, valueName, styleName )\
end",["Validator.lua"] = "\
-- validates and parses values (so BLUE becomes Graphics.colours.BLUE)\
class \"Validator\" {}\
\
--[[\
\9@instance\
\9@desc Gets a validation table from the given type name\
\9@param [string] typeName -- the type to validate against\
\9@return [Validator.validatorType] validatorType -- the table of valid values\
]]\
function Validator.validatorType( typeName )\
\9-- TODO: make validator types dynamic\
\9if typeName == \"Graphics.colours\" then\
\9\9return function( k ) return Graphics.colours[k] end\
\9elseif typeName == \"number\" then\
\9\9return tonumber\
\9elseif typeName == \"string\" then\
\9\9return tostring\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Validate a value against the given type\
\9@param value -- the value to validate\
\9@param [string] typeName -- the type to validate against\
\9@return [boolean] isValid -- whether the value is valid\
]]\
function Validator.isValid( value, typeName )\
\9local validatorType = Validator.validatorType( typeName )\
\9return validatorType( value ) ~= nil\
end\
\
--[[\
\9@instance\
\9@desc Parse a value to the given type\
\9@param value -- the value to parse\
\9@param [string] typeName -- the type to parse to\
\9@return parsedValue -- the parsed value\
]]\
function Validator.parse( value, typeName )\
\9local validatorType = Validator.validatorType( typeName )\
\9return validatorType( value )\
end",["MouseDragEvent.lua"] = "\
class \"MouseDragEvent\" extends \"MouseEvent\" {\
\9eventType = Event.MOUSE_DRAG;\
\9mouseButton = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseDragEvent:initialise( mouseButton, x, y )\
\9self.mouseButton = mouseButton\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end\
",["WindowButton.lua"] = "\
class \"WindowButton\" extends \"View\" {\
\9width = 9;\
\9height = 7;\
    isPressed = false;\
    backgroundObject = nil;\
    symbolObject = nil;\
    window = nil;\
}\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function WindowButton:initialise( ... )\
    self.super:initialise( ... )\
    \
    self:event( Event.MOUSE_DOWN, self.onMouseDown )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
    if self.onMouseUp then self:event( Event.MOUSE_UP, self.onMouseUp ) end\
end\
\
function WindowButton:initialiseCanvas()\
\9self.super:initialiseCanvas()\
\
    local backgroundObject = self.canvas:insert( Circle( 3, 2, 5, 5 ) )\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    -- local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height ) )\
\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    -- self.theme:connect( backgroundObject, \"topLeftRadius\", \"cornerRadius\" )\
\
\
\
    self.backgroundObject = backgroundObject\
end\
\
function WindowButton:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function WindowButton:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function WindowButton:setIsPressed( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function WindowButton:onGlobalMouseUp( event )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled and self:hitTestEvent( event ) then\
            return self.event:handleEvent( event )\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function WindowButton:onMouseDown( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end",["Circle.lua"] = "\
class \"Circle\" extends \"GraphicsObject\" {}\
\
--[[\
\9@static\
\9@desc Creates a rounded rectangle\
\9@param [number] x -- the x coordinate of the rectangle\
\9@param [number] y -- the y coordinate of the rectangle\
\9@param [number] width -- the width of the rectangle\
\9@param [number] height -- the height of the rectangle\
\9@param [number] radius -- the radius of the corners. of the top of the next parameter is defined, or top left if all 4 are\
]]\
function Circle:initialise( x, y, diameter )\
\9self.super:initialise( x, y, diameter, diameter )\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Circle:getFill()\
\9-- TODO: why is this commented out?\
\9-- if self.fill then return self.fill end\
\
\9local fill = {}\
\9local fillColour = self.fillColour\
\9local r = math.min( self.width, self.height ) / 2\
\9local radius = ( math.min( self.width, self.height ) + 1 ) / 2\
\9for y = 1, self.height do\
\9\9local ySqrd = ( y - radius )^2\
\9\9for x = 1, self.width do\
\9\9\9-- TODO: could probably make this faster by only square rooting once per y\
     \9\9local distance = ( ySqrd + ( x - radius )^2 )^0.5\
\9\9\9if distance <= r then\
\9\9\9\9fill[x] = fill[x] or {}\
\9\9\9\9fill[x][y] = true\
\9\9\9end\
\9\9end\
\9end\
\9return fill\
end",["ActionInterfaceEvent.lua"] = "\
class \"ActionInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.ACTION;\
\9sender = false; -- the view whose action it is\
}\
\
--[[\
\9@constructor\
\9@desc Creates a focus event from the arguments\
\9@param [View] sender -- the view whose action it is\
]]\
function ActionInterfaceEvent:initialise( sender )\
\9self.sender = sender\
end\
",["Rectangle.lua"] = "\
class \"Rectangle\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.LIGHT_GREY;\
}\
\
function Rectangle:initialise( x, y, width, height, fillColour ) -- @constructor( number x, number y, number width, number height, graphics.fillColour fillColour )\
\9self.super:initialise( x, y, width, height )\
\9self.fillColour = fillColour\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Rectangle:getFill()\
\9if self.fill then return self.fill end\
\
\9local fill = {}\
\9local height = self.height\
\9for x = 1, self.width do\
\9\9local fillX = {}\
\9\9for y = 1, height do\
\9\9\9fillX[y] = true\
\9\9end\
\9\9fill[x] = fillX\
\9end\
\
\9self.fill = fill\
\9return fill\
end",["Document.lua"] = "\
class \"Document\" {\
\9path = false;\
\9contents = false;\
\9readMode = \"r\";\
\9writeMode = \"w\";\
\9isModified = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a document from the given path\
\9@param [string] path -- the path of the document\
]]\
function Document:initialise( path )\
\9self.path = path\
\
\9local rawContents, err = self:read()\
\9if rawContents then\
\9\9local contents, err = self:parse( rawContents )\
\9\9if contents then\
\9\9\9self.contents = contents\
\9\9end\
\9end\
\
\9if err then\
\9\9self:onError( err )\
\9end\
end\
\
--[[\
\9@static\
\9@desc Opens a file and sets it as the application's active document, opening a file dialouge if neccesary. If there was an error the application's active document will not be changed. Simply use Document( path ) if you want to open a document but not set it as active.\
\9@param [string] path -- the path of the document\
\9@return [Document] document -- the opened document\
]]\
function Document.open( path )\
\9local function f( path )\
\9\9local document = Document( path )\
\9\9if document.contents then\
\9\9\9local oldDocument = Document.application.document\
\9\9\9if oldDocument then\
\9\9\9\9oldDocument:close( function( isClosed )\
\9\9\9\9\9if isClosed then Document.application.document = document end\
\9\9\9\9end )\
\9\9\9else\
\9\9\9\9Document.application.document = document\
\9\9\9end\
\9\9end\
\9end\
\
\9if path then\
\9\9f( path )\
\9else \
\9\9-- TODO: open file dialouge\
\9\9f( \"test.txt\" )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Reads the raw contents from the path.\
\9@return [string] rawContents -- the raw contents. return false if there was an error.\
\9@return [string] err -- the error message if rawContents is false.\
]]\
function Document:read()\
\9local path = self.path\
\9if not fs.exists( path ) then return false, \"Document path does not exist.\" end\
\9if fs.isDir( path ) then return false, \"Document path is a folder.\" end\
\
\9local h = fs.open( path, self.readMode )\
\9if not h then return false, \"Document path unreadable.\" end\
\9if not h.readAll then return false, \"Invalid read mode (doesn't support readAll).\" end\
\
\9local rawContents = h.readAll()\
\9if not rawContents then return false, \"Document has nil contents.\" end\
\9h.close()\
\
\9return rawContents\
end\
\
--[[\
\9@instance\
\9@desc Parses the raw string from the document. When subclassing you MUST override this! (what's the point of subclassing otherwise?)\
\9@param [string] rawContents -- the contents of the document\
\9@return contents -- the parsed contents. return false if rawContents is invalid.\
\9@return [string] err -- the error message if rawContents is invalid. this is REQUIRED if contents is returned as false, be helpful to your users.\
]]\
function Document:parse( rawContents )\
\9return rawContents\
end\
\
--[[\
\9@instance\
\9@desc Called when there was an error reading or writing the document. By default makes the application show an alert box. Override this if you want to change that.\
\9@param [string] err -- a description of the error encountered\
]]\
function Document:onError( err )\
\9-- TODO: alert window\
\9error( err )\
end\
\
function Document:setContents( contents )\
\9self.contents = contents\
\9if self.hasInitialised then\
\9\9self.isModified = true\
\9end\
end\
\
\
--[[\
\9@instance\
\9@desc Saves the document's contents to it's path. Calls :write with self.path\
\9@return [string/nil] err -- the error message if there was an issue with saving, nil otherwise.\
]]\
function Document:save()\
\9local err = self:write( self.path )\
\9if not err then\
\9\9self.isModified = false\
\9end\
\9return err\
end\
\
--[[\
\9@instance\
\9@desc Saves the document's contents to the given path.\
\9@param [string] path -- the path to save to\
\9@return [string/nil] err -- the error message if there was an issue with saving, nil otherwise.\
]]\
function Document:saveAs( path )\
\9return self:write( path )\
end\
\
--[[\
\9@instance\
\9@desc Serialises the document's contents to it's raw form for saving. When subclassing you MUST override this! (what's the point of subclassing otherwise?)\
\9@param [string] contents -- the contents to serialise (don't asume it's equal to self.contents)\
\9@return serialisedContents -- the serialised contents. return false if there was an eror.\
\9@return [string] err -- the error message if there was an issue in serialising. this is REQUIRED if contents is returned as false, be helpful to your users.\
]]\
function Document:serialise( contents )\
\9return contents\
end\
\
Document:alias( \"serialize\", \"serialise\" )\
\
--[[\
\9@instance\
\9@desc Writes the document's serialised contents to the given path.\
\9@param [string] path -- the path to save to\
\9@return [string/nil] err -- the error message if there was an issue with saving, nil otherwise.\
]]\
function Document:write( path )\
\9if fs.exists( path ) then\
\9\9if fs.isReadOnly( path ) then return \"Document path is read only.\" end\
\9\9if self.path ~= path and not self:onOverwrite( path ) then return end\
\9\9if fs.isDir( path ) then fs.delete( path ) end\
\9end\
\
\9local h = fs.open( path, self.writeMode )\
\9if not h then return \"Document path unwritable.\" end\
\9if not h.write then return false, \"Invalid read mode (doesn't support write).\" end\
\
\9local serialisedContents, err = self:serialise( self.contents )\
\9if not serialisedContents then return err end\
\
\9h.write(serialisedContents)\
\9h.close()\
end\
\
--[[\
\9@instance\
\9@desc Called when the path being written to already exists (but not when it's the document's own path). By default makes the application show an alert box. Override this if you want to change that.\
\9@param [string] path -- the path being overwritten\
]]\
function Document:onOverwrite( path )\
\9-- TODO: alert window\
\9error( \"Already exists: \" .. path )\
end\
\
--[[\
\9@instance\
\9@desc Tries to close the document, prompting the user (calling :onClose) if it's been modified\
\9@param [function( [boolean] isClosed )] callback -- the callback to call either after it was closed or the user cancelled. the argument is true if the document was closed, false it's still open\
]]\
function Document:close( callback )\
\9if not self.isModified then\
\9\9self.application.document = false\
\9\9callback( true )\
\9else\
\9\9self:onClose( function( isClosed ) \
\9\9\9if isClosed then self.application.document = false end\
\9\9\9callback( isClosed )\
\9\9end )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Called when the user is asked whether they want to close and save their document. By default makes the application show an alert box. Override this if you want to change that.\
\9@param [function( [boolean] isClosed )] callback -- the callback to call either after it was closed or the user cancelled. the argument is true if the document was closed, false it's still open\
]]\
function Document:onClose( callback )\
\9-- self:save()\
\9callback( false )\
end",["RoundedRectangle.lua"] = "\
-- draws a corner with the given radius for the corner given\
local function corner( fill, width, height, radius, position ) -- position is a byte. first bit is 0 if top, second bit is 0 if left\
\9if radius <= 0 then return end\
\9\
\9local minDistance = radius\
\9radius = radius + 0.5 -- doing this seems to magically make them look much better\
\
\9local centerX = (bit.band( position, 2 ) == 0) and radius or width - radius + 1\
\9local centerY = (bit.band( position, 1 ) == 0) and radius or height - radius + 1\
\9local minX = (bit.band( position, 2 ) == 0) and 1 or width - minDistance + 1\
\9local minY = (bit.band( position, 1 ) == 0) and 1 or height - minDistance + 1\
\
\9for x = minX, minX + radius - 1 do\
\9\9fill[x] = fill[x] or {}\
\9\9local xDistance = ( x - centerX ) ^ 2\
\9\9for y = minY, minY + radius - 1 do\
\9\9\9local distance = ( xDistance + ( y - centerY) ^ 2 ) ^ 0.5\
\9\9\9if distance <= minDistance then\
\9\9\9\9fill[x][y] = true\
\9\9\9end\
\9\9end\
\9end\
end\
\
class \"RoundedRectangle\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.RED;\
\
\9topLeftRadius = 1;\
\9topRightRadius = 1;\
\9bottomLeftRadius = 1;\
\9bottomRightRadius = 1;\
}\
\
--[[\
\9@static\
\9@desc Creates a rounded rectangle\
\9@param [number] x -- the x coordinate of the rectangle\
\9@param [number] y -- the y coordinate of the rectangle\
\9@param [number] width -- the width of the rectangle\
\9@param [number] height -- the height of the rectangle\
\9@param [number] topLeftRadius -- the radius of the corners. of the top of the next parameter is defined, or top left if all 4 are\
\9@param [number] topRightRadius -- the radius of the bottom corners or top right if all 4 are\
\9@param [number] bottomLeftRadius -- the radius of the bottom left corner\
\9@param [number] bottomRightRadius -- the radius of the bottom right corner\
]]\
function RoundedRectangle:initialise( x, y, width, height, fillColour, outlineColour, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius )\
\9self.super:initialise( x, y, width, height )\
\9self.fillColour = fillColour or Graphics.colours.TRANSPARENT\
\9self.outlineColour = outlineColour or Graphics.colours.TRANSPARENT\
\9topLeftRadius = topLeftRadius or 0\
\9self.topLeftRadius = topLeftRadius\
\9self.topRightRadius = topRightRadius or topLeftRadius\
\9self.bottomLeftRadius = bottomLeftRadius or topRightRadius or topLeftRadius\
\9self.bottomRightRadius = bottomRightRadius or bottomLeftRadius or topRightRadius or topLeftRadius\
end\
\
--[[\
\9@instance\
\9@desc Sets the radius of both sides\
\9@param [number] radius -- the new radius\
\9@return [type] returnedValue -- description\
]]\
function RoundedRectangle:setRadius( radius )\
\9self.topLeftRadius = radius\
\9self.topRightRadius = radius\
\9self.bottomLeftRadius = radius\
\9self.bottomRightRadius = radius\
end\
\
function RoundedRectangle:setTopLeftRadius( radius )\
\9if radius then self.topLeftRadius = math.floor( radius ) end\
end\
\
function RoundedRectangle:setTopRightRadius( radius )\
\9if radius then self.topRightRadius = math.floor( radius ) end\
end\
\
function RoundedRectangle:setBottomLeftRadius( radius )\
\9if radius then self.bottomLeftRadius = math.floor( radius ) end\
end\
\
function RoundedRectangle:setBottomRightRadius( radius )\
\9if radius then self.bottomRightRadius = math.floor( radius ) end\
end\
\
function RoundedRectangle:setLeftRadius( radius )\
\9if radius then\
\9\9self.bottomLeftRadius = math.floor( radius )\
\9\9self.topLeftRadius = math.floor( radius )\
\9end\
end\
\
function RoundedRectangle:setRightRadius( radius )\
\9if radius then\
\9\9self.bottomRightRadius = math.floor( radius )\
\9\9self.topRightRadius = math.floor( radius )\
\9end\
end\
\
function RoundedRectangle:setTopRadius( radius )\
\9if radius then\
\9\9self.topLeftRadius = math.floor( radius )\
\9\9self.topRightRadius = math.floor( radius )\
\9end\
end\
\
function RoundedRectangle:setBottomRadius( radius )\
\9if radius then\
\9\9self.bottomLeftRadius = math.floor( radius )\
\9\9self.bottomRightRadius = math.floor( radius )\
\9end\
end\
\
function RoundedRectangle:getRadius( radius )\
\9return math.max( self.topLeftRadius, self.topRightRadius, self.bottomLeftRadius, self.bottomRightRadius )\
end\
\
function RoundedRectangle:getLeftRadius( radius )\
\9return math.max( self.topLeftRadius, self.bottomLeftRadius )\
end\
\
function RoundedRectangle:getRightRadius( radius )\
\9return math.max( self.topRightRadius, self.bottomRightRadius )\
end\
\
function RoundedRectangle:getTopRadius( radius )\
\9return math.max( self.topLeftRadius, self.topRightRadius )\
end\
\
function RoundedRectangle:getBottomRadius( radius )\
\9return math.max( self.bottomLeftRadius, self.bottomRightRadius )\
end\
\
\
--[[\
    @instance\
    @desc Gets the pixels to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function RoundedRectangle:getFill()\
\9if self.fill then return self.fill end\
\
\9local fill = {}\
\
\9local topLeftRadius = self.topLeftRadius\
\9local topRightRadius = self.topRightRadius\
\9local bottomLeftRadius = self.bottomLeftRadius\
\9local bottomRightRadius = self.bottomRightRadius\
\
\9local width, height = self.width, self.height\
\
\9corner( fill, width, height, topLeftRadius, 0 )\
\9corner( fill, width, height, topRightRadius, 2 )\
\9corner( fill, width, height, bottomLeftRadius, 1 )\
\9corner( fill, width, height, bottomRightRadius, 3 )\
\
\9local maxTopRadius = math.max( topLeftRadius, topRightRadius )\
\9for x = topLeftRadius, self.width - topRightRadius do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = 1, maxTopRadius do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9local maxBottomRadius = math.max( bottomLeftRadius, bottomRightRadius )\
\9for x = bottomLeftRadius, self.width - bottomRightRadius do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = self.height - maxBottomRadius + 1, self.height do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9for x = 1, self.width do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = maxTopRadius + 1, self.height - maxBottomRadius do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9self.fill = fill\
\9return fill\
end",["ThemeChangedInterfaceEvent.lua"] = "\
class \"ThemeChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.THEME_CHANGED;\
\9newThemeName = false;\
\9oldThemeName = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a theme changed event from the arguments\
\9@param newThemeName -- the theme that is now active\
\9@param oldThemeName -- the theme that was previously active\
]]\
function ThemeChangedInterfaceEvent:initialise( newThemeName, oldThemeName )\
\9self.newThemeName = newThemeName\
\9self.oldThemeName = oldThemeName\
end\
",["MathParser.lua"] = "\
local symbols = {\
\9[\"+\"] = true;\
\9[\"-\"] = true;\
\9[\"*\"] = true;\
\9[\"/\"] = true;\
\9[\"(\"] = true;\
\9[\")\"] = true;\
\9[\",\"] = true;\
\9[\"^\"] = true;\
\9[\"%\"] = true;\
}\
\
local operatorLevels = {\
\9[\"+\"] = 1;\
\9[\"-\"] = 1;\
\9[\"*\"] = 2;\
\9[\"/\"] = 2;\
\9[\"%\"] = 2;\
\9[\"^\"] = 3;\
}\
\
local functionParameterCounts = {\
\9min = 2;\
\9max = 2;\
\9sqrt = 1;\
\9sin = 1;\
\9cos = 1;\
\9tan = 1;\
\9abs = 1;\
\9random = 2;\
\9pow = 2;\
\9exp = 1;\
\9floor = 1;\
\9ceil = 1;\
\9log = 1;\
\9ran = 0;\
\9degrees = 1;\
\9radians = 1;\
}\
\
local functions = {\
\9min = math.min;\
\9max = math.max;\
\9sqrt = math.sqrt;\
\9sin = math.sin;\
\9cos = math.cos;\
\9tan = math.tan;\
\9abs = math.abs;\
\9random = math.random;\
\9pow = math.pow;\
\9exp = math.exp;\
\9floor = math.floor;\
\9ceil = math.ceil;\
\9log = math.log;\
\9ran = math.random;\
\9degrees = function( n )\
\9\9return n * 180 / math.pi\
\9end;\
\9radians = function( n )\
\9\9return n / 180 * math.pi\
\9end;\
}\
\
local allowedIndices = { left = true, right = true, top = true, bottom = true, width = true, height = true }\
\
local parse, eval = nil, {}\
\
local function getpos( token )\
\9return token and \"[\" .. token.pos .. \"]: \"\
end\
\
local function getClosingBracket( tokens, pos )\
\9local level = 1\
\9while pos <= #tokens do\
\9\9if tokens[pos].type == \"symbol\" and tokens[pos].value == \"(\" then\
\9\9\9level = level + 1\
\9\9elseif tokens[pos].type == \"symbol\" and tokens[pos].value == \")\" then\
\9\9\9level = level - 1\
\9\9\9if level == 0 then\
\9\9\9\9return pos\
\9\9\9end\
\9\9end\
\9\9pos = pos + 1\
\9end\
end\
\
local function getBracketContents( tokens, start )\
\9local close = getClosingBracket( tokens, start )\
\9if close then\
\9\9local t = {}\
\9\9for i = 1, close - start do\
\9\9\9t[#t + 1] = tokens[start]\
\9\9\9table.remove( tokens, start )\
\9\9end\
\9\9table.remove( tokens, start )\
\9\9return t\
\9end\
end\
\
local function lex( str )\
\9local tokens = {}\
\9local pos = 1\
\9local lpos = 1\
\9local function push( t, v )\
\9\9tokens[#tokens + 1] = {\
\9\9\9type = t;\
\9\9\9value = v;\
\9\9\9pos = lpos;\
\9\9}\
\9end\
\9while pos <= #str do\
\9\9local c = str:sub( pos, pos )\
\9\9if str:find( \"^%d*%.?%d+\", pos ) then\
\9\9\9local num = str:match( \"^%d*%.?%d+\", pos )\
\9\9\9pos = pos + #num\
\9\9\9local exp = str:match( \"^e%-?%d+\", pos )\
\9\9\9if exp then\
\9\9\9\9pos = pos + #exp\
\9\9\9end\
\9\9\9local percentage = false\
\9\9\9if str:sub( pos, pos ) == \"%\" then\
\9\9\9\9percentage = true\
\9\9\9\9pos = pos + 1\
\9\9\9end\
\9\9\9local n = tonumber( num )\
\9\9\9if exp then\
\9\9\9\9n = n * 10 ^ tonumber( exp )\
\9\9\9end\
\9\9\9if percentage then\
\9\9\9\9push( \"percentage\", n / 100 )\
\9\9\9else\
\9\9\9\9push( \"constant\", n )\
\9\9\9end\
\9\9elseif c:find \"%s\" then\
\9\9\9pos = pos + #str:match( \"^%s+\", pos  )\
\9\9elseif c == \".\" then\
\9\9\9push \"dot\"\
\9\9\9pos = pos + 1\
\9\9elseif c:find \"[a-zA-Z_]\" then\
\9\9\9local word = str:match( \"^[_%w]+\", pos )\
\9\9\9push( \"word\", word )\
\9\9\9pos = pos + #word\
\9\9elseif symbols[c] then\
\9\9\9push( \"symbol\", c )\
\9\9\9pos = pos + 1\
\9\9else\
\9\9\9error( \"shit\", 0 ) -- more descriptive error? :P\
\9\9end\
\9\9lpos = pos\
\9end\
\9return tokens\
end\
\
local function parseRelativeIndexes( tokens )\
\9local i = 1\
\9while i <= #tokens do\
\9\9if tokens[i].type == \"dot\" then\
\9\9\9if not tokens[i-1] or tokens[i-1].type ~= \"word\" then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected super before '.', got \" .. ( tokens[i-1] and tokens[i-1].type or \"nothing\" ), 0 )\
\9\9\9end\
\9\9\9if not tokens[i+1] or tokens[i+1].type ~= \"word\" then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected super after '.' (trying to index \" .. tokens[i-1].value .. \"), got \" .. ( tokens[i-1] and tokens[i-1].type or \"nothing\" ), 0 )\
\9\9\9end\
\9\9\9tokens[i-1].type = \"relative\"\
\9\9\9local index = string.lower( tokens[i+1].value )\
\9\9\9if not allowedIndices[index] then\
\9\9\9\9error( \"Illegal relative index: \" .. index .. \". Possible indices are: left, right, top, bottom, width or height.\", 0 )\
\9\9\9end\
\9\9\9tokens[i-1].value = {\
\9\9\9\9parent = tokens[i-1].value;\
\9\9\9\9index = index;\
\9\9\9}\
\9\9\9table.remove( tokens, i )\
\9\9\9table.remove( tokens, i )\
\9\9end\
\9\9i = i + 1\
\9end\
end\
\
local function parseFunctionCalls( tokens )\
\9local i = 1\
\9while i <= #tokens do\
\9\9if tokens[i].type == \"word\" and tokens[i + 1] and tokens[i + 1].type == \"symbol\" and tokens[i + 1].value == \"(\" then\
\9\9\9local content = getBracketContents( tokens, i + 2 )\
\9\9\9if content then\
\9\9\9\9table.remove( tokens, i + 1 )\
\
\9\9\9\9local parameters = {}\
\9\9\9\9if content[1] then\
\9\9\9\9\9parameters[1] = {}\
\9\9\9\9end\
\
\9\9\9\9for p = 1, #content do\
\9\9\9\9\9if content[p].type == \"symbol\" and content[p].value == \",\" then\
\9\9\9\9\9\9parameters[#parameters + 1] = {}\
\9\9\9\9\9else\
\9\9\9\9\9\9parameters[#parameters][#parameters[#parameters] + 1] = content[p]\
\9\9\9\9\9end\
\9\9\9\9end\
\
\9\9\9\9for i = 1, #parameters do\
\9\9\9\9\9if #parameters[i] == 0 then\
\9\9\9\9\9\9error( getpos( tokens[i] ) .. \"function parameter is empty\", 0 )\
\9\9\9\9\9end\
\9\9\9\9\9parse( parameters[i] )\
\9\9\9\9end\
\
\9\9\9\9tokens[i].type = \"call\"\
\9\9\9\9tokens[i].value = {\
\9\9\9\9\9func = tokens[i].value;\
\9\9\9\9\9parameters = parameters;\
\9\9\9\9}\
\9\9\9else\
\9\9\9\9error( getpos( tokens[i + 1] ) .. \"expected ')' to close '('\", 0 )\
\9\9\9end\
\9\9end\
\9\9i = i + 1\
\9end\
end\
\
local function parseBrackets( tokens )\
\9local i = 1\
\9while i <= #tokens do\
\9\9if tokens[i].type == \"symbol\" and tokens[i].value == \"(\" then\
\9\9\9local contents = getBracketContents( tokens, i + 1 )\
\9\9\9if contents then\
\9\9\9\9tokens[i] = {\
\9\9\9\9\9type = \"bracket\";\
\9\9\9\9\9value = parse( contents );\
\9\9\9\9\9pos = tokens[i].pos;\
\9\9\9\9}\
\9\9\9else\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected ')' to close '('\", 0 )\
\9\9\9end\
\9\9elseif tokens[i].type == \"symbol\" and tokens[i].value == \")\" then\
\9\9\9error( getpos( tokens[i] ) .. \"unexpected ')' with no opening '('\", 0 )\
\9\9else\
\9\9\9i = i + 1\
\9\9end\
\9end\
end\
\
local function parseUnaryMinuses( tokens )\
\9for i = #tokens, 1, -1 do\
\9\9if tokens[i].type == \"symbol\" and tokens[i].value == \"-\" and ( not tokens[i-1] or tokens[i-1].type == \"symbol\" ) then\
\9\9\9local n = tokens[i+1]\
\9\9\9if not n or n.type == \"symbol\" then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected constant (number) or percentage after '-'\", 0 )\
\9\9\9end\
\9\9\9tokens[i].type = \"constant\"\
\9\9\9tokens[i].value = -1\
\9\9\9table.insert( tokens, i + 1, {\
\9\9\9\9type = \"symbol\";\
\9\9\9\9value = \"*\";\
\9\9\9\9pos = tokens[i].pos;\
\9\9\9} )\
\9\9end\
\9end\
end\
\
local function parseMathConstants( tokens )\
\9for i = 1, #tokens do\
\9\9if tokens[i].type == \"word\" and tokens[i].value:lower() == \"pi\" then\
\9\9\9tokens[i].type = \"constant\"\
\9\9\9tokens[i].value = math.pi\
\9\9elseif tokens[i].type == \"word\" and tokens[i].value:lower() == \"phi\" then\
\9\9\9tokens[i].type = \"constant\"\
\9\9\9tokens[i].value = 1.61803398875 -- can support 2 extra numbers on the end, checked in lua prompt, need to get more precise version\
\9\9end\
\9end\
end\
\
function parse( tokens )\
\9if #tokens == 0 then\
\9\9error( \"no values in tokens\", 0 )\
\9end\
\9parseFunctionCalls( tokens )\
\9parseBrackets( tokens )\
\9parseUnaryMinuses( tokens )\
\9for i = 1, #tokens do\
\9\9if i % 2 == 1 and tokens[i].type == \"symbol\" then\
\9\9\9error( getpos( tokens[i] ) .. \"unexpected symbol, expected operand\", 0 )\
\9\9elseif i % 2 == 0 and tokens[i].type ~= \"symbol\" then\
\9\9\9log( textutils.serialize( tokens ) )\
\9\9\9error( getpos( tokens[i] ) .. \"expected symbol between operands\", 0 )\
\9\9end\
\9\9if tokens[i].type == \"symbol\" and tokens[i].value == \",\" then\
\9\9\9error( getpos( tokens[i] ) .. \"unexpected ','\", 0 )\
\9\9end\
\9end\
\9if #tokens % 2 == 0 then\
\9\9error( getpos( tokens[#tokens] ) .. \"expected operand\", 0 )\
\9end\
\9return tokens\
end\
\
local function checkFunctionCalls( tokens )\
\9for i = 1, #tokens do\
\9\9if tokens[i].type == \"call\" then\
\9\9\9local f = tokens[i].value.func\
\9\9\9local count = functionParameterCounts[f]\
\9\9\9if not count then\
\9\9\9\9error( getpos( tokens[i] ) .. \"no such function '\" .. f .. \"'\", 0 )\
\9\9\9end\
\9\9\9local p = tokens[i].value.parameters\
\9\9\9if #p ~= count then\
\9\9\9\9error( getpos( tokens[i] ) .. \"expected \" .. count .. \" parameters, got \" .. #p, 0 )\
\9\9\9end\
\9\9\9for i = 1, count do\
\9\9\9\9checkFunctionCalls( p[i] )\
\9\9\9end\
\9\9\9tokens[i].value.func = functions[f]\
\9\9elseif tokens[i].type == \"bracket\" then\
\9\9\9checkFunctionCalls( tokens[i].value )\
\9\9end\
\9end\
\9return tokens\
end\
\
local function isKnownValue( t )\
\9if type( t ) == \"number\" then return true end\
\9if t.type == \"bracket\" then\
\9\9for i = 1, #t.value do\
\9\9\9if type( t.value[i] ) ~= \"string\" and not isKnownValue( t.value[i] ) then\
\9\9\9\9return false\
\9\9\9end\
\9\9end\
\9\9return true\
\9elseif t.type == \"call\" then\
\9\9for p = 1, #t.value.parameters do\
\9\9\9for i = 1, #t.value.parameters[p] do\
\9\9\9\9if type( t.value.parameters[p][i] ) ~= \"string\" and not isKnownValue( t.value.parameters[p][i] ) then\
\9\9\9\9\9return false\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9return true\
\9end\
\9return t.type == \"constant\"\
end\
\
local function groupByLevel( terms, operators, level )\
\9local i = 1\
\9while i <= #operators do\
\9\9local t = { terms[i] }\
\9\9while operatorLevels[operators[i]] == level do\
\9\9\9t[#t + 1] = operators[i]\
\9\9\9table.remove( operators, i )\
\9\9\9t[#t + 1] = terms[i + 1]\
\9\9\9table.remove( terms, i + 1 )\
\9\9end\
\9\9if #t > 1 then\
\9\9\9terms[i] = {\
\9\9\9\9type = \"bracket\";\
\9\9\9\9pos = terms[i].pos;\
\9\9\9\9value = t;\
\9\9\9}\
\9\9end\
\9\9i = i + 1\
\9end\
end\
\
local function group( tokens )\
\9local levels = {}\
\9for i = 1, #tokens do\
\9\9tokens[i].pos = nil\
\9\9if tokens[i].type == \"symbol\" then\
\9\9\9levels[operatorLevels[tokens[i].value]] = true\
\9\9elseif tokens[i].type == \"bracket\" then\
\9\9\9tokens[i].value = group( tokens[i].value )\
\9\9elseif tokens[i].type == \"call\" then\
\9\9\9local p = tokens[i].value.parameters\
\9\9\9for i = 1, #p do\
\9\9\9\9p[i] = group( p[i] )\
\9\9\9end\
\9\9end\
\9end\
\9local terms = {}\
\9local operators = {}\
\9for i = 1, #tokens do\
\9\9local t = i % 2 == 1 and terms or operators\
\9\9t[#t + 1] = i % 2 == 0 and tokens[i].value or tokens[i]\
\9end\
\
\9if next( levels, next( levels ) ) then\
\9\9groupByLevel( terms, operators, 3 )\
\9\9groupByLevel( terms, operators, 2 )\
\9end\
\
\9local tokens = { terms[1] }\
\9for i = 1, #operators do\
\9\9tokens[#tokens + 1] = operators[i]\
\9\9tokens[#tokens + 1] = terms[i + 1]\
\9end\
\
\9return tokens\
end\
\
function eval.knownList( list )\
\9local n = eval.knownValue( list[1] )\
\9for i = 1, ( #list - 1 ) / 2 do\
\9\9local n2 = eval.knownValue( list[i * 2 + 1] )\
\9\9local op = list[i * 2]\
\9\9if op == \"+\" then\
\9\9\9n = n + n2\
\9\9elseif op == \"-\" then\
\9\9\9n = n - n2\
\9\9elseif op == \"*\" then\
\9\9\9n = n * n2\
\9\9elseif op == \"/\" then\
\9\9\9n = n / n2\
\9\9elseif op == \"%\" then\
\9\9\9n = n % n2\
\9\9elseif op == \"^\" then\
\9\9\9n = n ^ n2\
\9\9end\
\9end\
\9return n\
end\
\
function eval.knownValue( token )\
\9if type( token ) == \"number\" then\
\9\9return math.floor( token + .5 )\
\9elseif token.type == \"bracket\" then\
\9\9return math.floor( eval.knownList( token.value ) + .5 )\
\9elseif token.type == \"call\" then\
\9\9local p = token.value.parameters\
\9\9for i = 1, #p do\
\9\9\9p[i] = eval.knownList( p[i] )\
\9\9end\
\9\9return math.floor( token.value.func( unpack( p ) ) + .5 )\
\9elseif token.type == \"constant\" then\
\9\9return math.floor( token.value + .5 )\
\9else\
\9\9error( \"Unknown value for token type: \" .. tostring( token.type ), 0 )\
\9end\
end\
\
class \"MathParser\" {} -- I think it's best just to make it a class so it's loaded properly (when we make the loader). Happy to change it though.\
\
function MathParser.parseString( str )\
\9local tokens = lex( str )\
\9parseRelativeIndexes( tokens )\
\9parseMathConstants( tokens )\
\9return group( checkFunctionCalls( parse( tokens ) ) )\
end\
\
function MathParser.simplify( tokens )\
\9for i = 1, #tokens do\
\9\9if type( tokens[i] ) ~= \"string\" then\
\9\9\9if isKnownValue( tokens[i] ) then\
\9\9\9\9tokens[i] = eval.knownValue( tokens[i] )\
\9\9\9elseif tokens[i].type == \"bracket\" then\
\9\9\9\9tokens[i].value = MathParser.simplify( tokens[i].value )\
\9\9\9elseif tokens[i].type == \"call\" then\
\9\9\9\9local p = tokens[i].value.parameters\
\9\9\9\9for i = 1, #p do\
\9\9\9\9\9p[i] = MathParser.simplify( p[i] )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9for i = 1, #tokens do\
\9\9if type( tokens[i] ) == \"table\" and tokens[i].type == \"constant\" then\
\9\9\9tokens[i] = tokens[i].value\
\9\9end\
\9end\
\9for i = 1, #tokens do\
\9\9if i % 2 == 1 and not isKnownValue( tokens[i] ) then\
\9\9\9return tokens\
\9\9end\
\9end\
\9return { eval.knownList( tokens ) }\
end\
\
-- solve percentages\
-- plug in relative indexes\
function MathParser.resolve( tokens, object, property, references )\
\9references = references or {}\
\9local parent = object.parent\
\9local parentSize = parent and ( ( property == \"left\" or property == \"right\" or property == \"width\" ) and parent.width or parent.height ) or 0\
\9local t = {}\
\9for i = 1, #tokens do\
\9\9if type( tokens[i] ) == \"number\" or type( tokens[i] ) == \"string\" then -- these will be raw numbers\
\9\9\9t[#t + 1] = tokens[i]\
\9\9elseif tokens[i].type == \"constant\" then -- these will be raw numbers\
\9\9\9t[#t + 1] = tokens[i].value\
\9\9elseif tokens[i].type == \"percentage\" then -- these will be raw numbers\
\9\9\9t[#t + 1] = tokens[i].value * parentSize\
\9\9elseif tokens[i].type == \"bracket\" then -- this will be a bracket token\
\9\9\9t[#t + 1] = {\
\9\9\9\9type = \"bracket\";\
\9\9\9\9value = MathParser.resolve( tokens[i].value, object, property, references )\
\9\9\9}\
\9\9elseif tokens[i].type == \"call\" then -- this will be a call token\
\9\9\9local parameters = {}\
\9\9\9for i, v in ipairs( tokens[i].value.parameters ) do\
\9\9\9\9parameters[i] = MathParser.resolve( v, object, property, references )\
\9\9\9end\
\9\9\9t[#t + 1] = {\
\9\9\9\9type = \"call\";\
\9\9\9\9value = {\
\9\9\9\9\9func = tokens[i].value.func;\
\9\9\9\9\9parameters = parameters;\
\9\9\9\9}\
\9\9\9}\
\9\9elseif tokens[i].type == \"relative\" then -- this will be a bracket token\
\9\9\9local identifier, index = token.value.parent, token.value.index\
\9\9\9local value = { 0 }\
\
\9\9\9if identifier == \"parent\" then\
\9\9\9\9error( \"Constraint can not use 'parent' for a relative value. Use percentages for getting parent width or height (100%)\", 0 )\
\9\9\9elseif identifier == \"self\" and property == index then\
\9\9\9\9error( \"Cannot use recursive constraint index. (tried to use self.\" .. index .. \" within self.\" .. index .. \")\", 0 )\
\9\9\9else\
\9\9\9\9references[identifier] = true\
\9\9\9\9local view = identifier == \"self\" and object or parent:findChild( identifier, false )\
\9\9\9\9if view then\
\9\9\9\9\9value = view:parseConstraint( index ) or value\
\9\9\9\9else\
\9\9\9\9\9error( \"Could not find view '\" .. identifier .. \"'\", 0 )\
\9\9\9\9end\
\9\9\9end\
\9\9\9t[#t + 1] = {\
\9\9\9\9type = \"bracket\";\
\9\9\9\9value = value;\
\9\9\9}\
\9\9end\
\9end\
\9return t, references\
end\
\
function MathParser.eval( list )\
\9return eval.knownList( list )\
end",["Scrollbar.lua"] = "\
class \"Scrollbar\" extends \"View\" {\
\9width = 7;\
    isHorizontal = false;\
\9scrollerObject = nil;\
\9grabberObject = nil;\
    dragPoint = nil;\
}\
\
function Scrollbar:initialise( ... )\
\9self.super:initialise( ... )\
    -- self:event( Event.MOUSE_SCROLL, self.onMouseScroll )\
    self:event( Event.MOUSE_DOWN, self.onMouseDown )\
    self.event:connectGlobal( Event.MOUSE_DRAG, self.onGlobalMouseDrag )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Scrollbar:initialiseCanvas()\
    self.super:initialiseCanvas()\
\
    self.theme:connect( self.canvas, \"fillColour\" )\
\
    local scrollerObject = self.canvas:insert( RoundedRectangle( 2, 3, self.width - 2, 30 ) )\
    local grabberObject = self.canvas:insert( ScrollbarGrabber( 3, 3, self.width - 4, 30 ) )\
\
    self.theme:connect( scrollerObject, \"fillColour\", \"scrollerColour\" )\
    self.theme:connect( scrollerObject, \"outlineColour\" )\
    self.theme:connect( scrollerObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( grabberObject, \"fillColour\", \"grabberColour\" )\
\
    local position, size = self.scroller\
    -- local position, size = self:getScroller()\
    -- log( position )\
    -- log( size )\
    self.scrollerObject = scrollerObject\
    self.grabberObject = grabberObject\
end\
\
function Scrollbar:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function Scrollbar:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function Scrollbar:setIsPressed( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Gets and updates the size and location of the scroller\
    @return [number] position -- the position of the scroller\
    @return [number] size -- the size of the scroller\
]]\
function Scrollbar:getScroller( dontSetPosition )\
    local parent = self.parent\
    if not parent then\
        return 0, self.direction == \"vertical\" and self.height or self.width\
    end\
\
    local trayMargin = 2\
    local traySize = self.height - 2 * trayMargin\
\
    local frameSize, contentSize, contentScroll\
    frameSize = parent.height\
    local container = parent.container\
    contentSize = container.height\
    contentScroll = - parent.offsetY\
\
    local barSize = math.max( math.floor( traySize * frameSize / contentSize ), 1 )\
    local barPosition = math.ceil( traySize * contentScroll / contentSize )\
\
    local scrollerObject = self.scrollerObject\
    local grabberObject = self.grabberObject\
    scrollerObject.height = barSize\
    grabberObject.height = barSize\
    if not dontSetPosition then\
        local y = 1 + trayMargin - barPosition\
        scrollerObject.y = y\
        grabberObject.y = y\
    end\
\
    return barPosition, barSize\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Scrollbar:onGlobalMouseUp( event )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Scrollbar:onMouseDown( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
        local position, size = self:getScroller( true )\
        self.dragPoint = event.y + position - 1\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is dragged anywhere on screen. Moves the window if dragging\
    @param [Event] event -- the mouse drag event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Scrollbar:onGlobalMouseDrag( event )\
    if self.isPressed and self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        local oldRelative = event.relativeView\
        event:makeRelative( self )\
\
        local position, size = self:getScroller( true )\
        local traySize\
        position = event.y - self.dragPoint\
        traySize = self.height\
\
        position = math.max( math.min( position, traySize - size ), 0 )\
        local parent = self.parent\
        -- parent.offsetY = math.floor( position / traySize * parent.container.height )\
        -- scrollTo\
        parent:scrollTo( math.floor( position / traySize * parent.container.height ) )\
      \
        event:makeRelative( oldRelative )\
    end\
end",["VectorFont.lua"] = "\
class \"VectorFont\" extends \"Font\" {\
\9\
}",["KeyboardShortcutEvent.lua"] = "\
class \"KeyboardShortcutEvent\" extends \"Event\" {\
\9eventType = Event.KEYBOARD_SHORTCUT;\
\9keys = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a key event from the arguments\
\9@param [table] arguments -- the event arguments\
]]\
function KeyboardShortcutEvent:initialise( keys )\
\9self.keys = keys\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the keys in the given table match those of the event\
\9@param [table] keys -- a table of keys (key strings like { 'ctrl', 'a' })\
\9@param [type] arg2 -- description\
\9@param [type] arg3 -- description\
\9@return [type] returnedValue -- description\
]]\
function KeyboardShortcutEvent:matchesKeys( keys )\
\9local eventKeys = self.keys\
\9for i, keyString in ipairs( keys ) do\
\9\9if not eventKeys[keyString] then\
\9\9\9return false\
\9\9end\
\9end\
\
\9local eventKeysLength = 0\
\9for keyString, _ in pairs( eventKeys ) do\
\9\9eventKeysLength = eventKeysLength + 1\
\9end\
\
\9return eventKeysLength == #keys\
end",["Shader.lua"] = "\
class \"Shader\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.LIGHT_GREY;\
}\
\
function Shader:initialise( x, y, width, height, shader )\
\9self.super:initialise( x, y, width, height )\
\9self.shader = shader\
end\
--[[\
    @instance\
    @desc Draws a the graphics object to the canvas\
    @param [Canvas] canvas -- the canvas to draw to\
    @return self\
]]\
function Shader:drawTo( canvas )\
\9if self.isVisible then\
\9\9canvas:map( self.shader, self.x, self.y, self.width, self.height )\
\9end\
\9\
    return self\
end",["KeyboardShortcutManager.lua"] = "\
local keyStrings = {\
\9nil,\9\"1\", \9\"2\", \9\"3\",\9\"4\",\
\9\"5\", \9\"6\", \9\"7\", \9\"8\", \9\"9\",\
\9\"0\", \9\"-\", \9\"=\", \9\"backspace\",\"tab\",\
\9\"q\", \9\"w\", \9\"e\", \9\"r\",\9\"t\",\
\9\"y\",\9\"u\",\9\"i\",\9\"o\",\9\"p\",\
\9\"(\",\9\")\",\9\"enter\",\"ctrl\",\"a\",\
\9\"s\",\9\"d\",\9\"f\",\9\"g\",\9\"h\",\
\9\"j\",\9\"k\",\9\"l\",\9\";\",\9\"'\",\
\9\"`\",\9\"shift\",\"\\\\\",\9\"z\",\9\"x\",\
\9\"c\",\9\"v\",\9\"b\",\9\"n\",\9\"m\",\
\9\",\",\9\".\",\9\"/\",\9\"shift\",nil,\
\9\"alt\",\9nil,\9nil,\9\"f1\",\9\"f2\",\
\9\"f3\",\9\"f4\",\9\"f5\",\9\"f6\",\9\"f7\",\
\9\"f8\",\9\"f9\",\9\"f10\",\9[87] = \"f11\",\
\9[88] = \"f12\",\9[153] = \"ctrl\",\
\9[199] = \"home\",\9[207] = \"end\",\
\9[184] = \"alt\",\9[200] = \"up\",\
\9[203] = \"left\",\9[205] = \"right\",\
\9[208] = \"down\",\9[211] = \"delete\",\9\9\9\9\
\9[219] = \"ctrl\",\9[220] = \"ctrl\",\9\9\9\9\
}\
\
local keySymbols = {\
\9-- TODO: tab, left, right, up down, delete\
\9backspace = string.char( 144 );\
\9enter = string.char( 157 );\
\9ctrl = string.char( 141 );\
\9shift = string.char( 129 );\
\9alt = string.char( 143 );\
}\
\
class \"KeyboardShortcutManager\" {\
\9keysDown = {};\
\9keysUpdates = {};\
\9owner = nil;\
\9event = nil;\
}\
\
function KeyboardShortcutManager:initialise( owner )\
\9self.owner = owner\
\9self.event = EventManager( self )\
\9self.event:connectGlobal( Event.KEY_DOWN, self.onGlobalKeyDown )\
\9self.event:connectGlobal( Event.KEY_UP, self.onGlobalKeyUp )\
end\
\
function KeyboardShortcutManager:onGlobalKeyDown( event )\
\9local keyString = event.keyString\
\9if keyString then\
\9\9self.keysDown[keyString] = true\
\9\9self.keysUpdates[keyString] = os.clock()\
\9\9self.owner:schedule( self.onKeyTimeout, 10, self, keyString )\
\9\9return self:sendEvent()\
\9end\
end\
\
function KeyboardShortcutManager:onGlobalKeyUp( event )\
\9local keyString = event.keyString\
\9self.keysDown[keyString] = nil\
\9self.keysUpdates[keyString] = os.clock()\
end\
\
--[[\
\9@static\
\9@desc Returns the symbol for a keyString for places such as menus\
\9@return [string] keyString -- the string value of the key\
\9@return [string] symbol -- the symbol\
]]\
function KeyboardShortcutManager.symbol( keyString )\
\9return ( not keyString and \"\" or keySymbols[keyString] or keyString:upper() )\
end\
\
--[[\
\9@instance\
\9@desc Converts a keys API code to the common string value used throughout Silica\
\9@param [number] keyCode -- the numerical value of the key\
\9@return [string] keyString -- the string value of the key\
]]\
function KeyboardShortcutManager.convert( keyCode )\
\9return keyStrings[keyCode]\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the given key string is valid\
\9@param [string] keyString -- the string value of the key\
\9@return [boolean] isValid -- whether the key string is valid\
]]\
function KeyboardShortcutManager.isValid( keyString )\
\9if not keyString then return false end\
\9for i, _keyString in pairs( keyStrings ) do\
\9\9if _keyString == keyString then\
\9\9\9return true\
\9\9end\
\9end\
\9return false\
end\
\
--[[\
\9@instance\
\9@desc Send the keyboard shortcut event of the currently held keys\
]]\
function KeyboardShortcutManager:sendEvent()\
\9return self.owner.event:handleEvent( KeyboardShortcutEvent( self.keysDown ) )\
end\
\
--[[\
\9@instance\
\9@desc Fires 10 seconds after a key was pressed. If the key status hasn't changed it sets it to not be pressed.\
\9@param [string] keyString -- the key string\
]]\
function KeyboardShortcutManager:onKeyTimeout( keyString )\
\9if os.clock() - self.keysUpdates[keyString] >= 10 then\
\9\9self.keysDown[keyString] = nil\
\9\9self.keysUpdates[keyString] = os.clock()\
\9end\
end",["KeyDownEvent.lua"] = "\
class \"KeyDownEvent\" extends \"KeyEvent\" {\
\9eventType = Event.KEY_DOWN;\
}",["Path.lua"] = "\
local sin, cos, floor, min, max, abs, acos, PI = math.sin, math.cos, math.floor, math.min, math.max, math.abs, math.acos, math.pi\
\
local function round( num )\
\9return floor( num + 0.5 )\
end\
\
-- the next few functions are just taken from a site for bezier intersection, hence the terribly named variables. don't hate.\
local function sgn( n )\
\9return n < 0 and -1 or 1\
end\
\
local function sortSpecial( a )\
    local flip;\
    local temp;\
    \
    repeat\
        flip = false\
        for i = 1, #a - 1 do\
            if ( a[i+1] >= 0 and a[i] > a[i+1] ) or ( a[i] < 0 and a[i+1] >= 0 ) then\
\9\9\9\9flip = true\
\9\9\9\9temp = a[i]\
\9\9\9\9a[i] = a[i+1]\
\9\9\9\9a[i+1] = temp\
\9\9\9end\
\9\9end\
    until not flip\
\
\9return a\
end\
\
local function bezierCoeffs( P0, P1, P2, P3 )\
\9local Z = {};\
\9Z[1] = -P0 + 3 * P1 + -3 * P2 + P3; \
    Z[2] = 3 * P0 - 6 * P1 + 3 * P2;\
    Z[3] = -3 * P0 + 3 * P1;\
    Z[4] = P0;\
\9return Z;\
end\
\
local function cubicRoots( P )\
\
\9local a = P[1]\
\9local b = P[2]\
\9local c = P[3]\
\9local d = P[4]\
\9\
\9local A = b / a\
\9local B = c / a\
\9local C = d / a\
\
    local Q, R, D, S, T, Im -- ehm?\
\
    local Q = ( 3 * B - A ^ 2 )/9;\
    local R = ( 9 * A * B - 27 * C - 2 * A ^ 3 ) / 54;\
    local D = Q ^ 3 + R ^ 2;    -- polynomial discriminant\
\
    local t = {}\
\9\
    if D >= 0 then -- complex or duplicate roots\
    \9local v1, v2, third = R + D^.5, R - D^.5, 1 / 3\
        local T = sgn( v1 ) * abs( v1 ) ^ third\
        local S = sgn( v2 ) * abs( v2 ) ^ third\
\
        t[1] = A / -3 + ( S + T ) -- real root\
        t[2] = A / -3 - ( S + T ) / 2 -- real part of complex root\
        t[3] = A / -3 - ( S + T ) / 2 -- real part of complex root\
        local Im = abs( 3^.5 * ( S - T ) / 2 ) -- complex part of root pair   \
        \
        if Im ~= 0 then\
            t[2]=-1\
            t[3]=-1\
        end\
    else -- distinct real roots\
        local th = acos( R / (-( Q^3) )^.5 )\
        \
        t[1] = 2 * ( -Q )^.5 * cos( th / 3 ) - A / 3\
        t[2] = 2 * ( -Q )^.5 * cos( ( th + 2 * PI ) / 3 ) - A / 3\
        t[3] = 2 * ( -Q )^.5 * cos( ( th + 4 * PI ) / 3 ) - A / 3\
        local Im = 0.0\
    end\
    \
    -- discard out of spec roots\
\9for i = 1, 3 do\
        if t[i] < 0 or t[i] > 1 then\
       \9\9t[i] = -1\
       \9end\
\9end\
                \
\9-- sort but place -1 at the end\
    t = sortSpecial( t );\
    \
    return t;\
end\
\
local function getHorizontalLinearIntersectionPoint( points, y, line, minX, maxX )\
\9if abs( line.x1 - line.x2 ) < .00001 then\
\9\9if y >= min( line.y1, line.y2 ) - .00001 and y <= max( line.y1, line.y2 ) + .0001 then\
\9\9\9points[#points + 1] = floor( line.x1 + .5 )\
\9\9end\
\9else\
\9\9local m = ( line.y2 - line.y1 ) / ( line.x2 - line.x1 )\
\9\9local c = line.y1 - m * line.x1\
\9\9local x = ( y - c ) / m\
\9\9if x >= min( line.x1, line.x2 ) - .00001 and x <= max( line.x1, line.x2 ) + .0001 then\
\9\9\9points[#points + 1] = x\
\9\9end\
\9end\
end\
\
local function getVerticalLinearIntersectionPoint( points, x, line, minY, maxY )\
\9if abs( line.y1 - line.y2 ) < .00001 then\
\9\9if x >= math.min( line.x1, line.x2 ) - .00001 and x <= math.max( line.x1, line.x2 ) + .0001 then\
\9\9\9points[#points + 1] = floor( line.y1 + 0.5 )\
\9\9end\
\9else\
\9\9local m = ( line.y2 - line.y1 ) / ( line.x2 - line.x1 )\
\9\9local c = line.y1 - m * line.x1\
\9\9local y = m * x + c\
\9\9if y >= min( line.y1, line.y2 ) - .00001 and y <= max( line.y1, line.y2 ) + .0001 then\
\9\9\9points[#points + 1] = y\
\9\9end\
\9end\
end\
\
local function getHorizontalCurvedIntersectionPoints( points, y, line, minX, maxX )\
\9if not line.xCoefficients or not line.yCoefficients then\
\9\9line.xCoefficients = bezierCoeffs( line.x1, line.controlPoint1X, line.controlPoint2X, line.x2 )\
\9\9line.yCoefficients = bezierCoeffs( line.y1, line.controlPoint1Y, line.controlPoint2Y, line.y2 )\
\9end\
\
\9local xCoefficients = line.xCoefficients\
\9local yCoefficients = line.yCoefficients\
\
\9local yRoots = cubicRoots( { yCoefficients[1], yCoefficients[2], yCoefficients[3], yCoefficients[4] - y } )\
\
    for i = 1, 3 do\
        t = yRoots[i];\
        if t > 0 and t < 1 then\
\9        local x = xCoefficients[1] * t * t * t + xCoefficients[2] * t * t + xCoefficients[3] * t + xCoefficients[4];\
\9\9\9x = min( max( x, minX ), maxX )\
\9\9\9points[#points + 1] = x\
\9    end\
    end\
end\
\
local function getVerticalCurvedIntersectionPoints( points, x, line, minY, maxY )\
\9if not line.xCoefficients or not line.yCoefficients then\
\9\9line.xCoefficients = bezierCoeffs( line.x1, line.controlPoint1X, line.controlPoint2X, line.x2 )\
\9\9line.yCoefficients = bezierCoeffs( line.y1, line.controlPoint1Y, line.controlPoint2Y, line.y2 )\
\9end\
\
\9local xCoefficients = line.yCoefficients\
\9local yCoefficients = line.xCoefficients\
\
\9local yRoots = cubicRoots( { yCoefficients[1], yCoefficients[2], yCoefficients[3], yCoefficients[4] - x } )\
\
    for i = 1, 3 do\
        t = yRoots[i];\
        if t > 0 and t < 1 then\
\9        local y = xCoefficients[1] * t * t * t + xCoefficients[2] * t * t + xCoefficients[3] * t + xCoefficients[4];\
\9\9\9y = min( max( y, minY ), maxY )\
\9\9\9points[#points + 1] = y\
\9    end\
    end\
end\
\
local getLinearIntersectionPoint = getHorizontalLinearIntersectionPoint\
local getCurvedIntersectionPoints = getHorizontalCurvedIntersectionPoints\
\
class \"Path\" extends \"GraphicsObject\" {\
\9lines = {};\
\9defined = false; -- when true the path becomes immutable. set to true after :close is called\
\9width = 0;\
\9height = 0;\
\9x = 0;\
\9y = 0;\
\9currentX = 0;\
\9currentY = 0;\
\9outlinePoints = {}; -- the generic outline pixels used for fill and outline\
}\
\
--[[\
\9@constructor\
\9@desc Creates the start of a path\
\9@param [number] x -- the x coordinate\
\9@param [number] y -- the y coordinate\
\9@param [number] width -- the starting y coordinate\
\9@param [number] height -- the starting y coordinate\
\9@param [number] currentX -- the starting x coordinate\
\9@param [number] currentY -- the starting y coordinate\
]]\
function Path:initialise( x, y, width, height, currentX, currentY )\
\9self.super:initialise( x, y, width, height )\
\9self.fillColour = fillColour\
\9self.currentX = currentX or 1\
\9self.currentY = currentY or 1\
end\
\
--[[\
\9@instance\
\9@desc Moves the current position to the given coordinates.\
\9@param [number] x -- the x coordinate to move to\
\9@param [number] y -- the y coordinate to move to\
]]\
function Path:moveTo( x, y )\
\9self.currentX = x\
\9self.currentY = y\
end\
\
--[[\
\9@instance\
\9@desc Adds a straight line from the current position to the specified position\
\9@param [number] x -- the x coordinate to add a line to\
\9@param [number] y -- the y coordinate to add a line to\
\9@return [boolean] didAdd -- whether the line was added\
]]\
function Path:lineTo( x, y )\
\9if self.defined or not x or not y or (x == self.currentX and y == self.currentY) then return false end\
\9self.lines[#self.lines + 1] = {\
\9\9mode = \"linear\";\
\9\9x1 = self.currentX;\
\9\9y1 = self.currentY;\
\9\9x2 = x;\
\9\9y2 = y;\
\9}\
\9self.currentX = x\
\9self.currentY = y\
\9--[[\
\9local pointsTable = self.points\
\9pointsTable[#pointsTable + 1] = false\
\9pointsTable[#pointsTable + 1] = false\
\9pointsTable[#pointsTable + 1] = { x, y }\
\9]]\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Create a bezier curve from current position to the specified position\
\9@param [number] endX -- the x coordinate to create the curve to\
\9@param [number] endY -- the y coordinate to create the curve to\
\9@param [number] controlPoint1X -- the x coodinate of the first control point (for the current position)\
\9@param [number] controlPoint1Y -- the y coodinate of the first control point (for the current position)\
\9@param [number] controlPoint2X -- the x coodinate of the first control point\
\9@param [number] controlPoint2Y -- the y coodinate of the first control point\
\9@return [boolean] didAdd -- whether the line was added\
]]\
function Path:curveTo( endX, endY, controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y )\
\9if self.defined or not endX or not endY or not controlPoint1X or not controlPoint1Y or not controlPoint2X or not controlPoint2Y then return false end\
\9\
\9self.lines[#self.lines + 1] = {\
\9\9mode = \"curve\";\
\9\9x1 = self.currentX;\
\9\9y1 = self.currentY;\
\9\9x2 = endX;\
\9\9y2 = endY;\
\9\9controlPoint1X = controlPoint1X;\
\9\9controlPoint1Y = controlPoint1Y;\
\9\9controlPoint2X = controlPoint2X;\
\9\9controlPoint2Y = controlPoint2Y;\
\9}\
\
\9self.currentX = endX\
\9self.currentY = endY\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Adds an arc from the current position of the specified position. This is always circular (constant radius).\
\9@param [number] endX -- the x coordinate to create the arc to\
\9@param [number] endY -- the y coordinate to create the arc to\
\9@param [number] startAngle -- the angle to start (in radians)\
\9@param [number] endAngle -- the angle to end (in radians)\
\9@return [boolean] didAdd -- whether the line was added\
]]\
\
function Path:arc( startAngle, endAngle, radius )\
\9if self.defined then return false end\
\
\9local lines = self.lines\
\
\9local currentX, currentY = self.currentX, self.currentY\
\9local centreX, centreY = currentX - sin( startAngle ) * radius, currentY + cos( startAngle ) * radius\
\
\9local length = endAngle - startAngle\
\9local segments = floor( radius * abs( length ) * PI + .5 )\
\
\9for i = 0, segments do\
\9\9local angle = startAngle + length * i / segments\
\9\9local x, y = centreX + sin( angle ) * radius, centreY - cos( angle ) * radius\
\
\9\9lines[#lines + 1] = {\
\9\9\9mode = \"linear\";\
\9\9\9x1 = currentX;\
\9\9\9y1 = currentY;\
\9\9\9x2 = x;\
\9\9\9y2 = y;\
\9\9}\
\
\9\9currentX, currentY = x, y\
\9end\
\
\9self.currentX, self.currentY = currentX, currentY\
\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Closes the path (i.e. makes the end meet the start), making it immutable and drawable\
\9@return [boolean] didClose -- whether the path was closed\
]]\
function Path:close( linkedToEnd )\
\9linkedToEnd = (linkedToEnd == nil) and true or false\
\9if self.defined then return false end\
\
\9if #self.lines == 0 then\
\9\9error( \"Path has no lines!\", 2 )\
\9end\
\9if linkedToEnd and (self.lines[1].x1 ~= self.lines[#self.lines].x2 or self.lines[1].y1 ~= self.lines[#self.lines].y2) then\
\9\9self:lineTo( self.lines[1].x1, self.lines[1].y1 )\
\9end\
\
\9self.defined = true;\
\9self.currentX = nil\
\9self.currentY = nil\
\9return true\
end\
\
function Path:getHorizontalIntersections( y, minX, maxX )\
\9local points = {}\
\9local lines = self.lines\
\9for i = 1, #lines do\
\9\9if lines[i].mode == \"linear\" then\
\9\9\9getHorizontalLinearIntersectionPoint( points, y, lines[i], minX, maxX )\
\9\9else\
\9\9\9getHorizontalCurvedIntersectionPoints( points, y, lines[i], minX, maxX )\
\9\9end\
\9end\
\9table.sort( points )\
\9return points\
end\
\
function Path:getVerticalIntersections( x, minY, maxY )\
\9local points = {}\
\9local lines = self.lines\
\9for i = 1, #lines do\
\9\9if lines[i].mode == \"linear\" then\
\9\9\9getVerticalLinearIntersectionPoint( points, x, lines[i], minY, maxY )\
\9\9else\
\9\9\9getVerticalCurvedIntersectionPoints( points, x, lines[i], minY, maxY )\
\9\9end\
\9end\
\9table.sort( points )\
\9return points\
end\
\
--[[\
\9@instance\
\9@desc Get an array of the intersection points (essentially the outline)\
\9@return [table] points -- the points\
\9@return [table] vertices -- the points\
]]\
function Path:getPointsAndVertices( y, minX, maxX )\
\9local points = {}\
\9local lines = self.lines\
\9for i = 1, #lines do\
\9\9local line = lines[i]\
\9\9if line.mode == \"linear\" then\
\9\9\9getLinearIntersectionPoint( points, y, line, minX, maxX )\
\9\9else\
\9\9\9getCurvedIntersectionPoints( points, y, line, minX, maxX )\
\9\9end\
\9end\
\
\9local vertices = {}\
\9table.sort( points )\
\9for i = #points, 2, -1 do\
\9\9if round( points[i] ) == round( points[i-1] ) then\
\9\9\9vertices[i] = true\
\9\9\9vertices[i-1] = true\
\9\9end\
\9end\
\
\9return points, vertices\
end\
\
--[[\
    @instance\
    @desc Gets the points on the outline of the path\
    @param [number] outlineWidth -- the outline width\
    @param [boolean] dualAxis -- whether or not to check both axis\
    \9this should be true if generating outline points for fill mode\
    @return [table] points -- an array of points { [y] = { [1] = x1, [n] = xn } }\
    @return [number] minY -- the minimum Y coord\
    @return [number] maxY -- the maximum Y coord\
]]\
function Path:getFill()\
\9if self.fill then return self.fill end\
\
\9local minY, maxY, minX, maxX = 1, self.height, 1, self.width\
\9local fill = {}\
\
\9for y = minY, maxY do\
\
\9\9local points = self:getHorizontalIntersections( y, minX, maxX )\
\
\9\9if #points == 1 then\
\9\9\9local x = floor( points[1] + .5 )\
\9\9\9fill[x] = fill[x] or {}\
\9\9\9fill[x][y] = true\
\9\9else\
\9\9\9local filling = false\
\9\9\9for i = 1, #points - 1 do\
\9\9\9\9local isVertex = ( round( points[i] ) == round( points[i + 1] ) ) or ( points[i-1] and round( points[i] ) == round( points[i - 1] ) )\
\9\9\9\9if not filling or not isVertex then\
\9\9\9\9\9filling = not filling\
\9\9\9\9end\
\9\9\9\9if filling then\
\9\9\9\9\9for x = floor( points[i] + .5 ), floor( points[i + 1] + .5 ) do\
\9\9\9\9\9\9fill[x] = fill[x] or {}\
\9\9\9\9\9\9fill[x][y] = true\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9self.fill = fill\
\9return fill\
end\
\
\
function Path:getOutline()\
\9if self.outline then return self.outline end\
\
\9local minY, maxY, minX, maxX = 1, self.height, 1, self.width\
\9local outline = {}\
\
\9for y = minY, maxY do\
\9\9local points = self:getHorizontalIntersections( y, minX, maxX )\
\
\9\9for i = 1, #points do\
\9\9\9local x = round( points[i] )\
\9\9\9outline[x] = outline[x] or {}\
\9\9\9outline[x][y] = true\
\9\9end\
\9end\
\
\9for x = minX, maxX do\
\9\9outline[x] = outline[x] or {}\
\9\9local points = self:getVerticalIntersections( x, minY, maxY )\
\
\9\9for i = 1, #points do\
\9\9\9local y = round( points[i] )\
\9\9\9outline[x][y] = true\
\9\9end\
\9end\
\
\9local thickendOutline = {}\
\9local function xScanline( min, max, inc, outlineWidth )\
\9\9if outlineWidth <= 1 then return end\
\9\9for y = 1, self.height do\
\9\9\9for x = min, max, inc do\
\9\9\9\9if outline[x] and outline[x][y] then\
\9\9\9\9\9for i = 1 - outlineWidth, outlineWidth - 1 do\
\9\9\9\9\9\9thickendOutline[x + i] = thickendOutline[x + i] or {}\
\9\9\9\9\9\9thickendOutline[x + i][y] = true\
\9\9\9\9\9end\9\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9local function yScanline( min, max, inc, outlineWidth )\
\9\9for x = 1, self.width do\
\9\9\9local lastY = 0\
\9\9\9local yPixels = 0\
\9\9\9local outlineX = outline[x]\
\9\9\9if outlineX then\
\9\9\9\9for y, isSet in pairs( outlineX ) do\
\9\9\9\9\9if isSet then\
\9\9\9\9\9\9for i = 1 - outlineWidth, outlineWidth - 1 do\
\9\9\9\9\9\9\9thickendOutline[x + i] = thickendOutline[x + i] or {}\
\9\9\9\9\9\9\9thickendOutline[x][y + i] = true\
\9\9\9\9\9\9end\9\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9xScanline( 1, self.width, 1, self.leftOutlineWidth )\
\9xScanline( self.width, 1, -1, self.rightOutlineWidth )\
\9yScanline( 1, self.height, 1, self.topOutlineWidth )\
\9yScanline( self.height, 1, -1, self.bottomOutlineWidth )\
\
\9self.outline = thickendOutline\
\9return thickendOutline\
end",["ApplicationContainer.lua"] = "\
class \"ApplicationContainer\" extends \"Container\" {\
\9-- TODO: make this use a Constraint\
\9x = 1;\
\9y = 1;\
\9width = 310;\
\9height = 175;\
\9themeName = false;\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function ApplicationContainer:initialise( ... )\
\9self.super:initialise( ... )\
\
\9if not self.themeName then\
\9\9self.themeName = \"default\"\
\9end\
\
    self.theme:connect( self.canvas, \"fillColour\" )\
    self:event( Event.MOUSE_DOWN, self.onMouseUp, EventManager.phase.AFTER )\
end\
\
function ApplicationContainer:initialiseCanvas()\
\9local canvas = ScreenCanvas( self.x, self.y, self.width, self.height )\
    self.canvas = canvas\
end\
\
function ApplicationContainer:setTheme( theme )\
\9if type( theme ) == \"string\" then error( \"Use .themeName, not .theme, to set a theme with it's name.\", 0 ) end\
\9self.theme = theme\
end\
\
--[[\
\9@instance\
\9@desc Sets the container's theme based upon it's name\
\9@return [string] themeName -- the name of the theme\
]]\
function ApplicationContainer:setThemeName( themeName )\
\9local oldThemeName = self.themeName\
\9self.themeName = themeName\
\9Theme.active = Theme.named( themeName )\
\9self.application.event:handleEvent( ThemeChangedInterfaceEvent( themeName, oldThemeName ) )\
end\
\
function ApplicationContainer:draw()\
\9self.canvas:drawToTerminal()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released and doesn't hit anything else. Unfocuses the focused view, if any.\
    @param [MouseDownEvent] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function ApplicationContainer:onMouseUp( event )\
\9local application = self.application\
\9local focus = application.focus\
\9if focus and focus.isFocusDismissable then\
\9    application:clearFocus()\
\9end\
end\
\
function ApplicationContainer:dispose()\
\9self.super:dispose()\
\9self.application:clearFocus()\
end",["ContainerEventManager.lua"] = "\
class \"ContainerEventManager\" extends \"EventManager\" {}\
\
--[[\
\9@instance\
\9@desc Perfoms the appropriate handles for the given event and then trickles them down through the owner's children\
\9@param [Event] event -- the event to handle\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function ContainerEventManager:handleEvent( event )\
\9local sender = event.sender\
\9local isSentToSender = not sender or ( self ~= sender or event.isSentToSender )\
\9if isSentToSender and self:handleEventPhase( event, self.phase.BEFORE ) then\
\9\9return true\
\9end\
\
\9if event.isSentToChildren then\
\9\9local owner = self.owner\
\9\9local children = owner.children\
\9\9for i = #children, 1, -1 do\
\9\9\9childView = children[i]\
\9\9\9if childView:typeOf( Container ) or childView.event:hasConnections( event.eventType ) then\
\9\9\9\9if childView:hitTestEvent( event, owner ) then\
\9\9\9\9\9event:makeRelative( childView )\
\9\9\9\9\9if childView.event:handleEvent( event ) then\
\9\9\9\9\9\9return true\
\9\9\9\9\9end\
\9\9\9\9\9event:makeRelative( owner )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9\9\
\9if isSentToSender and self:handleEventPhase( event, self.phase.AFTER ) then\
\9\9return true\
\9end\
end",["TerminateEvent.lua"] = "\
class \"TerminateEvent\" extends \"Event\" {\
\9eventType = Event.TERMINATE;\
}",["Graphics.lua"] = "\
class \"Graphics\" {\
\9\
\9colours = { -- @enum [Graphics.colours]\
\9\9TRANSPARENT = 0;\
\9\9WHITE = colours.white;\
\9\9ORANGE = colours.orange;\
\9\9MAGENTA = colours.magenta;\
\9\9LIGHT_BLUE = colours.lightBlue;\
\9\9YELLOW = colours.yellow;\
\9\9LIME = colours.lime;\
\9\9PINK = colours.pink;\
\9\9GREY = colours.grey;\
\9\9LIGHT_GREY = colours.lightGrey;\
\9\9CYAN = colours.cyan;\
\9\9PURPLE = colours.purple;\
\9\9BLUE = colours.blue;\
\9\9BROWN = colours.brown;\
\9\9GREEN = colours.green;\
\9\9RED = colours.red;\
\9\9BLACK = colours.black;\
\
\9\9-- For those who can't spell.\
\9\9GRAY = colours.grey;\
\9\9LIGHT_GRAY = colours.lightGrey;\
\9};\
\
}",["SeparatorMenuItem.lua"] = "\
class \"SeparatorMenuItem\" extends \"MenuItem\" {\
\9text = nil;\
\
\9height = 3;\
\9width = 51;\
\
\9textColour = Graphics.colours.LIGHT_GREY;\
\
    pressedTextColour = Graphics.colours.WHITE;\
\
    disabledTextColour = Graphics.colours.LIGHT_GREY;\
\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function SeparatorMenuItem:initialise( ... )\
\9self.super.super:initialise( ... )\
end\
\
function SeparatorMenuItem:initialiseCanvas()\
\9self.super.super:initialiseCanvas()\
    self.backgroundObject = self.canvas:insert( Separator( 5, 2, self.width - 8, 1 ) )\
end\
\
function SeparatorMenuItem:setIsPressed( isPressed )\
    self.isPressed = false\
end\
\
function SeparatorMenuItem:updateWidth( width )\
\9self.backgroundObject.width = width - 8\
end\
\
function SeparatorMenuItem:updateHeight( height )\
\9self.backgroundObject.height = 1\
end",["InterfaceEvent.lua"] = "\
class \"InterfaceEvent\" extends \"Event\" {\
\9owner = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates an interface event from the arguments\
\9@param [class] owner -- the owner view\
]]\
function InterfaceEvent:initialise( owner )\
\9self.owner = owner\
end",["class.lua"] = "\
-- cache the names of the property getter/setter functions\
local setters, getters = {}, {}\
setmetatable( setters, {\
\9__index = function( self, k )\
\9\9local v = \"set\" .. k:sub( 1, 1 ):upper() .. k:sub( 2 )\
\9\9self[k] = v\
\9\9return v\
\9end;\
} )\
setmetatable( getters, {\
\9__index = function( self, k )\
\9\9local v = \"get\" .. k:sub( 1, 1 ):upper() .. k:sub( 2 )\
\9\9self[k] = v\
\9\9return v\
\9end;\
} )\
\
local classes = {}\
local creating\
local USE_GLOBALS = true\
\
local class = {}\
\
function class.get( type )\
\9return classes[type]\
end\
\
-- ensures that all tables that should be unique to an instance are (designated by assigning the table to {} as class a property)\
local function uniqueTable( _class, raw )\
\9for k, v in pairs( _class ) do\
\9\9-- if the properties contain any blank tables generate a new table so it's not shared between instances\
\9\9if type( v ) == \"table\" then\
\9\9\9if #v == 0 then\
\9\9\9\9local keyFound = false\
\9\9\9\9for k2, v2 in pairs( v ) do\
\9\9\9\9\9keyFound = true\
\9\9\9\9\9break\
\9\9\9\9end\
\
\9\9\9\9if not keyFound then\
\9\9\9\9\9raw[k] = {}\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
end\
\
-- @static\
function class:newSuper( instance, eq, ... )\
\9local _class = self\
\9local raw = {}\
\9local super\
\9if _class._extends then\
\9\9-- super needs it's super too\
\9\9super = _class._extends:newSuper( instance, eq, ... )\
\9\9raw.super = super\
\9end\
\
\9uniqueTable( _class, instance )\
\
\9raw.class = _class\
\9raw.instance = instance\
\9raw.mt = {}\
\
\9-- Super needs to be able to act like it's own instance in that it has all of it's own methods and properties, yet the subclass needs to be able to use super as if it were itself\
\9-- So, for example, setting a value in a super method would actually set the value in the subclass\
\9-- Likewise, indexing a value that's present \
\9-- super:initialise is not automatically called, that's up to the subclass (although, one init will always be called, which might reach in to super)\
\
\9raw.mt.__eq = eq\
\
\9local _rawSuper = raw.super\
\9function raw.mt:__index( k )\
\9\9if k == \"super\" then\
\9\9\9-- only ever called if this class doesn't have a super, to prevent super refering back to itself return nil\
\9\9\9return nil\
\9\9end\
\
\9\9local _classValue = _class[k]\
\9\9if _classValue and type( _classValue ) == \"function\" then\
\9\9\9-- we want super functions to be callable and not overwritten when accessed directly (e.g. self.super:initialise( ) )\
\9\9\9local f = _classValue\
\9\9\9return function(_self, ...)\
\9\9\9\9if _self == raw then\
\9\9\9\9\9-- when calling a function on super, the instance needs to be given, but the super needs to be the super's super\
\9\9\9\9\9local oldSuper = rawget( instance, \"super\" )\
\9\9\9\9\9rawset( instance, \"super\", _rawSuper )\
\9\9\9\9\9local v = { f( instance, ... ) }\
\9\9\9\9\9rawset( instance, \"super\", oldSuper )\
\9\9\9\9\9return unpack( v )\
\9\9\9\9else\
\9\9\9\9\9return f( _self, ... )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9local _instanceValue = instance[k]\
\9\9if _instanceValue and type( _instanceValue ) ~= \"function\" then \
\9\9\9-- however, we don't want any properties (i.e. mutable values) to come from super if they exist in the instanceclass. we also don't want instance functions called from self.super\
\9\9\9return _instanceValue\
\9\9elseif _classValue then\
\9\9\9-- try to use the super's class values\
\9\9\9return _classValue\
\9\9end\
\9end\
\
\9function raw.mt:__newindex( k, v )\
\9\9-- we don't want to save values in super, save them in the subclass\
\9\9instance[k] = v\
\9end\
\
\9local rawId = tostring( raw):sub(8 ) -- remove 'table: ' from the id\
\9function raw.mt:__tostring()\
\9\9return 'instance of `' .. _class.className .. '` as super: ' .. rawId\
\9end\
\
\9setmetatable( raw, raw.mt )\
\
\9return raw\
end\
\
-- @static\
function class:new( ... )\
\9local _class = self\
\9local raw = {}\
\9local proxy = { hasInitialised = false } -- the proxy. \"self\" always needs to be this, NOT raw\
\9local super\
\9proxy.mt = {}\
\
\9raw.class = _class\
\9raw.mt = {}\
\9function proxy.mt.__eq( l, r )\
\9\9return rawequal( l, r ) or ( rawequal( l.instance, r ) ) or ( rawequal( l, r.instance ) ) or ( rawequal( l.instance, r.instance ) )\
\9end\
\
\9if _class._extends then\
\9\9super = _class._extends:newSuper( proxy, proxy.mt.__eq, ... ) -- super needs to be an instance, not class\
\9\9raw.super = super\
\9end\
\
\9uniqueTable( _class, raw )\
\
\9local _superClass = super and super.class or nil\
\9local _superSuper = super and super.super or nil\
\9function raw.mt:__index( k )\
\9\9local rawClassValue = rawget( _class, k )\
\9\9if rawClassValue ~= nil then\
\9\9\9-- try to take it from the self class (only, not super)\
\9\9\9return rawClassValue\
\9\9end\
\
\9\9if _superClass then\
\9\9\9local f = _superClass[k]\
\9\9\9if f then\
\9\9\9\9-- otherwise, check super classes for a value\
\9\9\9\9if type( f ) == \"function\" then\
\9\9\9\9\9return function(_self, ...)\
\9\9\9\9\9\9if _self == proxy then\
\9\9\9\9\9\9\9-- when calling a function on super, the instance needs to be given, but the super needs to be the super's super\
\9\9\9\9\9\9\9local oldSuper = rawget( proxy, \"super\" )\
\9\9\9\9\9\9\9rawset( proxy, \"super\", _superSuper )\
\9\9\9\9\9\9\9local v = { f( proxy, ... ) }\
\9\9\9\9\9\9\9rawset( proxy, \"super\", oldSuper ) -- as it's the proxy setting to nil simply causes it to look in raw again\
\9\9\9\9\9\9\9return unpack( v )\
\9\9\9\9\9\9else\
\9\9\9\9\9\9\9return f( _self, ... )\
\9\9\9\9\9\9end\
\9\9\9\9\9end\
\9\9\9\9else\
\9\9\9\9\9return f\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9return class[k]\
\9end\
\9\
\9setmetatable( raw, raw.mt )\
\
\9-- these are to prevent infinite loops in getters and setters ( so, for example, doing self.speed = 10 in setSpeed doesn't cause setSpeed to be called a million times )\
\9local lockedSetters = {}\
\9local lockedGetters = {}\
\
\9proxy.__lockedSetters = lockedSetters\
\9proxy.__lockedGetters = lockedGetters\
\9proxy.raw = raw -- not sure about this, although i guess it can't hurt\
\9-- TODO: the getter/setter ifs could be made more efficient\
\
\9local _rawGet = ( raw.get and type( raw.get ) == \"function\" ) and raw.get or nil\
\9function proxy.mt:__index( k )\
\9\9local isRawFunc\
\9\9local rawV\
\9\9if not lockedGetters[k] then\
\
\9\9\9-- this basically allows a global filter or notification on all get\
\9\9\9if _rawGet then\
\9\9\9\9lockedGetters[k] = true\
\9\9\9\9local use, value = _rawGet( proxy, k )\
\9\9\9\9lockedGetters[k] = nil\
\9\9\9\9if use then\
\9\9\9\9\9return value\
\9\9\9\9end\9\
\9\9\9end\
\
\9\9\9-- basically, if the get\"Key\" function is set, return it's value\
\9\9\9-- non-function properties can't use it, because, well, it's just futile really\
\9\9\9-- \
\9\9\9rawV = raw[k]\
\9\9\9isRawFunc = type( rawV ) == \"function\"\
\9\9\9if not isRawFunc then\
\9\9\9\9local rawFunc = raw[getters[k]]\
\9\9\9\9if rawFunc and type( rawFunc ) == \"function\" then\
\9\9\9\9\9lockedGetters[k] = true\
\
\9\9\9\9\9local value = rawFunc( proxy )\
\9\9\9\9\9-- if the super has been masked then change it back, then change it again\
\9\9\9\9\9local oldSuper = rawget( proxy, \"super\" )\
\9\9\9\9\9rawset( proxy, \"super\", nil ) -- as it's the proxy setting to nil simply causes it to look in raw again\
\9\9\9\9\9local v = { rawFunc( proxy ) }\
\9\9\9\9\9rawset( proxy, \"super\", oldSuper )\
\9\9\9\9\9local value =  unpack( v )\
\
\9\9\9\9\9lockedGetters[k] = nil\
\9\9\9\9\9return value\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9rawV = ( rawV == nil ) and raw[k] or rawV\
\9\9isRawFunc = ( isRawFunc == nil ) and type( rawV ) == \"function\" or isRawFunc\
\
\9\9if isRawFunc then\
\9\9\9return function( _self, ... )\
\9\9\9\9if rawequal( _self, proxy ) then\
\9\9\9\9\9-- if the super has been masked then change it back, then change it again\
\9\9\9\9\9local oldSuper = rawget( proxy, \"super\" )\
\9\9\9\9\9rawset( proxy, \"super\", nil ) -- as it's the proxy setting to nil simply causes it to look in raw again\
\9\9\9\9\9local v = { rawV( proxy, ... ) }\
\9\9\9\9\9rawset( proxy, \"super\", oldSuper )\
\9\9\9\9\9return unpack( v )\
\9\9\9\9else\
\9\9\9\9\9return rawV( _self, ... )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9return rawV\
\9end\
\
\9local _rawSet = ( raw.set and type( raw.set ) == \"function\" ) and raw.set or nil\
\9function proxy.mt:__newindex( k, v )\
\9\9if k == \"super\" or k == \"class\" then\
\9\9\9error( 'Cannot set reserved property: ' .. k, 0 )\
\9\9end\
\
\9\9if not lockedSetters[k] then\
\9\9\9-- TODO: maybe don't make the setter call if the value hasn't changed\
\9\9\9-- this basically allows a global filter or notification on all sets\
\9\9\9if _rawSet then\
\9\9\9\9lockedSetters[k] = true\
\9\9\9\9local use, value = _rawSet( proxy, k, v )\
\9\9\9\9lockedSetters[k] = nil\
\9\9\9\9if use then\
\9\9\9\9\9raw[k] = value\
\9\9\9\9\9return\
\9\9\9\9end\9\
\9\9\9end\
\
\9\9\9-- if the filter wasn't applied, if the set\"Key\" function is set, call it\
\9\9\9local isRawFunc = type( raw[k] ) == \"function\"\
\9\9\9if not isRawFunc then\
\9\9\9\9local rawFunc = raw[setters[k]]\
\9\9\9\9if rawFunc and type( rawFunc ) == \"function\" then\
\9\9\9\9\9lockedSetters[k] = true\
\
\9\9\9\9\9-- if the super has been masked then change it back, then change it again\
\9\9\9\9\9local oldSuper = rawget( proxy, \"super\" )\
\9\9\9\9\9rawset( proxy, \"super\", nil ) -- as it's the proxy setting to nil simply causes it to look in raw again\
\9\9\9\9\9local v = { rawFunc( proxy, v ) }\
\9\9\9\9\9rawset( proxy, \"super\", oldSuper )\
\
\9\9\9\9\9lockedSetters[k] = nil\
\9\9\9\9\9return\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9raw[k] = v -- use the passed value if not using a setter\
\9end\
\
\9local proxyId = tostring( proxy):sub( 8 ) -- remove 'table: ' from the id\
\9function proxy.mt:__tostring()\
\9\9local identifier = proxy.identifier\
\9\9return \"instance of `\" .. _class.className .. \"`\" .. (identifier and \" ('\" .. identifier .. \"')\" or \"\") .. \": \" .. proxyId\
\9end\
\
\9setmetatable( proxy, proxy.mt )\
\
\9for k, v in pairs( _class ) do\
\9\9if type( v ) == \"table\" and v.typeOf and v:typeOf( InterfaceOutlet ) then\
\9\9\9-- link interface outlets, they set the class property to a share instance, so we need to generate a unique one\
\9\9\9proxy[k] = InterfaceOutlet( v.viewIdentifier or k, v.trackAll, proxy )\
\9\9end\
\9end\
\
\9-- once the class has been created, pass the arguments to the init function for handling\
\9if proxy.initialise and type( proxy.initialise ) == \"function\" then\
\9\9proxy:initialise( ... )\
\9end\
\9proxy.hasInitialised = true\
\
\9return proxy\
end\
\
-- constructs an actual class ( NOT instance )\
-- @static\
function class:construct( _, className )\
\9local _class = {}\
\9_class.className = className\
\9_class.interfaceOutletActions = { 1 }\
\
\9local mt = { __index = self }\
\9_class.mt = mt\
\
\9function mt:__call( ... )\
\9\9return self:new( ... )\
\9end\
\
\9function mt:__newindex( k, v )\
\9\9if type( v ) == \"function\" and #k >= 3 and k:sub( 1, 2 ) == \"on\" then\
\9\9\9local firstLetter = k:sub( 3, 3 )\
\9\9\9if firstLetter:upper() == firstLetter then\
\9\9\9\9local property = firstLetter:lower() .. k:sub( 4 )\
\9\9\9\9local existingValue = _class[property]\
\9\9\9\9if existingValue and type( existingValue ) == \"table\" and existingValue:typeOf( InterfaceOutlet ) then\
\9\9\9\9\9-- the value is being set to a function, but it's already an InterfaceOutlet. in this circumstance we treat it as an action\
\9\9\9\9\9_class.interfaceOutletActions[property] = v\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9rawset(_class, k, v)\
\9end\
\
\9function mt:__tostring()\
\9\9return 'class: ' .. self.className\
\9end\
\
\9setmetatable( _class, mt )\
\
\9classes[className] = _class\
\9_G[className] = _class -- TODO: this is just temporary due to the temporary loading system in Silica\
\9-- getfenv( 2 )[className] = _class\
\9creating = _class\
\
\9return function( properties )\
\9\9creating = nil\
\9\9_class:properties( properties )\
\9\9if _class.constructed then\
\9\9\9_class:constructed()\
\9\9end\
\9\9return _class\
\9end\
end\
\
-- @erm, class instance?\
function class:alias( shorthand, property )\
\9self[ setters[shorthand] ] = function( self, value )\
\9\9self[property] = value\
\9end\
\9self[ getters[shorthand] ] = function( self )\
\9\9return self[property]\
\9end\
end\
\
-- @instance\
function class:dispose()end\
\
-- @instance\
function class:properties( properties )\
\9for k, v in pairs( properties ) do\
\9\9self[k] = v\
\9end\
end\
\
-- @instance\
function class:typeOf( _class )\
\9_self = self.instance or self -- gets the class at the bottom of the chain (i.e. the one who has the most supers above)\
\
\9if type( _self ) ~= \"table\" then -- will this ever be true?? class.typeOf( \"\", MyClass )\
\9\9return false\
\9elseif _self.class then\
\9\9return _self.class:typeOf( _class )\
\9elseif _self == _class then\
\9\9return true\
\9elseif _self._extends then\
\9\9return _self._extends:typeOf( _class )\
\9end\
\9return false\
end\
\
-- @instance\
function class:type()\
\9local _type = type( self )\
\9pcall( function()\
\9\9_type = getmetatable( self ).__type or _type\
\9end )\
\9return _type\
end\
\
-- @instance\
function class:can( method )\
\9return type( self[method] ) == \"function\"\
end\
\
setmetatable( class, {\
\9__call = function( ... ) \
\9\9return class:construct( ... )\
\9end\
} )\
\
local function extends( superName )\
\9if not classes[superName] then\
\9\9-- try to load the class\
\9\9-- TODO: set this system up correctly\
\9\9local ourCreating = creating\
\9\9__loadClassNamed( superName )\
\9\9creating = ourCreating\
\9\9if not classes[superName] then\
\9\9\9error( 'Super class for `' .. creating.className .. '` was not found: ' .. superName, 0 )\
\9\9end\
\9end\
\
\9creating._extends = classes[superName]\
\9for k, v in pairs( classes[superName].mt ) do\
\9\9if not creating.mt[k] then\
\9\9\9creating.mt[k] = v\
\9\9end\
\9end\
\9creating.mt.__index = classes[superName]\
\9-- function(self, k)\
\9-- \9return classes[superName][k]\
\9-- end\
\9-- local super = classes[superName]\
 --    function creating.mt:__index( k )\
 --    \9local v = super[k]\
\
 --    \9if type( rawget( super, k ) ) == \"function\" then -- rawget is used just to prevent calls compounding\
 --    \9\9return function(_, ...)\
 --    \9\9\9return \
 --    \9\9end\
 --    \9else\
 --    \9\9return v\
 --    \9end\
 --    end\
\
\9setmetatable( creating, creating.mt )\
\
\9return function( properties )\
\9\9local _class = creating\
\9\9creating = nil\
\9\9_class:properties( properties )\
\9\9if _class.constructed then\
\9\9\9_class:constructed()\
\9\9end\
\9\9return _class\
\9end\
end\
\
if USE_GLOBALS then\
\9getfenv().class = class\
\9getfenv().extends = extends\
else\
\9class.extends = extends\
\9return class\
end",["MouseUpEvent.lua"] = "\
class \"MouseUpEvent\" extends \"MouseEvent\" {\
\9eventType = Event.MOUSE_UP;\
\9mouseButton = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseUpEvent:initialise( mouseButton, x, y )\
\9self.mouseButton = mouseButton\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end\
",["MinimiseWindowButton.lua"] = "\
class \"MinimiseWindowButton\" extends \"WindowButton\" {}\
\
function MinimiseWindowButton:initialiseCanvas()\
\9self.super:initialiseCanvas()\
\
\9local symbolObject = Path( 4, 4, 3, 1, 1, 1 )\
    symbolObject:lineTo( 3, 1 )\
    symbolObject:close( false )\
    self.theme:connect( symbolObject, \"outlineColour\", \"symbolColour\" )\
    self.symbolObject = self.canvas:insert( symbolObject )\
end\
\
function MinimiseWindowButton:onMouseUp( event )    \
    if self.window then\
        self.window:close()\
        return true\
    end\
end",["MaximiseWindowButton.lua"] = "\
class \"MaximiseWindowButton\" extends \"WindowButton\" {}\
\
function MaximiseWindowButton:initialiseCanvas()\
\9self.super:initialiseCanvas()\
\
\9local symbolObject = Path( 4, 3, 3, 3, 2, 1 )\
    symbolObject:lineTo( 2, 3 )\
    symbolObject:moveTo( 1, 2 )\
    symbolObject:lineTo( 3, 2 )\
    symbolObject:close( false )\
    self.theme:connect( symbolObject, \"outlineColour\", \"symbolColour\" )\
    self.symbolObject = self.canvas:insert( symbolObject )\
end\
\
function MaximiseWindowButton:onMouseUp( event )    \
    if self.window then\
        self.window:close()\
        return true\
    end\
end",["CloseWindowButton.lua"] = "\
class \"CloseWindowButton\" extends \"WindowButton\" {}\
\
function CloseWindowButton:initialiseCanvas()\
\9self.super:initialiseCanvas()\
\
\9local symbolObject = Path( 4, 3, 3, 3 )\
    symbolObject:lineTo( 3, 3 )\
    symbolObject:moveTo( 3, 1 )\
    symbolObject:lineTo( 1, 3 )\
    symbolObject:close( false )\
\
    self.theme:connect( symbolObject, \"outlineColour\", \"symbolColour\" )\
    self.symbolObject = self.canvas:insert( symbolObject )\
end\
\
function CloseWindowButton:onMouseUp( event )    \
    if self.window then\
        self.window:close()\
        return true\
    end\
end",["Checkbox.lua"] = "\
class \"Checkbox\" extends \"View\" {\
\
    width = 7;\
    height = 7;\
\
    isPressed = false;\
    isEnabled = true;\
    isChecked = false;\
\
    checkObject = nil;\
\
}\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function Checkbox:initialise( ... )\
\9self.super:initialise( ... )\
    self:event( Event.MOUSE_DOWN, self.onMouseDown )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Checkbox:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height, self.theme.fillColour, self.theme.outlineColour, self.theme.cornerRadius ) )\
    \
    local checkObject = Path( 2, 2, self.width - 2, self.height - 2, 1, 4 )\
    checkObject:lineTo( 2, 5 )\
    checkObject:lineTo( 5, 2 )\
    checkObject:close( false )\
\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( checkObject, \"outlineColour\", \"checkColour\" )\
\
    self.backgroundObject = backgroundObject\
    self.checkObject = checkObject\
    self.canvas:insert( checkObject )\
end\
\
function Checkbox:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or (self.isChecked and \"checked\" or \"default\" ) ) or ( self.isChecked and \"disabledChecked\" or \"disabled\" )\
end\
\
function Checkbox:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function Checkbox:updateWidth( width )\
    self.backgroundObject.width = width\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Checkbox:setIsPressed( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Checkbox:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Checkbox:setIsChecked( isChecked )\
    self.isChecked = isChecked\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance. Sends the event to the local handler.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Checkbox:onGlobalMouseUp( event )\9\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled then\
    \9\9if self:hitTestEvent( event ) then\
                self.isChecked = not self.isChecked\
    \9\9\9return self.event:handleEvent( event )\
            end\
\9\9end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Checkbox:onMouseDown( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end",["ParentChangedInterfaceEvent.lua"] = "\
class \"ParentChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.PARENT_CHANGED;\
\9newParent = false; -- the new parent\
\9oldParent = false; -- the old parent\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a siblings changed event from the arguments\
\9@param [Container] newParent -- the new parent view\
\9@param [Container] oldParent -- the old parent view\
]]\
function ParentChangedInterfaceEvent:initialise( newParent, oldParent )\
\9self.newParent = newParent\
\9self.oldParent = oldParent\
end",["TextChangedInterfaceEvent.lua"] = "\
class \"TextChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.TEXT_CHANGED;\
\9text = false; -- the new text value\
\9oldText = false; -- the previous text value\
}\
\
--[[\
\9@constructor\
\9@desc Creates a Text event from the arguments\
\9@param text -- the new text value\
\9@param oldText -- the old text value\
]]\
function TextChangedInterfaceEvent:initialise( text, oldText )\
\9self.text = text\
\9self.oldText = oldText\
end\
",["BitmapFont.lua"] = "\
local floor, ceil = math.floor, math.ceil\
\
local function readstring( handle )\
\9local v = handle.read()\
\9local s = \"\"\
\9while v ~= 0 do\
\9\9s = s .. string.char( v )\
\9\9v = handle.read()\
\9end\
\9return s\
end\
local function writestring( handle, text )\
\9for i = 1, #text do\
\9\9handle.write( text:byte( i ) )\
\9end\
end\
\
local function bhasbit( n, i )\
\9return floor( n / 2 ^ ( 8 - i ) ) % 2 == 1\
end\
\
class \"BitmapFont\" extends \"Font\" {\
\9\
}\
\
function BitmapFont.decodeCharacter( bytes, width, height )\
\9local character = {}\
\9local s = ceil( height / 8 )\
\9local function hasbit( x, y )\
\9\9local byte = ( x - 1 ) * s + ceil( y / 8 )\
\9\9local index = y % 8\
\9\9if index == 0 then index = 8 end\
\9\9local s = \"\"\
\9\9for i = 1, 8 do\
\9\9\9s = s .. ( bhasbit( bytes[byte], i ) and 1 or 0 )\
\9\9end\
\9\9return bhasbit( bytes[byte], index )\
\9end\
\9character.width = width\
\9for y = 1, height do\
\9\9character[y] = {}\
\9\9for x = 1, width do\
\9\9\9character[y][x] = hasbit( x, y )\
\9\9end\
\9end\
\9return character\
end\
\
function BitmapFont.encodeCharacter( character, width, height )\
\9local bytes = {}\
\9for x = 1, width do\
\9\9local byte = {}\
\9\9local function close()\
\9\9\9if #byte == 0 then return end\
\9\9\9local n = 0\
\9\9\9for i = 1, #byte do\
\9\9\9\9n = n * 2 + byte[i]\
\9\9\9end\
\9\9\9byte = {}\
\9\9\9bytes[#bytes + 1] = n\
\9\9end\
\9\9local function append( b )\
\9\9\9byte[#byte + 1] = b and 1 or 0\
\9\9\9if #byte == 8 then\
\9\9\9\9close()\
\9\9\9end\
\9\9end\
\9\9for y = 1, ceil( height / 8 ) * 8 do\
\9\9\9if character[y] then\
\9\9\9\9append( character[y][x] )\
\9\9\9else\
\9\9\9\9append()\
\9\9\9end\
\9\9end\
\9\9close()\
\9end\
\9return bytes\
end\
\
function BitmapFont.encodeSet( characters, height )\
\9local bytes = {}\
\9for k, v in pairs( characters ) do\
\9\9local width = v.width or ( v[1] and #v[1] or 0 )\
\9\9bytes[#bytes + 1] = k\
\9\9bytes[#bytes + 1] = width\
\9\9for _, byte in ipairs( BitmapFont.encodeCharacter( v, width, height ) ) do\
\9\9\9bytes[#bytes + 1] = byte\
\9\9end\
\9end\
\9return bytes\
end\
\
function BitmapFont.decodeSet( bytes, height )\
\9local hf = ceil( height / 8 )\
\9local characters = {}\
\9while bytes[1] do\
\9\9local character = bytes[1]\
\9\9local width = bytes[2]\
\9\9table.remove( bytes, 1 )\
\9\9table.remove( bytes, 1 )\
\9\9local bitmapcount = hf * width\
\9\9characters[character] = BitmapFont.decodeCharacter( bytes, width, height )\
\9\9for i = 1, bitmapcount do\
\9\9\9table.remove( bytes, 1 )\
\9\9end\
\9end\
\9return characters\
end\
\
function BitmapFont.encodeFile( file, characters, height, metadata )\
\9local h = fs.open( file, \"wb\" )\
\9if h then\
\9\9for k, v in pairs( metadata or {} ) do\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( k ) )\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( v ) )\
\9\9\9h.write( 0 )\
\9\9end\
\9\9h.write( 1 )\
\9\9h.write( height )\
\9\9for _, byte in ipairs( BitmapFont.encodeSet( characters, height ) ) do\
\9\9\9h.write( byte )\
\9\9end\
\9\9h.close()\
\9\9return true\
\9end\
end\
\
function BitmapFont.decodeFile( file )\
\9local h = fs.open( file, \"rb\" )\
\9if h then\
\9\9local metadata = {}\
\9\9local v = h.read()\
\9\9while v == 0 do\
\9\9\9local key, value = readstring( h ), readstring( h )\
\9\9\9metadata[key] = value\
\9\9\9v = h.read()\
\9\9end\
\9\9local height = h.read()\
\9\9local bytes = {}\
\9\9for byte in h.read do\
\9\9\9bytes[#bytes + 1] = byte\
\9\9end\
\9\9local characters = BitmapFont.decodeSet( bytes, height )\
\9\9return characters, height, metadata\
\9end\
end\
\
function BitmapFont.convertFile( input, output, charsetStart, height, metadata )\
\9local newchar = colours.red\
\9local filled = colours.white\
\9local image = paintutils.loadImage( input )\
\9local n = charsetStart or 0\
\
\9local chars = { [n] = {} }\
\9for x = 1, #image[1] do\
\9\9if image[1][x] == newchar then\
\9\9\9n = n + 1\
\9\9\9chars[n] = {}\
\9\9else\
\9\9\9for y = 1, #image do\
\9\9\9\9chars[n][y] = chars[n][y] or {}\
\9\9\9\9chars[n][y][#chars[n][y] + 1] = image[y][x] == filled\
\9\9\9end\
\9\9end\
\9end\
\
\9return BitmapFont.encodeFile( output, chars, height, metadata )\
end",["ParentResizedInterfaceEvent.lua"] = "\
class \"ParentResizeInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.PARENT_RESIZED;\
\9isHorizontal = false;\
\9isVertical = false;\
\9isSentToSender = false;\
\9isSentToChildren = true;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a parent resized event from the arguments\
\9@param [boolean] isHorizontal -- whether the change effected the width\
\9@param [boolean] isVertical -- whether the change effected the height\
\9@param [Container] sender -- the parent that resized\
]]\
function ParentResizeInterfaceEvent:initialise( isHorizontal, isVertical, sender )\
\9self.isHorizontal = isHorizontal\
\9self.isVertical = isVertical\
\9self.sender = sender\
end\
",["TextBox.lua"] = "\
--[[\
\9TODO\
\9\9Shift clicking\
\9\9Shift-left/right\
\9\9Ctrl-left/right\
\9\9Home\
\9\9End\
\9\9Delete\
\9\9Ctrl-shift-left/right\
\9\9Ctrl-a\
]]\
\
local CURSOR_ANIMATION_SPEED = 0.45\
\
local floor = math.floor\
\
class \"TextBox\" extends \"View\" {\
\
\9height = 15; -- the default height\
\9width = 120;\
\9text = \"\";\
\9placeholder = \"\";\
\
\9font = false;\
\
\9backgroundObject = false;\
\9textObject = false;\
\9placeholderObject = false;\
\9cursorObject = false;\
\9cursorFlashCounter = 0;\
\
\9leftMargin = 0;\
\9rightMargin = 0;\
\9isFocused = false;\
\9isPressed = false;\
\9isMasked = false; -- whether bullets are shown instead of characters (for passwords)\
\
\9scroll = 0;\
\9cursorPosition = 1;\
\9maximumLength = false;\
\9selectionPosition = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a text box view and connects the event handlers\
]]\
function TextBox:initialise( ... )\
\9self.super:initialise( ... )\
\9\
\9self:event( Event.KEY_UP, self.onKeyUp )\
\9self:event( Event.KEY_DOWN, self.onKeyDown )\
\9self:event( Event.CHARACTER, self.onCharacter )\
\9self:event( Event.MOUSE_DOWN, self.onMouseDown )\
\9self:event( Event.MOUSE_UP, self.onMouseUp )\
\9self:event( Event.MOUSE_DRAG, self.onMouseDrag )\
    self:event( Event.KEYBOARD_SHORTCUT, self.onKeyboardShortcut )\
\9self:event( Event.FOCUS_CHANGED, self.onFocusChanged )\
    \9self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
end\
\
--[[\
\9@instance\
\9@desc Sets up the canvas and it's graphics objects\
]]\
function TextBox:initialiseCanvas()\
\9self.super:initialiseCanvas()\
\9local width, height, theme = self.width, self.height, self.theme\
\9local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, width, height, theme.fillColour, theme.outlineColour, cornerRadius ) )\
\9local selectionObject = self.canvas:insert( Rectangle( 0, 4, 1, self.height - 6 ) )\
\9local placeholderObject = self.canvas:insert( Text( self.leftMargin, 5, self.width, 10, self.text ) )\
\9local textObject = self.canvas:insert( Text( self.leftMargin, 5, self.width, 10, self.placeholder ) )\
\9local cursorObject = self.canvas:insert( Cursor( 0, 4, self.height - 6 ) )\
\9cursorObject.isVisible = false\
\9selectionObject.isVisible = false\
\
\9theme:connect( backgroundObject, \"fillColour\" )\
\9theme:connect( backgroundObject, \"outlineColour\" )\
\9theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
\9theme:connect( textObject, \"textColour\" )\
\9theme:connect( placeholderObject, \"textColour\", \"placeholderColour\" )\
\9theme:connect( cursorObject, \"fillColour\", \"cursorColour\" )\
\9theme:connect( selectionObject, \"fillColour\", \"selectionColour\" )\
\9theme:connect( self, \"leftMargin\" )\
\9theme:connect( self, \"rightMargin\" )\
\
\9self.backgroundObject = backgroundObject\
\9self.textObject = textObject\
\9self.placeholderObject = placeholderObject\
\9self.cursorObject = cursorObject\
\9self.selectionObject = selectionObject\
\
\9if not self.font then\
\9\9self.font = Font.systemFont\
\9end\
end\
\
function TextBox:update( deltaTime )\
\9self.super:update( deltaTime )\
\
\9if self.isFocused then\
\9\9local cursorFlashCounter = self.cursorFlashCounter\
\9\9local visible = cursorFlashCounter % 2 < 1\
\9\9local rem = cursorFlashCounter % 1\
\9\9local colour\
\9\9if rem > .85 then\
\9\9\9if visible then\
\9\9\9\9colour = ( rem > .95 and colours.lightGrey ) or colours.grey\
\9\9\9else\
\9\9\9\9colour = ( rem > .95 and colours.grey ) or colours.lightGrey\
\9\9\9\9visible = true\
\9\9\9end\
\9\9else\
\9\9\9colour = colours.black\
\9\9end\
\9\9self.cursorObject.fillColour = colour\
\9\9self.cursorObject.isVisible = visible\
\9\9self.cursorFlashCounter = cursorFlashCounter + deltaTime\
\9end\
end\
\
function TextBox:updateHeight( height )\
\9self.backgroundObject.height = height\
end\
\
function TextBox:updateWidth( width )\
\9self.backgroundObject.width = width\
\9local textObject = self.textObject\
\9textObject.x = self.leftMargin + 1 - self.scroll\
\9textObject.width = width - self.leftMargin - self.rightMargin\
\9local placeholderObject = self.placeholderObject\
\9placeholderObject.x = self.leftMargin + 1\
\9placeholderObject.width = width - self.leftMargin - self.rightMargin\
end\
\
function TextBox:updateSelection()\
\9local selectionObject = self.selectionObject\
\9local leftMargin = self.leftMargin\
\9local cursorPosition = self.cursorPosition\
\9local selectionPosition = self.selectionPosition\
\
\9local isVisible = selectionObject.isVisible\
\9if not selectionPosition then--or cursorPosition == selectionPosition then\
\9\9if isVisible then selectionObject.isVisible = false end\
\9else\
\9\9local cursorX = leftMargin + math.max( self:charToViewCoords( cursorPosition ) - 1, 1 ) - self.scroll\
\9\9local selectionX = leftMargin + math.max( self:charToViewCoords( selectionPosition ) - 1, 1 ) - self.scroll\
\
\9\9if not isVisible then selectionObject.isVisible = true end\
\
\9\9local x, width, f\
\9\9if cursorX == selectionX then\
\9\9\9-- if isVisible then selectionObject.isVisible = false end\
\9\9\9local _x, _width = selectionObject.x, selectionObject.width\
\9\9\9x = math.floor( _x + _width / 2 )\
\9\9\9width = 0\
\9\9\9f = function() selectionObject.isVisible = false end\
\9\9else\
\9\9\9x = math.min( cursorX, selectionX )\
\9\9\9width = math.max( cursorX, selectionX ) - x\
\9\9end\
\
\9\9if not isVisible then\
\9\9\9selectionObject.x = x\
\9\9\9selectionObject.width = width\
\9\9else\
\9\9\9self:animate( \"selectionX\", x, CURSOR_ANIMATION_SPEED, f, Animation.easing.OUT_QUART )\
\9\9\9self:animate( \"selectionWidth\", width, CURSOR_ANIMATION_SPEED, nil, Animation.easing.OUT_QUART )\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Converts the coordinates relative to the text box to the character position\
\9@param [number] x -- the x coordinate\
\9@return [number] characterPosition -- the charcter position\
]]\
function TextBox:viewToCharCoords( x )\
\9if x <= 0 then\
\9\9return 1\
\9end\
\9local font = self.font\
\9local width = font.getWidth\
\9local text = self.isMasked and string.rep( string.char( 149 ), #self.text ) or self.text\
\9for i = 1, #text do\
\9\9local cw = width( font, text:sub( i, i ) )\
\9\9if x <= cw / 2 then\
\9\9\9return i\
\9\9end\
\9\9x = x - cw\
\9end\
\9return #text + 1\
end\
\
function TextBox:charToViewCoords( char )\
\9local text = self.isMasked and string.rep( string.char( 149 ), #self.text ) or self.text\
\9return self.font:getWidth( text:sub( 1, char - 1 ) ) + 1\
end\
\
--[[\
\9@instance\
\9@desc Callback to check whether a character entered by the user is valid, intended to be overridden by sub-classes\
\9@param [string] character\
\9@return [boolean] isValid\
]]\
function TextBox:isValidChar( character )\
\9return true\
end\
\
function TextBox:setScroll( scroll )\
\9self.scroll = scroll\
\9self.textObject.x = self.leftMargin + 1 - self.scroll\
\9self:updateSelection()\
\9self:updateCursorPosition()\
end\
\
function TextBox:setCursorPosition( cursorPosition )\
\9cursorPosition = math.max( math.min( cursorPosition, #self.text + 1 ), 1 )\
\9self.cursorPosition = cursorPosition\
\9self.cursorFlashCounter = 0\
\9if self:charToViewCoords( cursorPosition ) - self.scroll < 1 then\
\9\9self.scroll = self:charToViewCoords( cursorPosition ) - 1\
\9elseif self:charToViewCoords( cursorPosition ) - self.scroll > ( self.width - self.leftMargin - self.rightMargin ) then\
\9\9self.scroll = self:charToViewCoords( cursorPosition ) - ( self.width - self.leftMargin - self.rightMargin )\
\9end\
\
\9self:updateCursorPosition()\
end\
\
function TextBox:setCursorX( x )\
\9self.cursorObject.x = x\
end\
\
function TextBox:getCursorX()\
\9return self.cursorObject.x\
end\
\
function TextBox:setSelectionX( x )\
\9self.selectionObject.x = x\
end\
\
function TextBox:getSelectionX()\
\9return self.selectionObject.x\
end\
\
function TextBox:setSelectionWidth( width )\
\9self.selectionObject.width = width\
end\
\
function TextBox:getSelectionWidth()\
\9return self.selectionObject.width\
end\
\
function TextBox:updateCursorPosition()\
\9local value = self.leftMargin + math.max( self:charToViewCoords( self.selectionPosition or self.cursorPosition ) - 1, 1 ) - self.scroll\
\9self:animate( \"cursorX\", value, CURSOR_ANIMATION_SPEED, nil, Animation.easing.OUT_QUART )\
end\
\
function TextBox:setSelectionPosition( selectionPosition )\
\9self.selectionPosition = selectionPosition\
\9self.cursorFlashCounter = 0\
\9self:updateSelection()\
\9self:updateCursorPosition()\
end\
\
--[[\
\9@instance\
\9@desc ima leave this... until floobits,.. just yeah\
\9es@param [string] character\
\9@return [boolean] isValid\
]]\
local sub = string.sub -- move to top\
local concat = table.concat\
function TextBox:write( text )\
\9local t = {}\
\9local valid = self.isValidChar\
\9for i = 1, #text do\
\9\9local char = sub( text, 1, 1 )\
\9\9if valid( self, char ) then\
\9\9\9t[#t + 1] = char\
\9\9end\
\9end\
\9local text = self.text\
\9local s = concat( t )\
\9local cp, sp = self.cursorPosition, self.selectionPosition\
\9if sp then\
\9\9sp = sp - 1\
\9\9self.text = text:sub( 1, math.min( cp, sp ) - 1 ) .. s .. text:sub( math.max( cp, sp ) + 1 )\
\9\9self.cursorPosition =  math.min( cp, sp ) + #s\
\9\9self.selectionPosition = nil\
\9else\
\9\9self.text = text:sub( 1, cp - 1 ) .. s .. text:sub( cp )\
\9\9self.cursorPosition =  cp + #s\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns the character at the given character position\
\9@param [number] characterPosition -- the character position\
\9@return [string] character -- the character\
]]\
function TextBox:charCoordsToChar( characterPosition )\
\9return character\
end\
\
--[[\
\9@instance\
\9@desc What does this actually do?\
\9@param [type] arg1 -- description\
\9@param [type] arg2 -- description\
\9@param [type] arg3 -- description\
\9@return [type] returnedValue -- description\
]]\
function TextBox:charToCharCoords( arg1, arg2, arg3 )\
\9return returnedValue\
end\
\
--[[\
\9@instance\
\9@desc Converts the character position to screen coordinates\
\9@param [number] characterPosition -- the position of the character\
\9@return [number] x -- the x coordinate realtive to the text box\
\9@return [number] y -- the y coordinate realtive to the text box\
]]\
function TextBox:charCoordsToViewCoordinates( characterPosition )\
\9return x, y\
end\
\
--[[\
\9@instance\
\9@desc Set the text of the text box.\
\9@param [string] text -- the text of the text box\
]]\
function TextBox:setText( text )\
\9self.text = text\
\9self.textObject.text = self.isMasked and string.rep( string.char( 149 ), #text ) or text\
\9self.placeholderObject.isVisible = #text == 0\
end\
\
function TextBox:setPlaceholder( placeholder )\
\9self.placeholder = placeholder\
\9local placeholderObject = self.placeholderObject\
\9if placeholderObject then\
\9\9placeholderObject.text = placeholder or ''\
\9end\
end\
\
function TextBox:setIsMasked( isMasked )\
\9self.isMasked = isMasked\
\9self.text = self.text\
end\
\
--[[\
\9@instance\
\9@desc Set the margin on either side of the text\
\9@param [number] margin -- the space around the text\
]]\
function TextBox:setMargin( margin )\
\9self.leftMargin = margin\
\9self.rightMargin = margin\
end\
\
function TextBox:setFont( font )\
\9self.font = font\
\9local textObject = self.textObject\
\9if textObject then\
\9\9textObject.font = font\
\9\9self.placeholderObject.font = font\
\9\9self.cursorObject.height = font.height + 1\
\9\9self.selectionObject.height = font.height + 1\
\9end\
end\
\
function TextBox:updateThemeStyle()\
\9self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or ( self.isFocused and \"focused\" or \"default\" ) ) or \"disabled\"\
end\
\
function TextBox:setIsPressed( isPressed )\
\9self.isPressed = isPressed\
\9self:updateThemeStyle()\
end\
\
function TextBox:setIsEnabled( isEnabled )\
\9self.isEnabled = isEnabled\
\9if not isEnabled then\
\9\9self:unfocus()\
\9end\
\9self:updateThemeStyle()\
end\
\
--[[\
\9@instance\
\9@desc Sets whether the text box is focused. DO NOT CALL/SET THIS DIRECTLY! Use :focus and :unfocus instead.\
\9@param [boolean] isFocused -- whether the text box is focused\
]]\
function TextBox:setIsFocused( isFocused )\
\9local wasFocused = self.isFocused\
\9if wasFocused ~= isFocused then\
\9\9self.cursorObject.isVisible = isFocused\
\9\9self.cursorPosition = self.cursorPosition or 1\
\9\9self.isFocused = isFocused\
\9\9self:updateThemeStyle()\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Focuses the text box, making it the current view that text is entered in to\
]]\
function TextBox:focus()\
\9self.application.focus = self\
end\
\
--[[\
\9@instance\
\9@desc Unfocuses the text box, making no other view focused\
]]\
function TextBox:unfocus()\
\9if self.isFocused then\
\9\9self.application:clearFocus()\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Fired when the focused view changes\
\9@param [FocusChangedInterfaceEvent] event -- the focus changed event\
\9@return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onFocusChanged( event )\
\9self.isFocused = ( self == event.newFocus )\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
\9@param [Event] event -- the mouse up event\
\9@return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onGlobalMouseUp( event )\
\9if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self.isPressed = false\
\9\9if self.isEnabled and self:hitTestEvent( event ) then\
\9\9\9return self.event:handleEvent( event )\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is released. Focuses on the text box\
\9@param [MouseDownEvent] event -- the mouse down event\
\9@return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onMouseUp( event )\
\9if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self:focus()\
\9end\
\9return true\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
\9@param [MouseDownEvent] event -- the mouse down event\
\9@return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onMouseDown( event )\
\9if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self.isPressed = true\
\9\9self.cursorPosition = self:viewToCharCoords( event.x - self.leftMargin + self.scroll )\
\9\9self.selectionPosition = false\
\9end\
\9return true\
end\
\
function TextBox:onMouseDrag( event )\
\9if self.isPressed and self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
\9\9self.isPressed = true\
\9\9self.selectionPosition = self:viewToCharCoords( event.x - self.leftMargin + self.scroll )\
\9end\
\9return true\
end\
\
function TextBox:onKeyDown( event )\
\9if self.isFocused then\
\9\9local keyCode = event.keyCode\
\9\9local text = self.text\
\
\9\9if keyCode == keys.backspace then\
\9\9\9if self.selectionPosition then\
\9\9\9\9self:write \"\"\
\9\9\9elseif self.cursorPosition > 1 then\
\9\9\9\9self.text = text:sub( 1, self.cursorPosition - 2 ) .. text:sub( self.cursorPosition )\
\9\9\9\9self.cursorPosition = self.cursorPosition - 1\
\9\9\9end\
\9\9elseif keyCode == keys.left then\
\9\9\9local selectionPosition = self.selectionPosition\
\9\9\9local cursorPosition = self.cursorPosition\
\
\9\9\9if selectionPosition then\
\9\9\9\9self.cursorPosition = math.min( cursorPosition, selectionPosition )\
\9\9\9\9self.selectionPosition = false\
\9\9\9else\
\9\9\9\9self.cursorPosition = cursorPosition - 1\
\9\9\9end\
\9\9elseif keyCode == keys.right then\
\9\9\9local selectionPosition = self.selectionPosition\
\9\9\9local cursorPosition = self.cursorPosition\
\
\9\9\9if selectionPosition then\
\9\9\9\9self.cursorPosition = math.max( cursorPosition, selectionPosition )\
\9\9\9\9self.selectionPosition = false\
\9\9\9else\
\9\9\9\9self.cursorPosition = cursorPosition + 1\
\9\9\9end\
\9\9elseif keyCode == keys[\"end\"] then\
\
\9\9elseif keyCode == keys.home then\
\
\9\9elseif keyCode == keys.delete then\
\
\9\9end\
\9end\
end\
\
function TextBox:onKeyUp( event )\
\9if self.isFocused then\
\9\9\
\9end\
end\
\
function TextBox:onCharacter( event )\
\9if self.isFocused then\
\9\9local text = self.text\
\9\9self:write( event.character )\
\9end\
end\
\
--[[\
    @instance\
    @desc Fired when the a keyboard shortcut is fired\
    @param [Event] event -- the keyboard shortcut\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function TextBox:onKeyboardShortcut( event )\
    if self.isFocused then\
        if event:matchesKeys( { \"ctrl\", \"left\" } ) or event:matchesKeys( { \"home\" } ) then\
        \9self.selectionPosition = false\
        \9self.cursorPosition = 1\
        elseif event:matchesKeys( { \"ctrl\", \"right\" } ) or event:matchesKeys( { \"end\" } ) then\
        \9self.selectionPosition = false\
        \9self.cursorPosition = #self.text + 1\
        elseif event:matchesKeys( { \"ctrl\", \"shift\", \"left\" } ) then -- ehm, nope, select a word\
        \9self.selectionPosition = 1\
        elseif event:matchesKeys( { \"ctrl\", \"shift\", \"right\" } ) then -- ehm, nope, select a word\
        \9self.selectionPosition = #self.text + 1\
        elseif event:matchesKeys( { \"shift\", \"left\" } ) then\
        \9local selectionPosition = self.selectionPosition\
        \9if selectionPosition then\
\9        \9self.selectionPosition = math.max( 1, selectionPosition - 1 )\
\9    \9else\
\9    \9\9self.selectionPosition = math.max( 1, self.cursorPosition - 1 )\
\9    \9end\
        elseif event:matchesKeys( { \"shift\", \"right\" } ) then\
        \9local selectionPosition = self.selectionPosition\
        \9if selectionPosition then\
\9        \9self.selectionPosition = math.min( #self.text + 1, selectionPosition + 1 )\
\9    \9else\
\9    \9\9self.selectionPosition = math.min( #self.text + 1, self.cursorPosition + 1 )\
\9    \9end\
        elseif event:matchesKeys( { \"ctrl\", \"a\" } ) then\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = #self.text + 1\
        elseif event:matchesKeys( { \"ctrl\", \"backspace\" } ) then\
        \9local cursorPosition = self.cursorPosition\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = nil\
        \9self.text = self.text:sub( cursorPosition )\
        elseif event:matchesKeys( { \"ctrl\", \"home\" } ) then\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = #self.text + 1\
        elseif event:matchesKeys( { \"ctrl\", \"end\" } ) then\
        \9self.cursorPosition = 1\
        \9self.selectionPosition = #self.text + 1\
        else\
            return false\
        end\
        return true\
    end\
end",["SegmentButton.lua"] = "\
-- TODO: this needs some fixes to make the last button have a gap on it's left when pushed\
\
class \"SegmentButton\" extends \"Button\" {\
\9\
\9separatorObject = nil;\
\
}\
\
function SegmentButton:initialise( ... )\
    self.super:initialise( ... )\
    self:event( Event.PARENT_CHANGED, self.onSiblingOrParentChanged )\
    self:event( Event.SIBLING_ADDED, self.onSiblingOrParentChanged )\
    self:event( Event.SIBLING_ADDED, self.onSiblingOrParentChanged )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function SegmentButton:initialiseCanvas()\
\9self.super:initialiseCanvas()\
    local separatorBackgroundObject = self.canvas:insert( Rectangle( self.width, 1, 1, self.height -1 ) )\
    self.separatorObject = self.canvas:insert( Separator( self.width, 3, 1, self.height - 4 ) )\
    separatorBackgroundObject.leftOutlineWidth = 0\
    separatorBackgroundObject.rightOutlineWidth = 0\
    local theme = self.theme\
    theme:connect( separatorBackgroundObject, \"fillColour\", \"separatorFillColour\" )\
    theme:connect( separatorBackgroundObject, \"dotColour\", \"separatorDotColour\" )\
    theme:connect( separatorBackgroundObject, \"outlineColour\", \"separatorOutlineColour\" )\
    theme:connect( self, \"centerMargin\" )\
    self.separatorBackgroundObject = separatorBackgroundObject\
    theme:disconnect( self.backgroundObject, \"radius\", \"cornerRadius\" )\
    theme:disconnect( self.shadowObject, \"radius\", \"cornerRadius\" )\
end\
\
function SegmentButton:setWidth( width )\
    self.super.super:setWidth( width )\
    local isFirst = self.isFirst\
    local isLast = self.isLast\
    self.backgroundObject.width = isLast and width - 1 or width - 1\
    self.shadowObject.width = (isLast or isFirst) and width - 1 or width\
    self.separatorObject.x = width\
    self.separatorBackgroundObject.x = width\
    \
    local textObject = self.textObject\
    local leftMargin, rightMargin = self.leftMargin, self.rightMargin\
    textObject.x = self.isPressed and leftMargin + 2 or leftMargin + 1\
    textObject.width = width - leftMargin - rightMargin\
    self.parent.needsLayoutUpdate = true\
end\
\
function SegmentButton:getRightMargin()\
    return self.isLast and self.rightMargin or self.centerMargin\
end\
\
function SegmentButton:getLeftMargin()\
    return self.isFirst and self.leftMargin or self.centerMargin\
end\
\
function SegmentButton:setIsPressed( isPressed )\
    self.super:setIsPressed( isPressed )\
    local isFirst = self.isFirst\
    local isLast = self.isLast\
    if isLast then\
        local width = self.width\
        self.backgroundObject.x = isPressed and 2 or 1\
        self.backgroundObject.width = isPressed and width - 2 or width - 1\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when it's siblings changed or it is added/removed from it's parent\
    @param [Event] event -- the event\
]]\
function SegmentButton:onSiblingOrParentChanged( event )\
    local backgroundObject = self.backgroundObject\
    local shadowObject = self.shadowObject\
    local isFirst = self.isFirst\
    local isLast = self.isLast\
    local theme = self.theme\
\
    shadowObject.x = (isLast or isFirst) and 2 or 1\
    backgroundObject.leftOutlineWidth = isFirst and 1 or 0\
    backgroundObject.rightOutlineWidth = isLast and 1 or 0\
    self.separatorObject.isVisible = not isLast\
    self.separatorBackgroundObject.isVisible = not isLast\
\
\
    if isFirst then\
        theme:connect( backgroundObject, \"leftRadius\", \"cornerRadius\" )\
        theme:connect( shadowObject, \"leftRadius\", \"cornerRadius\" )\
    else\
        theme:disconnect( backgroundObject, \"leftRadius\", \"cornerRadius\" )\
        theme:disconnect( shadowObject, \"leftRadius\", \"cornerRadius\" )\
    end\
\
    if isLast then\
        theme:connect( backgroundObject, \"rightRadius\", \"cornerRadius\" )\
        theme:connect( shadowObject, \"rightRadius\", \"cornerRadius\" )\
    else\
        theme:disconnect( backgroundObject, \"rightRadius\", \"cornerRadius\" )\
        theme:disconnect( shadowObject, \"rightRadius\", \"cornerRadius\" )\
    end\
\
\
    local width = self.width\
    local isPressed = self.isPressed\
    -- backgroundObject.width = (isLast and isPressed) and width or width - 1\
    shadowObject.width = ((isLast and not isPressed) or isFirst) and width - 1 or width\
end",["Radio.lua"] = "\
class \"Radio\" extends \"View\" {\
\
    width = 7;\
    height = 7;\
\
    isPressed = false;\
    isEnabled = true;\
    isChecked = false;\
\
}\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function Radio:initialise( ... )\
\9self.super:initialise( ... )\
    self:event( Event.MOUSE_DOWN, self.onMouseDown )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
    end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Radio:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height, self.theme.fillColour, self.theme.outlineColour, self.theme.cornerRadius ) )\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.backgroundObject = backgroundObject\
end\
\
function Radio:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function Radio:updateWidth( width )\
    self.backgroundObject.width = width\
end\
\
--[[\
    @instance\
    @desc Sets the checked state of the radio button. Sets all other sibling (in the same container) radios to false if being set to true\
    @param [boolean] isChecked -- the new checked state\
]]\
function Radio:setIsChecked( isChecked )\
    self.isChecked = isChecked\
    if isChecked then\
        for i, sibling in ipairs( self:siblingsOfType( Radio ) ) do\
            sibling.isChecked = false\
        end\
    end\
    self.event:handleEvent( ActionInterfaceEvent( self ) )\
    self:updateThemeStyle()\
end\
\
\
function Radio:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or (self.isChecked and \"checked\" or \"default\" ) ) or ( self.isChecked and \"disabledChecked\" or \"disabled\" )\
end\
\
function Radio:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is pressed, changing the drawing state\
]]\
function Radio:setIsPressed( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Radio:onGlobalMouseUp( event )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self:hitTestEvent( event ) then\
            self.isChecked = true\
            return self.event:handleEvent( event )\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Radio:onMouseDown( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end",["ProgressBar.lua"] = "\
class \"ProgressBar\" extends \"View\" {\
    \
    height = 7;\
    width = 100;\
\
    isEnabled = true;\
    isIndeterminate = true;\
    cornerRadius = 4;\
    stripeWidth = 8;\
\
    value = 0.3;\
    maximum = 1;\
\
    backgroundObject = nil;\
    stripesObject = nil;\
\
}\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function ProgressBar:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width, self.height, self.theme.fillColour, self.theme.outlineColour, self.theme.cornerRadius ) )\
    local stripesObject = self.canvas:insert( ProgressBarStripes( 1, 1, math.floor( ( self.value/self.maximum ) * self.width + 0.5 ), self.height, self.theme.barColour, self.theme.barColour, self.theme.stripeColour, self.theme.cornerRadius ) )\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( stripesObject, \"fillColour\", \"barColour\" )\
    self.theme:connect( stripesObject, \"outlineColour\", \"barColour\" )\
    self.theme:connect( stripesObject, \"stripeColour\" )\
    self.theme:connect( stripesObject, \"radiusLeft\", \"cornerRadius\" )\
\
    self.backgroundObject = backgroundObject\
    self.stripesObject = stripesObject\
end\
\
function ProgressBar:updateWidth( width )\
    self.backgroundObject.width = width\
    self.stripesObject.width = math.floor( ( self.value/self.maximum ) * width + 0.5 )\
end\
\
function ProgressBar:updateHeight( height )\
    self.backgroundObject.height = height\
    self.stripesObject.height = height\
end\
\
function ProgressBar:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
--[[\
    @instance\
    @desc Set the value of the progress bar\
    @param [number] value -- the value\
]]\
function ProgressBar:setValue( value )\
    self.value = math.min( math.max( value, 0 ), self.maximum )\
    self.stripesObject.width = math.floor( ( self.value / self.maximum ) * self.width + 0.5 )\
end\
\
--[[\
    @instance\
    @desc Set the maximum value of the progress bar\
    @param [number] maximum -- the maximum value\
]]\
function ProgressBar:setMaximum( maximum )\
    self.maximum = math.max( maximum, 0 )\
    self.stripesObject.width = math.floor( ( self.value / self.maximum ) * self.width + 0.5 )\
end\
\
--[[\
    @instance\
    @desc Fired on a screen update. Animates the stripes\
    @param [number] deltaTime -- the time since last update\
]]\
function ProgressBar:update( deltaTime )\
    if self.value > 0 or self.isIndeterminate then\
        self.stripesObject.animationStep = self.stripesObject.animationStep + deltaTime * 20\
    end\
end",["MenuItem.lua"] = "\
local TEXT_MARGIN = 12\
\
class \"MenuItem\" extends \"View\" {\
\
\9height = 12;\
\9width = 40;\
\
    isPressed = false;\
    isEnabled = true;\
\9isCanvasHitTested = false;\
\
    keyboardShortcut = nil;\
    text = nil;\
\
    font = nil;\
    backgroundObject = nil;\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a menu item instance\
\9@param [table] properties -- the properties for the view\
]]\
function MenuItem:initialise( ... )\
\9self.super:initialise( ... )\
\
    self:event( Event.MOUSE_DOWN, self.onMouseDown )\
    self:event( Event.KEYBOARD_SHORTCUT, self.onKeyboardShortcut )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
end\
\
function MenuItem:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local backgroundObject = self.canvas:insert( Rectangle( 1, 1, self.width, self.height, self.fillColour ) )\
    local textObject = self.canvas:insert( Text( 7, 3, self.height, self.width - TEXT_MARGIN, self.text ) )\
    local keyboardShortcut = self.keyboardShortcut\
    local shortcutObject = self.canvas:insert( Text( 1, 3, self.height, self.width - TEXT_MARGIN, keyboardShortcut and keyboardShortcut:symbols() or \"\" ) )\
    shortcutObject.alignment = Font.alignments.RIGHT\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( textObject, \"textColour\" )\
    self.theme:connect( shortcutObject, \"textColour\", \"shortcutColour\" )\
\
    self.backgroundObject = backgroundObject\
    self.textObject = textObject\
    self.shortcutObject = shortcutObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
function MenuItem:setShortcut( shortcut )\
    if shortcut and #shortcut > 0 then\
        self.keyboardShortcut = KeyboardShortcut.fromString( shortcut ) or false\
    else\
        self.keyboardShortcut = false\
    end\
end\
\
function MenuItem:setFont( font )\
    self.font = font\
    local textObject = self.textObject\
    local shortcutObject = self.shortcutObject\
    if textObject then\
        textObject.font = font\
        shortcutObject.font = font\
        self:updateText()\
    end\
end\
\
function MenuItem:updateText()\
    local text = self.text\
    local keyboardShortcut = self.keyboardShortcut\
    local symbols = keyboardShortcut and keyboardShortcut:symbols()\
    local textObject = self.textObject\
    local shortcutObject = self.shortcutObject\
\
    if textObject then\
        local textWidth = self.font:getWidth( text )\
        local shortcutWidth = symbols and self.font:getWidth( symbols ) or 0\
        local width = textWidth + TEXT_MARGIN + ( shortcutWidth ~= 0 and shortcutWidth + 8 or 0 )\
        self.width = width\
        textObject.text = text\
        shortcutObject.text = symbols\
        local parent = self.parent\
        if parent then\
            parent.needsLayoutUpdate = true\
        end\
    end\
end\
\
\
function MenuItem:setText( text )\
    self.text = text\
    self:updateText()\
end\
\
function MenuItem:setKeyboardShortcut( keyboardShortcut )\
    self.keyboardShortcut = keyboardShortcut\
    self:updateText()\
end\
\
function MenuItem:updateWidth( width )\
    self.backgroundObject.width = width\
    self.textObject.width = width - TEXT_MARGIN\
    local shortcutObject = self.shortcutObject\
    shortcutObject.width = width - 5\
end\
\
function MenuItem:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function MenuItem:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function MenuItem:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function MenuItem:setIsPressed( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuItem:onGlobalMouseUp( event )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled and self:hitTestEvent( event ) then\
            if self.event:handleEvent( ActionInterfaceEvent( self ) ) then return true end\
            self.parent:close()\
            return self.event:handleEvent( event )\
        end\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuItem:onMouseDown( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the a keyboard shortcut is fired\
    @param [Event] event -- the keyboard shortcut\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuItem:onKeyboardShortcut( event )\
    if self.isEnabled then\
        local keyboardShortcut = self.keyboardShortcut\
        if keyboardShortcut and keyboardShortcut:matchesEvent( event ) then\
            local parent = self.parent\
            local owner = parent.owner\
            if owner:typeOf( MenuBarItem ) then owner:flash() end\
            if self.event:handleEvent( ActionInterfaceEvent( self ) ) then return true end\
            parent:close()\
            return true\
        end\
    end\
end",["MenuBarItem.lua"] = "\
local TEXT_MARGIN = 12\
\
class \"MenuBarItem\" extends \"View\" {\
\
\9height = 12;\
    isPressed = false;\
    isEnabled = true;\
\9isCanvasHitTested = false;\
    text = false;\
    font = false;\
    backgroundObject = false;\
    menu = false;\
    menuName = false;\
    isFlashing = false;\
\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a menu item instance\
\9@param [table] properties -- the properties for the view\
]]\
function MenuBarItem:initialise( ... )\
\9self.super:initialise( ... )\
\
    local menuName = self.menuName\
    if not menuName then error( \"MenuBarItems must specify the property menuName (the name of the interface file to use).\", 0 ) end\
    menu = Menu.fromInterface( menuName, Menu )\
    menu.owner = self\
    menu.isSingleShot = false\
    menu.isVisible = false\
    menu.hitTestOwner = true\
    menu.topMargin = Menu.topMargin + 4\
    self.menu = menu\
    self:event( Event.MENU_CHANGED, self.onMenuChanged )\
    self:event( Event.MOUSE_DOWN, self.onMouseDown )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
    self:event( Event.INTERFACE_READY, self.onInterfaceReady )\
end\
\
function MenuBarItem:onInterfaceReady( event )\
    local menu = self.menu\
    if menu then\
        menu = self.menu\
        if menu.parent then\
            menu.parent:removeChild( menu )\
        end\
        local parent = self.parent\
        if parent then\
            menu.x = self.x + parent.x - 6\
            menu.y = self.y + parent.y + 7\
            local parentParent = parent.parent\
            if parentParent then\
                parentParent:insert( menu )\
            end\
        end\
    end\
end\
\
function MenuBarItem:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local backgroundObject = self.canvas:insert( Rectangle( 1, 1, self.width, self.height, self.fillColour ) )\
    local textObject = self.canvas:insert( Text( TEXT_MARGIN / 2 + 1, 3, self.height, self.width - TEXT_MARGIN, self.text ) )\
\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( textObject, \"textColour\" )\
\
    self.backgroundObject = backgroundObject\
    self.textObject = textObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
function MenuBarItem:setFont( font )\
    self.font = font\
    local textObject = self.textObject\
    if textObject then\
        local fontWidth = self.font:getWidth( text )\
        self.width = fontWidth + TEXT_MARGIN\
        self.textObject.font = font\
        local parent = self.parent\
        if parent then\
            parent.needsLayoutUpdate = true\
        end\
    end\
end\
\
function MenuBarItem:setText( text )\
    self.text = text\
    local textObject = self.textObject\
    if textObject then\
        local fontWidth = self.font:getWidth( text )\
        self.width = fontWidth + TEXT_MARGIN\
        self.textObject.text = text\
        local parent = self.parent\
        if parent then\
            parent.needsLayoutUpdate = true\
        end\
    end\
end\
\
function MenuBarItem:updateX( x )\
    local menu = self.menu\
    if menu then\
        menu.x = self.x + ( parent and parent.x or 0 ) -- 4\
    end\
end\
\
function MenuBarItem:updateY( y )\
    local menu = self.menu\
    if menu then\
        menu.y = self.y + ( parent and parent.y or 0 ) + 7\
    end\
end\
\
function MenuBarItem:updateWidth( width )\
    self.backgroundObject.width = width\
    self.textObject.width = width - TEXT_MARGIN\
end\
\
function MenuBarItem:updateHeight( height )\
    self.backgroundObject.height = height\
end\
\
function MenuBarItem:update( deltaTime )\
    self.super:update( deltaTime )\
    local isFlashing = self.isFlashing\
    if isFlashing then\
        if isFlashing <= 0 then\
            self.isFlashing = false\
        else\
            self.isFlashing = isFlashing - deltaTime\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Make the menu bar item flash for a brief period of time\
]]\
function MenuBarItem:flash()\
    self.isFlashing = 0.2\
end\
\
function MenuBarItem:setIsFlashing( isFlashing )\
    self.isFlashing = isFlashing\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Whether the button is pressed or open\
    @return [boolean] isActive -- whether the button is active\
]]\
function MenuBarItem:getIsActive()\
    return self.isPressed or self.isFlashing or self.menu.isOpen\
end\
\
function MenuBarItem:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isActive and \"pressed\" or \"default\" ) or \"disabled\"\
end\
\
function MenuBarItem:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function MenuBarItem:setIsPressed( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Toggles the menu if it hit tests.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuBarItem:onGlobalMouseUp( event )\
    if self.isEnabled and self.isPressed then\
        self.isPressed = false\
        if self:hitTestEvent( event ) then\
            self.menu:toggle()\
            return self.event:handleEvent( event )\
        end\
    end\
end\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuBarItem:onMouseDown( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when the owned menu opens or closes\
    @param [Event] event -- the menu changed event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function MenuBarItem:onMenuChanged( event )\
    self:updateThemeStyle()\
    \
    local menu = self.menu\
    if menu.isOpen then\
        menu.parent:sendToFront( menu )\
        menu.parent:sendToFront( self.parent )\
    end\
    return true\
end",["XML.lua"] = "\
-- TODO: XML bug. backslashes in attributes don't work. A single \"\\\" results in: expected '\"' to close string. While \"\\\\\"\" results in two backslashes being the parsed text\
\
local function fromXMLString( value )\
\9value = string.gsub(value, \"&#x( [%x]+ )%;\",\
\9\9function( h ) \
\9\9\9return string.char( tonumber(h,16) )\
\9\9end);\
\9value = string.gsub(value, \"&#([0-9]+)%;\",\
\9\9function( h )\
\9\9\9return string.char( tonumber(h,10) )\
\9\9end);\
\9value = string.gsub (value, \"&quot;\", \"\\\"\");\
\9value = string.gsub (value, \"&apos;\", \"'\");\
\9value = string.gsub (value, \"&gt;\", \">\");\
\9value = string.gsub (value, \"&lt;\", \"<\");\
\9value = string.gsub (value, \"&amp;\", \"&\");\
\9return value;\
end\
\
local function lex( text )\
\9local tokens = {}\
\9local pos, line, char = 1, 1, 1\
\9local function push( type, value )\
\9\9tokens[#tokens + 1] = {\
\9\9\9type = type;\
\9\9\9value = value;\
\9\9\9char = char;\
\9\9\9line = line;\
\9\9}\
\9end\
\9while pos <= #text do\
\9\9local c = text:sub( pos, pos )\
\9\9if c == \"\\n\" then\
\9\9\9line = line + 1\
\9\9\9char = 1\
\9\9\9pos = pos + 1\
\9\9elseif c:find \"%s\" then\
\9\9\9pos = pos + #text:match( \"%s+\", pos )\
\9\9elseif c == \"\\\"\" or c == \"'\" then\
\9\9\9local e, f, l = false, false, line\
\9\9\9for i = pos + 1, #text do\
\9\9\9\9if e then\
\9\9\9\9\9e = false\
\9\9\9\9elseif text:sub( i, i ) == \"\\\\\" then\
\9\9\9\9\9e = true\
\9\9\9\9elseif text:sub( i, i ) == c then\
\9\9\9\9\9push( \"string\", fromXMLString( text:sub( pos + 1, i - 1 ) ) )\
\9\9\9\9\9pos = i + 1\
\9\9\9\9\9f = true\
\9\9\9\9\9break\
\9\9\9\9elseif text:sub( i, i ) == \"\\n\" then\
\9\9\9\9\9line = line + 1\
\9\9\9\9end\
\9\9\9end\
\9\9\9if not f then\
\9\9\9\9return false, \"[\" .. l .. \" (char:\" .. char .. \")]: expected '\" .. c .. \"' to close string\"\
\9\9\9end\
\9\9elseif c:find \"[a-zA-Z%-%._]\" then\
\9\9\9local v = text:match( \"[a-zA-Z%d%-%._]+\", pos )\
\9\9\9push( \"word\", v )\
\9\9\9pos = pos + #v\
\9\9elseif text:find( \"^#?%.?%d\", pos ) then\
\9\9\9local v = text:match( \"^#?%d*%.?%d+%%?\", pos )\
\9\9\9pos = pos + #v\
\9\9\9local percentage = false\
\9\9\9if v:sub( -1 ) == \"%\" then\
\9\9\9\9v = v:sub( 1, -2 )\
\9\9\9\9percentage = true\
\9\9\9end\
\9\9\9if v:sub( 1, 1 ) == \"#\" then\
\9\9\9\9v = tonumber( v:sub( 2 ), 16 )\
\9\9\9else\
\9\9\9\9v = tonumber( v )\
\9\9\9end\
\9\9\9if percentage then\
\9\9\9\9v = v / 100\
\9\9\9end\
\9\9\9push( \"number\", v )\
\9\9elseif text:find( \"^<!%-%-.-%-%->\", pos ) then\
\9\9\9pos = pos + #text:match( \"^<!%-%-.-%-%->\", pos )\
\9\9else\
\9\9\9push( \"symbol\", c )\
\9\9\9pos = pos + 1\
\9\9end\
\9end\
\9return tokens\
end\
\
local parser = {}\
function parser:new( tokens )\
\9local t = setmetatable( {}, { __index = self } )\
\9t.tokens = tokens\
\9t.pos = 1\
\9t.last = tokens[1]\
\9t.exception = false\
\9return t\
end\
\
function parser:throw( message )\
\9if self.last then\
\9\9self.exception = \"[line \" .. self.last.line .. \", char \" .. self.last.char .. \"]: \" .. message\
\9else\
\9\9self.exception = \"[unknown]: \" .. message\
\9end\
\9return false, self.exception\
end\
\
function parser:thrown()\
\9return self.exception\
end\
\
function parser:peek()\
\9return self.tokens[self.pos]\
end\
\
function parser:next()\
\9self.pos = self.pos + 1\
\9self.last = self.tokens[self.pos] or self.last\
\9return self.tokens[self.pos]\
end\
\
function parser:test( type, value )\
\9local token = self:peek()\
\9return token and token.type == type and ( not value or token.value == value )\
end\
\
function parser:parseXMLInitialiser()\
\9local closing = false\
\
\9if self:test( \"symbol\", \"/\" ) then\
\9\9closing = true\
\9\9self:next()\
\9end\
\
\9if not self:test \"word\" then\
\9\9return self:throw \"expected name of XML item\"\
\9end\
\
\9local name = self:peek().value\
\9self:next()\
\
\9if closing then\
\9\9if self:test( \"symbol\", \">\" ) then\
\9\9\9self:next()\
\9\9else\
\9\9\9return self:throw \"expected '>' to close closing tag\"\
\9\9end\
\9end\
\
\9return name, closing\
end\
\
function parser:parseXMLAttributes()\
\9local attributes = {}\
\9while true do\
\9\9if self:test \"word\" then\
\9\9\9local name = self:peek().value\
\9\9\9self:next()\
\
\9\9\9if self:test( \"symbol\", \"=\" ) or self:test( \"symbol\", \":\" ) then\
\9\9\9\9local v = self:next()\
\
\9\9\9\9if v.type == \"number\" or v.type == \"string\" then\
\9\9\9\9\9attributes[name] = v.value\
\9\9\9\9elseif v.type == \"word\" then\
\9\9\9\9\9local word = v.value\
\9\9\9\9\9if word == \"true\" or word == \"false\" then\
\9\9\9\9\9\9word = word == \"true\"\
\9\9\9\9\9end\
\9\9\9\9\9attributes[name] = word\
\9\9\9\9else\
\9\9\9\9\9return self:throw( \"unexpected \" .. v.type .. \" as attribute value\" )\
\9\9\9\9end\
\
\9\9\9\9self:next()\
\9\9\9else\
\9\9\9\9attributes[name] = true\
\9\9\9\9self:next()\
\9\9\9end\
\9\9elseif self:test( \"symbol\", \"/\" ) then\
\9\9\9self:next()\
\9\9\9if not self:test( \"symbol\", \">\" ) then\
\9\9\9\9return self:throw \"expected '>' after '/' to close opening tag\"\
\9\9\9end\
\
\9\9\9self:next()\
\9\9\9return attributes, false\
\9\9elseif self:test( \"symbol\", \">\" ) then\
\9\9\9self:next()\
\9\9\9return attributes, true\
\9\9elseif not self:peek() then\
\9\9\9return attributes, false\
\9\9else\
\9\9\9return self:throw( \"unexpected \" .. self:peek().type .. \" in attributes\" )\
\9\9end\
\9end\
end\
\
function parser:parseXMLBody()\
\9local blocks = {}\
\
\9while self:peek() do\
\9\9while not self:test( \"symbol\", \"<\" ) do\
\9\9\9self:next()\
\9\9end\
\
\9\9self:next()\
\9\9local type, isClosing = self:parseXMLInitialiser()\
\9\9if self:thrown() then\
\9\9\9return false, self.exception\
\9\9end\
\
\9\9if isClosing then\
\9\9\9return blocks, type\
\9\9end\
\
\9\9local attributes, hasBody = self:parseXMLAttributes()\
\9\9if self:thrown() then\
\9\9\9return false, self.exception\
\9\9end\
\
\9\9local body, closer\
\9\9if hasBody then\
\9\9\9body, closer = self:parseXMLBody()\
\9\9\9if self:thrown() then\
\9\9\9\9return false, self.exception\
\9\9\9end\
\9\9\9if not closer then\
\9\9\9\9return self:throw( \"expected '</\" .. type .. \">' to close XML item, got nothing\" )\
\9\9\9elseif closer ~= type then\
\9\9\9\9return self:throw( \"expected '</\" .. type .. \">' to close XML item, got '</\" .. closer .. \">'\" )\
\9\9\9end\
\9\9end\
\
\9\9blocks[#blocks + 1] = {\
\9\9\9type = type;\
\9\9\9attributes = attributes;\
\9\9\9body = body;\
\9\9}\
\9end\
\
\9return blocks\
end\
\
class \"XML\" {}\
\
--[[\
\9@static\
\9@desc Loads XML from source text\
\9@param [string] xmlText -- the XML text to parse\
\9@return [table] xmlNodes -- the parsed XML nodes\
\9on error:\
\9@return false\
\9@return [string] error -- the error message\
]]\
function XML.fromText( xmlText )\
\9local tokens, err = lex( xmlText )\
\9if not tokens then\
\9\9return false, err\
\9end\
\
\9local p = parser:new( tokens )\
\9local blocks, data = p:parseXMLBody()\
\
\9if not blocks then\
\9\9return false, data\
\9end\
\9if data then -- if they put a </*> in the main body\
\9\9return p:throw( \"unexpected '</\" .. data .. \">' in main body\" )\
\9end\
\9return blocks\
end\
\
--[[\
\9@static\
\9@desc Loads an XML file\
\9@param [string] filePath -- the path to the XML file\
\9@return [table] xmlNodes -- the parsed XML nodes\
]]\
function XML.fromFile( filePath )\
\9local h = fs.open( filePath, \"r\" )\
\9if not h then\
\9\9error( \"Failed to open XML file: \" .. filePath, 0 )\
\9end\
\
\9local text = h.readAll()\
\9h.close()\
\9return XML.fromText( text )\
end",["MaskedTextBox.lua"] = "\
class \"MaskedTextBox\" extends \"TextBox\" {\
    \
    isMasked = true;\
\
}",["Label.lua"] = "\
class \"Label\" extends \"View\" {\
\
    text = nil;\
    isAutosizing = true;\
    font = nil;\
    textObject = nil;\
    needsAutosize = false;\
\9\
}\
\
function Label:initialise( ... )\
    self.super:initialise( ... )\
    end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Label:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local width, height, theme = self.width, self.height, self.theme\
    local textObject = self.canvas:insert( Text( 1, 1, self.width, self.height, self.text ) )\
\
    theme:connect( textObject, \"textColour\" )\
    theme:connect( self.canvas, \"fillColour\" )\
    self.textObject = textObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
function Label:updateThemeStyle()\
    self.theme.style = self.isEnabled and \"default\" or \"disabled\"\
end\
\
function Label:setFont( font )\
    self.font = font\
    local textObject = self.textObject\
    if textObject then\
        self.textObject.font = font\
        self.needsAutosize = true\
    end\
end\
\
function Label:setText( text )\
    self.text = text\
    self.textObject.text = text\
    self.needsAutosize = true\
end\
\
function Label:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function Label:update( deltaTime )\
    self.super:update( deltaTime )\
    if self.needsAutosize then\
        self:autosize()\
    end\
end\
\
--[[\
    @instance\
    @desc Automatically resizes the button, regardless of isAutosizing value, to fit the text\
]]\
function Label:autosize()\
    -- TODO: support self.isAutosizingc\
    local font, text, textObject = self.font, self.text, self.textObject\
\
    if font and text then\
        local fontWidth = font:getWidth( text )\
        self.width = fontWidth\
        self.height = font.height\
    end\
    self.needsAutosize = false\
end",["WindowContainer.lua"] = "\
class \"WindowContainer\" extends \"Container\" {\
\9backgroundObject = nil;\
}\
\
function WindowContainer:initialise( ... )\
\9self.super:initialise( ... )\
end\
\
function WindowContainer:initialiseCanvas()\
\9self.canvas = WindowCanvas( self.x, self.y, self.width, self.height )\
\9self.backgroundObject = self.canvas:insert( Rectangle( 1, 1, self.width, self.height, Graphics.colours.WHITE ) )\
end\
\
function WindowContainer:updateHeight( height )\
\9self.backgroundObject.height = height\
end\
\
function WindowContainer:updateWidth( width )\
\9self.backgroundObject.width = width\
end",["ScrollView.lua"] = "\
local exp = math.exp\
\
local SCROLL_DECAY = -8\
local SCROLL_SPEED = 180\
local SCROLL_ACCELERATION = 1.2--0.97\
local SPEED_CUTOFF = 0.2\
\
class \"ScrollView\" extends \"Container\" {\
\9contents = nil;\
\9horizontalScrollbar = nil;\
\9verticalScrollbar = nil;\
\
\9verticalStartTime = 0;\
\9verticalVelocity = 0;\
\9horizontalVelocity = 0;\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function ScrollView:initialise( ... )\
\9self.super:initialise( ... )\
\9self.canvas.fillColour = Graphics.colours.WHITE\
\
\9local width, height = self.width, self.height\
\9self.verticalScrollbar = self:insert( Scrollbar( { isHorizontal = false, x = width - Scrollbar.width + 1, height = height } ) )\
\9self.container = self:insert( ScrollContainer( { x = 1, y = 1, width = width, height = height } ) )\
    -- self:sendToFront( self.horizontalScrollbar )\
    self:sendToFront( self.verticalScrollbar )\
\
    self:event( Event.INTERFACE_LOADED, self.onInterfaceLoaded )\
    self:event( Event.MOUSE_SCROLL, self.onMouseScroll )\
end\
\
function ScrollView:onInterfaceLoaded( event )\
    local currentContainer = self.container\
    for i, childView in ipairs( self.children ) do\
        if childView ~= currentContainer and childView:typeOf( ScrollContainer ) then\
            childView.x = 1\
            childView.y = 1\
            self:remove( self.container )\
            self.container = childView\
            -- self:sendToFront( self.horizontalScrollbar )\
\9\9\9self.verticalScrollbar:getScroller()\
            self:sendToFront( self.verticalScrollbar )\
            break\
        end\
    end\
end\
\
function ScrollView:updateWidth( width )\
    width = self.width\
\9local verticalScrollbar = self.verticalScrollbar\
\9if verticalScrollbar then verticalScrollbar.x = width - verticalScrollbar.width + 1 end\
end\
\
function ScrollView:updateHeight( height )\
    height = self.height\
\9local verticalScrollbar = self.verticalScrollbar\
\9if verticalScrollbar then self.verticalScrollbar.height = height end\
end\
\
--[[\
\9@instance\
\9@desc Set vertical scroll offset of the contents\
\9@param [number] offsetY -- the vertical offset\
]]\
function ScrollView:setOffsetY( offsetY, isVelocity )\
\9local container = self.container\
\9if container then\
\9\9local height = self.height\
\9\9local currentOffsetY = self.offsetY\
\9\9local realOffsetY = math.max( math.min( offsetY, math.max( container.height - height, 0 ) ), 0 )\
\9\9self.raw.offsetY = realOffsetY\
\9\9self.verticalScrollbar:getScroller()\
\9\9if realOffsetY ~= offsetY then\
\9\9\9self.verticalVelocity = 0\
\9\9\9self.verticalVelocityTime = 0\
\9\9end\
\9\9container.y = 1 - math.floor( realOffsetY + 0.5 )\
\9end\
end\
\
\
function ScrollView:update( deltaTime )\
\9self.super:update( deltaTime )\
\9local verticalVelocity = self.verticalVelocity\
\9if verticalVelocity ~= 0 then\
\9\9local startTime\
\9\9local time = self.verticalVelocityTime\
\9\9local newVerticalVelocity = verticalVelocity * exp( SCROLL_DECAY * (time + deltaTime) )\
\9\9local distance\
\9\9if math.abs( newVerticalVelocity ) <= SPEED_CUTOFF then\
\9\9\9self.verticalVelocity = 0\
\9\9\9self.verticalVelocityTime = 0\
\9\9else\
\9\9\9self.verticalVelocityTime = time + deltaTime\
\9\9\9local currentVerticalVelocity = verticalVelocity * exp( SCROLL_DECAY * time )\
\9\9\9self:setOffsetY( self.offsetY + (currentVerticalVelocity - newVerticalVelocity) / SCROLL_DECAY, true )\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Scrolls the scroll view to the offset given, animating the value\
\9@param [number] offsetY -- the direction/distance to scroll\
]]\
function ScrollView:scrollTo( offsetY )\
\9-- calculate the velocity required to reach a certain point\
\9-- see https://www.desmos.com/calculator/qis3qhbsvs for details\
\9-- d = vi / a * ( 1 - e ^ ln( vf / vi ) )\
\9-- it turns out that this is far easier than oeed first thought and spent an hour playing with integrals...\
\9-- vi = ad + vf\
\9-- (vi - vf)/a = d\
\9local deltaOffsetY = offsetY - self.offsetY\
\9local velocity = SCROLL_DECAY * deltaOffsetY + SPEED_CUTOFF\
\9self.verticalVelocity = velocity\
\9self.verticalVelocityTime = 0\
\9-- self.offsetY = self.offsetY + direction\
\9-- TODO: horizontal scrolling\
end\
\
--[[\
\9@instance\
\9@desc Fired when the mouse is scrolled over the scroll view\
\9@param [Event] event -- the mouse scroll event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function ScrollView:onMouseScroll( event )\
\9if self.isEnabled then\
\9\9local direction = event.direction\
\9\9local verticalVelocity = self.verticalVelocity\
\9\9instantaneousVelocity = verticalVelocity and verticalVelocity * exp( SCROLL_DECAY * (self.verticalVelocityTime or 0) ) or 0\
\9\9self.verticalVelocityTime = 0\
\9\9if direction * verticalVelocity > 1 then\
\9\9\9self.verticalVelocity = -direction * math.abs(instantaneousVelocity + direction * SCROLL_SPEED) ^ SCROLL_ACCELERATION\
\9\9else\
\9\9\9self.verticalVelocity = -direction * SCROLL_SPEED\
\9\9end\
\9\9-- self:scroll( event.direction * SCROLL_SPEED )\
\9end\
\9return true\
end",["LoadedInterfaceEvent.lua"] = "\
class \"LoadedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.INTERFACE_LOADED;\
}",["ApplicationEventManager.lua"] = "\
class \"ApplicationEventManager\" extends \"EventManager\" {\
\9handlesGlobal = nil;\
}\
\
--[[\
\9@instance\
\9@desc Perfoms the appropriate handles for the given event and then trickles them down through the owner's children\
\9@param [Event] event -- the event to handle\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function ApplicationEventManager:handleEvent( event )\
\9-- run the before phase handles first\
\9if self:handleEventPhase( event, self.phase.BEFORE ) then\
\9\9return true\
\9end\
\
\9-- start trickling the event down\
\9local container = self.owner.container\
\9if container and container.event:handleEvent( event ) then\
\9\9return true\
\9end\
\
\9-- if nothing has killed the flow yet run the after phases\
\9return self:handleEventPhase( event, self.phase.AFTER )\
end\
\
function ApplicationEventManager:connectGlobal()\
\9error( \"Cannot connect global handle on ApplicationEventManager as it is the global handler. Use the class' own manager.\", 0 )\
end\
\
function ApplicationEventManager:disconnectGlobal()\
\9error( \"Cannot disconnect global handle on ApplicationEventManager as it is the global handler. Use the handler's own manager.\", 0 )\
end",["Resource.lua"] = "\
class \"Resource\" {\
\9path = false;\
\9contents = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a resource class, allowing ease resolving and loading of files\
\9@param [string] match -- the exact file name of the file\
\9@param [string] category -- the category (folder, such as classes, interfaces) to look in\
\9@param [boolean] allowDirectories -- default false, whether directories are able to be matched\
]]\
function Resource:initialise( name, category, allowDirectories )\
\9-- TODO: path tidying\
\9-- TODO: maybe do this backwards? so you can override files in other libraries\
\9\
\9-- search the resource tables\
\9local resourceTables = self.application.resourceTables\
\9if #resourceTables > 0 then\
\9\9for i = 1, #resourceTables do\
\9\9\9local categoryFiles = resourceTables[i][category]\
\9\9\9if categoryFiles then\
\9\9\9\9local contents = categoryFiles[name]\
\9\9\9\9if contents and ( allowDirectories or type( contents ) ~= \"table\" ) then\
\9\9\9\9\9self.contents = contents\
\9\9\9\9\9return\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9-- otherwise search the resource directories\
\9local function searchDirectories( path )\
\9\9if type( path ) == \"table\" then\
\9\9\9for i, _path in ipairs( path ) do\
\9\9\9\9local value = searchDirectories( _path .. \"/\" .. category )\
\9\9\9\9if value then return value end\
\9\9\9end\
\9\9elseif fs.exists( path ) and fs.isDir( path ) then\
\9\9\9local files = fs.list( path )\
\9\9\9for i, v in ipairs( files ) do\
\9\9\9\9local _path = path .. \"/\" .. v\
\9\9\9\9local isDir = fs.isDir( _path )\
\
\9\9\9\9-- TODO: bundles\
\9\9\9\9if ( allowDirectories or not isDir ) and name == v then\
\9\9\9\9\9return _path\
\9\9\9\9end\
\
\9\9\9\9if isDir then\
\9\9\9\9\9local value = searchDirectories( _path .. '/' )\
\9\9\9\9\9if value then return value end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9local path = searchDirectories( self.application.resourceDirectories )\
\9self.path = path or fase\
\
\9if path and not fs.isDir( path ) then\
\9\9local f = fs.open( path, \"r\" )\
\9\9if f then\
\9\9\9self.contents = f.readAll()\
\9\9\9f.close()\
\9\9end\
\9end\
end",["Event.lua"] = "\
class \"Event\" {\
\9\
\9relativeView = false; -- the view that the event is relative of\
\9eventType = false;\
\
\9isSentToChildren = true; -- whether the event will be passed to children\
\9isSentToSender = true; -- whether the event will be handled by the sender\
\
\9MOUSE_UP = \"mouse_up\";\
\9MOUSE_DOWN = \"mouse_click\";\
\9MOUSE_DRAG = \"mouse_drag\";\
\9MOUSE_SCROLL = \"mouse_scroll\";\
\9KEY_DOWN = \"key\";\
\9KEY_UP = \"key_up\";\
\9CHARACTER = \"char\";\
\9TIMER = \"timer\";\
\9TERMINATE = \"terminate\";\
\9MENU_CHANGED = \"interface_menu_changed\";\
\9INTERFACE_LOADED = \"interface_loaded\";\
\9KEYBOARD_SHORTCUT = \"interface_keyboard_shortcut\";\
\9FOCUS_CHANGED = \"interface_focus\";\
\9TEXT_CHANGED = \"interface_text\";\
\9SIBLING_ADDED = \"interface_sibling_added\";\
\9SIBLING_REMOVED = \"interface_sibling_removed\";\
\9PARENT_CHANGED = \"interface_parent_changed\";\
\9PARENT_RESIZED = \"interface_parent_resized\";\
\9INTERFACE_READY = \"interface_ready\";\
\9INTERFACE_OUTLET_CHANGED = \"interface_outlet_changed\";\
\9ACTION = \"interface_action\";\
\9THEME_CHANGED = \"interface_theme_changed\";\
\
}\
\
local eventClasses = {}\
\
--[[\
\9@static\
\9@desc Registers an Event subclass to a event type name (e.g. MouseDownEvent links with \"mouse_down\")\
\9@param [class] _class -- the class that was constructed\
]]\
function Event.register( eventType, subclass )\
\9eventClasses[eventType] = subclass\
end\
\
--[[\
\9@static\
\9@desc Registers an Event subclass after it has just been constructed\
\9@param [class] _class -- the class that was constructed\
]]\
function Event.constructed( _class )\
\9if _class.eventType then\
\9\9Event.register( _class.eventType, _class )\
\9end\
end\
\
--[[\
\9@static\
\9@desc Creates an event with the arguments in a table from os.pullEvent or similar function\
\9@param [Event.eventTypes] eventType -- the event type\
\9@param ... -- the event arguments\
\9@return [Event] event\
]]\
function Event.create( eventType, ... )\
\9if not eventType then error( \"No event type given to Event.create!\", 0 ) end\
\
\9local eventClass = eventClasses[eventType]\
\9if eventClass then\
\9\9return eventClass( ... )\
\9else\
\9\9return Event()\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Make the event relative to the supplied view\
\9@param [View] view -- the view to be relative to\
]]\
function Event:makeRelative( view )\
\9self.relativeView = view\
end",["MouseDownEvent.lua"] = "\
class \"MouseDownEvent\" extends \"MouseEvent\" {\
\9eventType = Event.MOUSE_DOWN;\
\9mouseButton = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.mouseButtons] mouseButton -- the mouse button (left, right, etc.)\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseDownEvent:initialise( mouseButton, x, y )\
\9self.mouseButton = mouseButton\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end",["KeyEvent.lua"] = "\
class \"KeyEvent\" extends \"Event\" {\
\9keyCode = false;\
\9keyString = false;\
\9isCharacter = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a key event from the arguments\
\9@param [number] keyCode -- the key's numerical key code\
]]\
function KeyEvent:initialise( keyCode )\
\9self.keyCode = keyCode\
\9self.keyString = KeyboardShortcutManager.convert( keyCode ) or false\
\9-- TODO: this needs testing\
\9self.isCharacter = (2 <= keyCode and keyCode <= 13) or (16 <= keyCode and keyCode <= 27) or (30 <= keyCode and keyCode <= 41) or (44 <= keyCode and keyCode <= 53)\
end",["Separator.lua"] = "\
class \"Separator\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.LIGHT_GREY;\
}\
\
function Separator:initialise( x, y, width, height )\
\9self.super:initialise( x, y, width, height )\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Separator:getFill()\
\9local fill = self.fill\
\9if fill then return fill end\
\9\
\9fill = {}\
\9for x = 1, self.width do\
\9\9local fillX = {}\
\9\9if x % 2 == 1 then\
\9\9\9for y = 1, self.height do\
\9\9\9\9if y % 2 == 1 then\
\9\9\9\9\9fillX[y] = true\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9fill[x] = fillX\
\9end\
\
\9self.fill = fill\
\9return fill\
end",["Container.lua"] = "\
class \"Container\" extends \"View\" {\
\9children = {};\
\9interfaceOutlets = {};\
\9interfaceName = false;\
\9offsetX = 0;\
\9offsetY = 0;\
}\
\
--[[\
\9@constructor\
\9@desc Initialises the container, linking up any InterfaceOutlets\
\9@param ...\
]]\
function Container:initialise( ... )\
\9self.super:initialise( ... )\
\9self:loadInterface()\
\9self:event( Event.INTERFACE_OUTLET_CHANGED, self.onInterfaceOutletChanged )\
end\
\
--[[\
\9@static\
\9@desc Creates a container from interface file\
\9@param [string] interfaceName -- the name of the interface file\
\9@param [class] _class -- the class that the container must extend (e.g. ApplicationContainer). If this is being called on a subclass you MUST pass in the class.\
\9@return [Container or _class] container -- the container\
]]\
function Container.fromInterface( interfaceName, _class )\
\9local interface = Interface( interfaceName, _class or Container )\
\9if interface then\
\9\9local container = interface.container\
\9\9container.interface = interface\
\9\9return container\
\9end\
end\
\
--[[\
    @instance\
    @desc Loads the children and properties of the interface specified by the self.interfaceName interface name. Called automatically during Container:init, do not call this yourself.\
]]\
function Container:loadInterface()\
    local interfaceName = self.interfaceName\
    if interfaceName then\
        local interface = Interface( interfaceName, self.class )\
        \
        local containerInterfaceProperties = self.interfaceProperties\
        for k, v in pairs( interface.properties ) do\
        \9if not containerInterfaceProperties or not containerInterfaceProperties[k] then -- if the interface defining THIS container specified this property then don't set it\
        \9\9self[k] = v\
        \9end\
        end\
\
        for i, childView in ipairs( interface.children ) do\
        \9self:insert( childView )\
        end\
    end\
end\
\
function Container:onInterfaceOutletChanged( event )\
\9local interfaceOutlet = event.interfaceOutlet\
\9local oldView = false\
\9local newView = false\
\9local interfaceOutletActions = false\
\9local BEFORE = EventManager.phase.BEFORE\
\9local ACTION = Event.ACTION\
\
\9for k, outlet in pairs( self.interfaceOutlets ) do\
\9\9if interfaceOutlet == outlet then\
\9\9\9oldView = oldView == false and event.oldView or oldView\
\9\9\9newView = newView == false and event.newView or newView\
\9\9\9if oldView ~= newView then\
\9\9\9\9interfaceOutletActions = interfaceOutletActions == false and self.interfaceOutletActions or interfaceOutletActions\
\9\9\9\9local func = interfaceOutletActions[k]\
\9\9\9\9if func then\
\9\9\9\9\9if oldView and #oldView == 0 then oldView.event:disconnect( ACTION, func, BEFORE, nil, self ) end\
\9\9\9\9\9if newView and #newView == 0 then newView:event( ACTION, func, BEFORE, nil, self ) end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
end\
\
--[[\
\9@instance\
\9@desc Called when a value is set. Connects InterfaceOutlets to the Container.\
\9@param [string] key -- the key of the set value\
    @param value -- the value\
]]\
function Container:set( key, value )\
\9if value and type( value ) == \"table\" and value.typeOf and value:typeOf( InterfaceOutlet ) then\
\9\9value:connect( key, self )\
\9elseif self.interfaceOutlets[key] and not value then\
\9\9self.interfaceOutlets[key]:disconnect()\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Initialises the custom container event manger\
]]\
function Container:initialiseEventManager()\
\9self.event = ContainerEventManager( self )\
end\
\
--[[\
\9@instance\
\9@desc Updates the view and it's children When overriding this self.super:update must be called AFTER the custom drawing code.\
\9@param [number] deltaTime -- the time since last update\
]]\
function Container:update( deltaTime )\
\9self.super:update( deltaTime )\
\9for i, childView in ipairs( self.children ) do\
\9\9childView:update( deltaTime )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Fired after\
\9@param [type] arg1 -- description\
\9@param [type] arg2 -- description\
\9@param [type] arg3 -- description\
\9@return [type] returnedValue -- description\
]]\
function Container:onParentResizedConstraintUpdateAfter( arg1, arg2, arg3 )\
\9return returnedValue\
end\
\
function Container:setWidth( width )\
\9self.super:setWidth( width )\
    width = self.width\
\9local event = self.event\
\9if event then\
\9\9event:handleEvent( ParentResizeInterfaceEvent( true, false, self ) )\
\9end\
end\
\
function Container:setHeight( height )\
\9self.super:setHeight( height )\
    height = self.height\
\9local event = self.event\
\9if event then\
\9\9event:handleEvent( ParentResizeInterfaceEvent( false, true, self ) )\
\9end\
end\
\
function Container:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    for i, childView in ipairs( self.children ) do\
    \9-- we need to update the isEnabled value for all children, the best way is just to send the current value\
    \9childView.isEnabled = childView.raw.isEnabled\
    end\
end\
\
--[[\
\9@instance\
\9@desc Moves the view to be the top of it's siblings\
\9@param [View] childView -- the view to make front most\
]]\
function Container:sendToFront( frontView, position )\
\9local children = self.children\
\9for i, childView in ipairs( children ) do\
\9\9if childView == frontView then\
\9\9\9table.remove( children, i )\
\9\9\9if position then table.insert( children, position, childView )\
\9\9\9else table.insert( children, childView ) end\
\9\9end\
\9end\
\9local frontCanvas = frontView.canvas\
\9local canvasChildren = self.canvas.children\
\9for i, childCanvas in ipairs( canvasChildren ) do\
\9\9if childCanvas == frontCanvas then\
\9\9\9table.remove( canvasChildren, i )\
\9\9\9if position then table.insert( canvasChildren, position, childCanvas )\
\9\9\9else table.insert( canvasChildren, childCanvas ) end\
\9\9end\
\9end\
\9\
\9-- TODO: screen order changed events?\
\9-- for i, childView in ipairs( self.children ) do\
\9-- \9local onSiblingsChanged = childView.onSiblingsChanged\
\9-- \9if onSiblingsChanged then onSiblingsChanged( childView ) end\
\9-- end\
\
\9self.canvas.hasChanged = true\
\9frontView.canvas.hasChanged = true\
end\
\
--[[\
\9@instance\
\9@desc Moves the view to be the bottom of it's siblings\
\9@param [View] childView -- the view to make botom most\
]]\
function Container:sendToBack( childView )\
\9self:sendToFront( childView, 1 )\
end\
\
--[[\
\9@instance\
\9@desc Adds a child view to the container (on the top by default)\
\9@param [View] childView -- the view to add to the container\
\9@param [number] position -- the z-position of the child (top by default). higher number means further back\
\9@return [View] childView -- the sent child view\
]]\
function Container:insert( childView, position )\
\9if position then\
\9\9table.insert( self.children, position, childView )\
\9else\
\9\9self.children[#self.children + 1] = childView\
\9end\
\
\9local oldParent = childView.parent \
\9childView.parent = self\
\9self.canvas:insert( childView.canvas )\
\9-- we need to update the isEnabled value\
\9childView.isEnabled = childView.raw.isEnabled\
\
\9for i, _childView in ipairs( self.children ) do\
\9\9if _childView == childView then\
\9\9\9_childView.event:handleEvent( ParentChangedInterfaceEvent( self, oldParent ) )\
\9\9else\
\9\9\9_childView.event:handleEvent( SiblingAddedInterfaceEvent( childView ) )\
\9\9end\
\9end\
\
\9local view = self\
\9while view do\
\9\9for key, interfaceOutlet in pairs( view.interfaceOutlets ) do\
\9\9\9if interfaceOutlet:childAdded( childView, view == self ) then\
\9\9\9\9view = false\
\9\9\9\9break\
\9\9\9end\
\9\9end\
\9\9view = view and view.parent\
\9end\
\9return childView\
end\
\
--[[\
\9@instance\
\9@desc Removes the first instance of the child view from the container\
\9@param [View] childView -- the view to add to the container\
\9@return [boolean] didRemove -- whether a child was removed\
]]\
function Container:remove( removingView )\
\9local didRemove = false\
\
\9for i, childView in ipairs( self.children ) do\
\9\9if childView == removingView then\
\9\9\9self.canvas:remove( removingView.canvas )\
\9\9\9table.remove( self.children, i )\
\9\9\9didRemove = true\
\9\9\9break\
\9\9end\
\9end\
\
\9for i, childView in ipairs( self.children ) do\
\9\9local onSiblingsChanged = childView.onSiblingsChanged\
\9\9if onSiblingsChanged then onSiblingsChanged( childView ) end\
\9end\
\
\9removingView.parent = nil\
\
\9if didRemove then\
\9\9local view = self\
\9\9while view do\
\9\9\9for key, interfaceOutlet in pairs( view.interfaceOutlets ) do\
\9\9\9\9interfaceOutlet:childRemoved( removingView )\
\9\9\9end\
\9\9\9view = view.parent\
\9\9end\
\9end\
\
\9return didRemove\
end\
\
--[[\
\9@instance\
\9@desc Returns the ( first ) child with the given identifier\
\9@param [string] identifier -- the identifier of the child view\
\9@param [boolean] descendTree -- true by default. whether child Containers should be looked through\
\9@return [View] childView -- the found child view\
]]\
function Container:findChild( identifier, descendTree )\
\9descendTree = (descendTree == nil and true or descendTree)\
\9for i, childView in ipairs( self.children ) do\
\9\9if childView.identifier == identifier then\
\9\9\9return childView\
\9\9end\
\
\9\9-- look in child Containers \
\9\9if descendTree and childView:typeOf( Container ) then\
\9\9\9local child = childView:findChild( identifier )\
\9\9\9if child then\
\9\9\9\9return child\
\9\9\9end\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns all children with the given identifier\
\9@param [string] identifier -- the identifier of the child view\
\9@param [boolean] descendTree -- true by default. whether child Containers should be looked through\
\9@return [table] childrenViews -- the table of the found found children views\
]]\
function Container:findChildren( identifier, descendTree )\
\9descendTree = (descendTree == nil and true or descendTree)\
\9\
\9local children = {}\
\9for i, childView in ipairs( self.children ) do\
\9\9if childView.identifier == identifier then\
\9\9\9table.insert( children, childView )\
\9\9end\
\
\9\9-- look in child Containers \
\9\9if descendTree and childView:typeOf( Container ) then\
\9\9\9local childChildren = childView:findChildren( identifier )\
\9\9\9for i2, childChild in ipairs( childChildren ) do\
\9\9\9\9table.insert( children, childChild )\
\9\9\9end\
\9\9end\
\9end\
\9return children\
end\
\
function Container:dispose()\
\9self.super:dispose()\
\9for i, childView in ipairs( self.children ) do\
\9\9childView:dispose()\
\9end\
end",["Animation.lua"] = "\
local math, assert, tostring, type = math, assert, tostring, type\
local pow, sin, cos, pi, sqrt, abs, asin = math.pow, math.sin, math.cos, math.pi, math.sqrt, math.abs, math.asin\
\
local function copyTables(destination, keysTable, valuesTable)\
    valuesTable = valuesTable or keysTable\
    local mt = getmetatable( keysTable )\
    if mt and getmetatable( destination ) == nil then\
        setmetatable(destination, mt)\
    end\
    for k,v in pairs( keysTable ) do\
        if type( v ) == \"table\" then\
            destination[k] = copyTables({}, v, valuesTable[k])\
        else\
            destination[k] = valuesTable[k]\
        end\
    end\
    return destination\
end\
\
local function performEasingOnSubject(subject, targetValues, initialValues, time, duration, easingFunc, round)\
    local t,b,c,d\
    for k,v in pairs( targetValues ) do\
        if type( v ) == \"table\" then\
            performEasingOnSubject(subject[k], v, initialValues[k], time, duration, easingFunc)\
        else\
            t,b,c,d = time, initialValues[k], v - initialValues[k], duration\
            if round then\
                subject[k] = math.floor( easingFunc( t,b,c,d ) + 0.5 )\
            else\
                subject[k] = easingFunc( t,b,c,d )\
            end\
        end\
    end\
end\
\
class \"Animation\" {\
\9easing = {};\
\9duration = nil;\
\9subject = nil;\
\9targetValues = nil;\
\9easingFunc = nil;\
\9initialValues = nil;\
\9time = nil;\
}\
\
--[[\
    @constructor\
    @desc Creates an animation instance for internal use\
    @param [number] duration -- the duration of the animation\
    @param [class] subject -- the subject of the animation\
    @param [class] targetValues -- the targetValues of the animation\
    @param [Animation.easing] easingFunc -- the easing function of the animation\
]]\
function Animation:initialise( duration, subject, targetValues, easingFunc, round )\
    self.duration = duration\
    self.subject = subject\
    self.targetValues = targetValues\
    self.easingFunc = easingFunc\
    self.round = round\
    self.initialValues = copyTables( {}, targetValues, subject )\
    self.time = 0\
end\
\
--[[\
\9@instance\
\9@desc Sets the animation to the specificed time point\
\9@param [number] time -- the time point\
\9@return [boolean] isComplete -- whether the animation is complete\
]]\
function Animation:setTime( time )\
\9assert( type(time ) == \"number\", \"time must be a positive number or 0\")\
\
\9self.time = time\
\
\9if self.time <= 0 then\
\9\9self.time = 0\
\9\9copyTables(self.subject, self.initialValues)\
\9elseif self.time >= self.duration then -- the tween has expired\
\9\9self.time = self.duration\
\9\9copyTables(self.subject, self.targetValues)\
\9else\
\9\9performEasingOnSubject(self.subject, self.targetValues, self.initialValues, self.time, self.duration, self.easingFunc, self.round)\
\9end\
\
\9return self.time >= self.duration\
end\
\
--[[\
\9@instance\
\9@desc Resets the animation back to the start\
\9@return [boolean] isComplete -- whether the animation is complete\
]]\
function Animation:reset()\
\9return self:setTime( 0 )\
end\
\
--[[\
\9@instance\
\9@desc Updates the animation given a change in time, returning true if the animation is complete\
\9@param [number] deltaTime -- the change in time since the last update\
\9@return [boolean] isComplete -- whether the animation is complete\
]]\
function Animation:update( deltaTime )\
\9return self:setTime( self.time + deltaTime )\
end\
\9\
\
-- easing functions --\
\
-- linear\
function Animation.easing.LINEAR( t, b, c, d )\
\9return c * t / d + b\
end\
\
-- quad\
function Animation.easing.IN_QUAD( t, b, c, d )\
\9return c * pow(t / d, 2) + b\
end\
\
function Animation.easing.OUT_QUAD( t, b, c, d )\
\9t = t / d\
\9return -c * t * (t - 2) + b\
end\
\
function Animation.easing.IN_OUT_QUAD( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(t, 2) + b end\
\9return -c / 2 * ((t - 1) * (t - 3) - 1) + b\
end\
\
function Animation.easing.OUT_IN_QUAD( t, b, c, d )\
\9if t < d / 2 then return outQuad(t * 2, b, c / 2, d) end\
\9return inQuad((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- cubic\
function Animation.easing.IN_CUBIC ( t, b, c, d )\
\9return c * pow(t / d, 3) + b\
end\
\
function Animation.easing.OUT_CUBIC( t, b, c, d )\
\9return c * (pow(t / d - 1, 3) + 1) + b\
end\
\
function Animation.easing.IN_OUT_CUBIC( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * t * t * t + b end\
\9t = t - 2\
\9return c / 2 * (t * t * t + 2) + b\
end\
\
function Animation.easing.OUT_IN_CUBIC( t, b, c, d )\
\9if t < d / 2 then return outCubic(t * 2, b, c / 2, d) end\
\9return inCubic((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- quart\
function Animation.easing.IN_QUART( t, b, c, d )\
\9return c * pow(t / d, 4) + b\
end\
\
function Animation.easing.OUT_QUART( t, b, c, d )\
\9return -c * (pow(t / d - 1, 4) - 1) + b\
end\
\
function Animation.easing.IN_OUT_QUART( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(t, 4) + b end\
\9return -c / 2 * (pow(t - 2, 4) - 2) + b\
end\
\
function Animation.easing.OUT_IN_QUART( t, b, c, d )\
\9if t < d / 2 then return outQuart(t * 2, b, c / 2, d) end\
\9return inQuart((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- quint\
function Animation.easing.IN_QUINT( t, b, c, d )\
\9return c * pow(t / d, 5) + b\
end\
\
function Animation.easing.OUT_QUINT( t, b, c, d )\
\9return c * (pow(t / d - 1, 5) + 1) + b\
end\
\
function Animation.easing.IN_OUT_QUINT( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(t, 5) + b end\
\9return c / 2 * (pow(t - 2, 5) + 2) + b\
end\
\
function Animation.easing.OUT_IN_QUINT( t, b, c, d )\
\9if t < d / 2 then return outQuint(t * 2, b, c / 2, d) end\
\9return inQuint((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- sine\
function Animation.easing.IN_SINE( t, b, c, d )\
\9return -c * cos(t / d * (pi / 2)) + c + b\
end\
\
function Animation.easing.OUT_SINE( t, b, c, d )\
\9return c * sin(t / d * (pi / 2)) + b\
end\
\
function Animation.easing.IN_OUT_SINE( t, b, c, d )\
\9return -c / 2 * (cos(pi * t / d) - 1) + b\
end\
\
function Animation.easing.OUT_IN_SINE( t, b, c, d )\
\9if t < d / 2 then return outSine(t * 2, b, c / 2, d) end\
\9return inSine((t * 2) -d, b + c / 2, c / 2, d)\
end\
\
-- expo\
function Animation.easing.IN_EXPO( t, b, c, d )\
\9if t == 0 then return b end\
\9return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001\
end\
\
function Animation.easing.OUT_EXPO( t, b, c, d )\
\9if t == d then return b + c end\
\9return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b\
end\
\
function Animation.easing.IN_OUT_EXPO( t, b, c, d )\
\9if t == 0 then return b end\
\9if t == d then return b + c end\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005 end\
\9return c / 2 * 1.0005 * (-pow(2, -10 * (t - 1)) + 2) + b\
end\
\
function Animation.easing.OUT_IN_EXPO( t, b, c, d )\
\9if t < d / 2 then return outExpo(t * 2, b, c / 2, d) end\
\9return inExpo((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- circ\
function Animation.easing.IN_CIRC( t, b, c, d )\
\9return(-c * (sqrt(1 - pow(t / d, 2)) - 1) + b)\
end\
\
function Animation.easing.OUT_CIRC( t, b, c, d )\
\9return(c * sqrt(1 - pow(t / d - 1, 2)) + b)\
end\
\
function Animation.easing.IN_OUT_CIRC( t, b, c, d )\
\9t = t / d * 2\
\9if t < 1 then return -c / 2 * (sqrt(1 - t * t) - 1) + b end\
\9t = t - 2\
\9return c / 2 * (sqrt(1 - t * t) + 1) + b\
end\
\
function Animation.easing.OUT_IN_CIRC( t, b, c, d )\
\9if t < d / 2 then return outCirc(t * 2, b, c / 2, d) end\
\9return inCirc((t * 2) - d, b + c / 2, c / 2, d)\
end\
\
-- elastic\
function Animation.easing.CALCULATE_P_A_S( p,a,c,d )\
\9p, a = p or d * 0.3, a or 0\
\9if a < abs( c ) then return p, c, p / 4 end -- p, a, s\
\9return p, a, p / (2 * pi) * asin( c/a ) -- p,a,s\
end\
\
function Animation.easing.IN_ELASTIC( t, b, c, d, a, p )\
\9local s\
\9if t == 0 then return b end\
\9t = t / d\
\9if t == 1 then return b + c end\
\9p,a,s = calculatePAS( p,a,c,d )\
\9t = t - 1\
\9return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b\
end\
\
function Animation.easing.OUT_ELASTIC( t, b, c, d, a, p )\
\9local s\
\9if t == 0 then return b end\
\9t = t / d\
\9if t == 1 then return b + c end\
\9p,a,s = calculatePAS( p,a,c,d )\
\9return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b\
end\
\
function Animation.easing.IN_OUT_ELASTIC( t, b, c, d, a, p )\
\9local s\
\9if t == 0 then return b end\
\9t = t / d * 2\
\9if t == 2 then return b + c end\
\9p,a,s = calculatePAS( p,a,c,d )\
\9t = t - 1\
\9if t < 0 then return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b end\
\9return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p ) * 0.5 + c + b\
end\
\
function Animation.easing.OUT_IN_ELASTIC( t, b, c, d, a, p )\
\9if t < d / 2 then return outElastic(t * 2, b, c / 2, d, a, p) end\
\9return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)\
end\
\
-- back\
function Animation.easing.IN_BACK( t, b, c, d, s )\
\9s = s or 1.70158\
\9t = t / d\
\9return c * t * t * ((s + 1) * t - s) + b\
end\
\
function Animation.easing.OUT_BACK( t, b, c, d, s )\
\9s = s or 1.70158\
\9t = t / d - 1\
\9return c * (t * t * ((s + 1) * t + s) + 1) + b\
end\
\
function Animation.easing.IN_OUT_BACK( t, b, c, d, s )\
\9s = (s or 1.70158) * 1.525\
\9t = t / d * 2\
\9if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end\
\9t = t - 2\
\9return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b\
end\
\
function Animation.easing.OUT_IN_BACK( t, b, c, d, s )\
\9if t < d / 2 then return outBack(t * 2, b, c / 2, d, s) end\
\9return inBack((t * 2) - d, b + c / 2, c / 2, d, s)\
end\
\
-- bounce\
function Animation.easing.OUT_BOUNCE( t, b, c, d )\
\9t = t / d\
\9if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end\
\9if t < 2 / 2.75 then\
\9\9t = t - (1.5 / 2.75)\
\9\9return c * (7.5625 * t * t + 0.75) + b\
\9elseif t < 2.5 / 2.75 then\
\9\9t = t - (2.25 / 2.75)\
\9\9return c * (7.5625 * t * t + 0.9375) + b\
\9end\
\9t = t - (2.625 / 2.75)\
\9return c * (7.5625 * t * t + 0.984375) + b\
end\
\
function Animation.easing.IN_BOUNCE( t, b, c, d )\
\9return c - outBounce(d - t, 0, c, d) + b\
end\
\
function Animation.easing.IN_OUT_BOUNCE( t, b, c, d )\
\9if t < d / 2 then return inBounce(t * 2, 0, c, d) * 0.5 + b end\
\9return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b\
end\
\
function Animation.easing.OUT_IN_BOUNCE( t, b, c, d )\
\9if t < d / 2 then return outBounce(t * 2, b, c / 2, d) end\
\9return inBounce((t * 2) - d, b + c / 2, c / 2, d)\
end",["FocusChangedInterfaceEvent.lua"] = "\
class \"FocusChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.FOCUS_CHANGED;\
\9newFocus = false; -- the new view that's being focused on. doesn't lose it's focus when it recieves this event.\
}\
\
--[[\
\9@constructor\
\9@desc Creates a focus event from the arguments\
\9@param newFocus -- the newFocus view (if any)\
]]\
function FocusChangedInterfaceEvent:initialise( newFocus )\
\9self.newFocus = newFocus\
end\
",["SiblingRemovedInterfaceEvent.lua"] = "\
class \"SiblingRemovedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.SIBLING_REMOVED;\
\9view = false; -- the new sibling that was removed\
\9isSentToChildren = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a siblings changed event from the arguments\
\9@param [View] view -- the removed sibling view\
]]\
function SiblingRemovedInterfaceEvent:initialise( view )\
\9self.view = view\
end",["GraphicsObject.lua"] = "\
class \"GraphicsObject\" {\
\9x = 1; -- @property x [number] - The x position of the object\
\9y = 1; -- @property y [number] - The y position of the object\
\9width = 0; -- @property width [number] - The width of the object\
\9height = 0; -- @property height [number] - The height of the object\
\9hasChanged = false; -- @property hasChanged [boolean] - Whether or not the object's internals have hasChanged since it was last drawn\
\9parent = nil; -- @property parent [View] - The parent of the object, if it exists\
\9outlineColour = Graphics.colours.TRANSPARENT; -- @property [Graphics.colours] -- The colour of the outline\
\9leftOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9topOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9rightOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9bottomOutlineWidth = 1; -- @property [number] -- The thickness of the outline\
\9fillColour = Graphics.colours.TRANSPARENT; -- @property [Graphics.colours] -- The fill colour of the object\
\9isVisible = true;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a graphics object\
\9@param [number] x -- the x coordinate of the graphics object\
\9@param [number] y -- the y coordinate of the graphics object\
\9@param [number] width -- the width of the graphics object\
\9@param [number] height -- the height of the graphics object\
]]\
function GraphicsObject:initialise( x, y, width, height )\
\9self.x = x\
\9self.y = y\
\9self.width = width\
\9self.height = height\
end\
\
--[[\
\9@instance\
\9@desc Sets the x coordinate of the graphics object\
\9@param [number] x -- the x coordinate of the graphics object\
]]\
function GraphicsObject:setX( x )\
\9if self.parent then\
\9\9self.parent.hasChanged = true\
\9end\
\9self.x = x\
end\
\
--[[\
\9@instance\
\9@desc Sets the y coordinate of the graphics object\
\9@param [number] y -- the y coordinate of the graphics object\
]]\
function GraphicsObject:setY( y )\
\9if self.parent then\
\9\9self.parent.hasChanged = true\
\9end\
\9self.y = y\
end\
\
--[[\
\9@instance\
\9@desc Sets the width of the graphics object\
\9@param [number] width -- the width of the graphics object\
]]\
function GraphicsObject:setWidth( width )\
\9self.hasChanged = true\
\9self.width = width\
end\
\
--[[\
\9@instance\
\9@desc Sets the height of the graphics object\
\9@param [number] height -- the height of the graphics object\
]]\
function GraphicsObject:setHeight( height )\
\9self.hasChanged = true\
\9self.height = height\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject:setOutlineWidth( outlineWidth )\
\9self.hasChanged = true\
\9self.leftOutlineWidth = outlineWidth\
\9self.topOutlineWidth = outlineWidth\
\9self.rightOutlineWidth = outlineWidth\
\9self.bottomOutlineWidth = outlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject:setLeftOutlineWidth( outlineWidth )\
\9self.hasChanged = true\
\9self.leftOutlineWidth = outlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject:setTopOutlineWidth( outlineWidth )\
\9self.hasChanged = true\
\9self.topOutlineWidth = outlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject:setRightOutlineWidth( outlineWidth )\
\9self.hasChanged = true\
\9self.rightOutlineWidth = outlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the outlineWidth of the graphics object\
\9@param [number] outlineWidth -- the outlineWidth of the graphics object\
]]\
function GraphicsObject:setBottomOutlineWidth( outlineWidth )\
\9self.hasChanged = true\
\9self.bottomOutlineWidth = outlineWidth\
end\
\
--[[\
\9@instance\
\9@desc Sets the fillColour of the graphics object\
\9@param [number] fillColour -- the fillColour of the graphics object\
]]\
function GraphicsObject:setFillColour( fillColour )\
\9self.hasChanged = true\
\9self.fillColour = fillColour\
end\
\
--[[\
\9@instance\
\9@desc Sets the visibility of the graphics object\
\9@param [boolean] isVisible -- whether the graphics object is visible\
]]\
function GraphicsObject:setIsVisible( isVisible )\
\9self.hasChanged = true\
\9self.isVisible = isVisible\
end\
\
--[[\
\9@instance\
\9@desc Sets the changed state of the graphics object, applying it to the parent too\
\9@param [boolean] hasChanged -- the changed state\
]]\
function GraphicsObject:setHasChanged( hasChanged )\
\9if hasChanged then\
\9\9local parent = self.parent\
\9\9if parent then\
\9\9\9parent.hasChanged = true\
\9\9end\
\9\9if self.fill then\
\9\9\9self.fill = nil\
\9\9end\
\9end\
\9self.hasChanged = hasChanged\
end\
\
--[[\
\9@instance\
\9@desc Sets the parent of the graphics object, removing the old one if it exists\
\9@param [boolean] hasChanged -- the parent\
]]\
function GraphicsObject:setParent( parent )\
\9if self.parent then\
\9\9self.parent:remove( self )\
\9end\
\9self.parent = parent\
\9if parent then\
\9\9parent:insert( self )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Generates the outline pixels from the given fill\
\9@param [table] fill -- the fill returned from self.getFill\
\9@return [table] outline -- the outline\
]]\
function GraphicsObject:getOutline( fill )\
\9local outline = {}\
\
\9local function xScanline( min, max, inc, outlineWidth )\
\9\9for y = 1, self.height do\
\9\9\9local lastX = 0\
\9\9\9local xPixels = 0\
\9\9\9for x = min, max, inc do\
\9\9\9\9outline[x] = outline[x] or {}\
\9\9\9\9if fill[x] and fill[x][y] then\
\9\9\9\9\9if xPixels < outlineWidth then\
\9\9\9\9\9\9xPixels = xPixels + 1\
\9\9\9\9\9\9outline[x][y] = true\
\9\9\9\9\9end\
\9\9\9\9\9lastX = x\
\9\9\9\9else\
\9\9\9\9\9xPixels = 0\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9local function yScanline( min, max, inc, outlineWidth )\
\9\9for x = 1, self.width do\
\9\9\9local lastY = 0\
\9\9\9local yPixels = 0\
\9\9\9for y = min, max, inc do\
\9\9\9\9if fill[x] and fill[x][y] then\
\9\9\9\9\9if yPixels < outlineWidth then\
\9\9\9\9\9\9yPixels = yPixels + 1\
\9\9\9\9\9\9outline[x][y] = true\
\9\9\9\9\9end\
\9\9\9\9\9lastX = x\
\9\9\9\9else\
\9\9\9\9\9yPixels = 0\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\
\9xScanline( 1, self.width, 1, self.leftOutlineWidth )\
\9xScanline( self.width, 1, -1, self.rightOutlineWidth )\
\9yScanline( 1, self.height, 1, self.topOutlineWidth )\
\9yScanline( self.height, 1, -1, self.bottomOutlineWidth )\
\
\9return outline\
end\
\
--[[\
\9@instance\
\9@desc Draws a the graphics object to the canvas\
\9@param [Canvas] canvas -- the canvas to draw to\
\9@return self\
]]\
function GraphicsObject:drawTo( canvas )\
\9if self.isVisible then\
\9\9local fill = self.fill\
\9\9local outline\
\9\9if self.outlineColour ~= Graphics.colours.TRANSPARENT then\
\9\9\9outline = self:getOutline( fill )\
\9\9end\
\
\9\9local fillColour = self.fillColour\
\9\9local outlineColour = self.outlineColour\
\9\9local _x = self.x - 1\
\9\9local _y = self.y - 1\
\
\9\9local buffer = canvas.buffer\
\9\9local width, height = canvas.width, canvas.height\
\9\9local TRANSPARENT = Graphics.colours.TRANSPARENT\
\9\9local function setPixel( x, y, colour )\
\9\9\9if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= width and y <= height then\
\9\9\9\9buffer[ ( y - 1 ) * width + x ] = colour\
\9\9\9end\
\9\9\9return canvas\
\9\9end\
\
\9\9if fill then\
\9\9\9for x, row in pairs( fill ) do\
\9\9\9\9local outlineX = outline and outline[x]\
\9\9\9\9for y, _ in pairs( row ) do\
\9\9\9\9\9if not outline or not outlineX or not outlineX [y] then\
\9\9\9\9\9\9setPixel( _x + x, _y + y, fillColour )\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\
\9\9if outline then\
\9\9\9for x, row in pairs( outline ) do\
\9\9\9\9for y, _ in pairs( row ) do\
\9\9\9\9\9setPixel( _x + x, _y + y, outlineColour )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9\
\9return self\
end",["InterfaceOutletChangedInterfaceEvent.lua"] = "\
class \"InterfaceOutletChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.INTERFACE_OUTLET_CHANGED;\
\9interfaceOutlet = false;\
\9oldView = false;\
\9newView = false;\
\9isSentToChildren = false;\
\9isSentToSender = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a focus event from the arguments\
\9@param interfaceOutlet -- the interface outlet that changed\
\9@param newView -- the new view the outlet is bound to\
\9@param oldView -- the old view the outlet was bound to\
]]\
function InterfaceOutletChangedInterfaceEvent:initialise( interfaceOutlet, newView, oldView )\
\9self.interfaceOutlet = interfaceOutlet\
\9self.newView = newView\
\9self.oldView = oldView\
end",["Text.lua"] = "\
class \"Text\" extends \"GraphicsObject\" {\
\9font = nil;\
\9text = nil;\
\9textColour = nil;\
\9alignment = Font.alignments.LEFT\
}\
\
function Text:initialise( x, y, width, height, text, font, textColour )\
\9self.super:initialise( x, y, width, height )\
\9self.text = text\
\9self.font = font\
\9self.textColour = textColour\
end\
\
--[[\
\9@instance\
\9@desc Sets the font of the text object\
\9@param [number] font -- the font of the text object\
]]\
function GraphicsObject:setFont( font )\
\9self.hasChanged = true\
\9self.font = font\
end\
\
--[[\
\9@instance\
\9@desc Sets the text of the text object\
\9@param [number] text -- the text of the text object\
]]\
function GraphicsObject:setText( text )\
\9self.hasChanged = true\
\9self.text = text\
end\
\
--[[\
\9@instance\
\9@desc Draws a the text to the canvas\
\9@param [Canvas] canvas -- the canvas to draw to\
\9@return self\
]]\
function Text:drawTo( canvas )\
\9if self.isVisible then\
\9\9local font = self.font\
\9\9local width = self.width\
\
\9\9-- TODO: font alignment\
\9\9local fontWidth = font:getWidth( self.text )\
\9\9local x = 1\
\9\9local alignment = self.alignment\
\9\9if alignment == Font.alignments.CENTRE then\
\9\9\9error( \"TODO: Font.alignments.CENTRE\" )\
\9\9\9-- x = math.floor( width / 2 - fontWidth / 2 + 1 )\
\9\9elseif alignment == Font.alignments.RIGHT then\
\9\9\9x = width - fontWidth + 1\
\9\9end\
        font:render( canvas, self.text, self.x + x - 1, self.y, self.textColour )\
\9end\
\9return self\
end",["ScrollContainer.lua"] = "\
class \"ScrollContainer\" extends \"Container\" {\
\9\
}",["ScrollbarGrabber.lua"] = "\
class \"ScrollbarGrabber\" extends \"GraphicsObject\" {\
\9lines = 4;\
}\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function ScrollbarGrabber:getFill()\
\9local height = self.height\
\9local width = self.width\
\9local lines = self.lines\
\
\9local fill = {}\
\9local startY = math.ceil( ( height - 2 * lines + 1 ) / 2 )\
\9for x = 1, width do\
\9\9fill[x] = fill[x] or {}\
\9\9for y = startY, startY + 2 * lines - 1, 2 do\
\9\9\9fill[x][y] = true\
\9\9end\
\9end\
\
\9return fill\
end",["MouseEvent.lua"] = "\
class \"MouseEvent\" extends \"Event\" {\
\9x = 0;\
\9y = 0;\
\9globalX = 0;\
\9globalY = 0;\
\
\9mouseButtons = {\
\9\9LEFT = 1;\
\9\9MIDDLE = 3;\
\9\9RIGHT = 2;\
\9};\
\
\9directions = {\
\9\9UP = -1;\
\9\9DOWN = 1;\
\9};\
}\
\
\
--[[\
\9@instance\
\9@desc Make the event's coordinates relative to the supplied view\
\9@param [View] view -- the view who's coordinate system will be used\
]]\
function MouseEvent:makeRelative( view )\
\9if not view then end\
\9local oldRelativeView = self.relativeView\
\9self.super:makeRelative( view )\
\9\
\9local x, y = self.x, self.y\
\
\9if oldRelativeView and oldRelativeView == view then\
\9\9-- return\
\9elseif oldRelativeView and oldRelativeView == view.parent then\
\9\9-- we are going 1 downward in to the stack\
\9\9x = x - view.x + 1\
\9\9y = y - view.y + 1\
\
\9elseif oldRelativeView and oldRelativeView.parent == view then\
\9\9-- we are going 1 upward in to the stack\
\9\9x = x + oldRelativeView.x - 1\
\9\9y = y + oldRelativeView.y - 1\
\9else\
\9\9-- we don't known exactly where the previous view was\
\9\9x, y = view:coordinates( self.globalX, self.globalY, self.application.container )\
\9end\
\9self.x = x\
\9self.y = y\
end",["AlertWindow.lua"] = "\
class \"AlertWindow\" extends \"Window\" {\
\9interfaceName = \"alert\";\
\9okayButton = InterfaceOutlet( \"okayButton\" );\
}\
\
function AlertWindow:initialise( ... )\
\9self.super:initialise( ... )\
\
\9self:event( Event.INTERFACE_LOADED, self.onInterfaceLoaded )\
\9self:event( Event.INTERFACE_READY, self.onReady )\
\
\9self.width = 100\
\9self.height = 40\
end\
\
function AlertWindow:onReady( event )\
\9self:centre()\
\9self:focus()\
\9self.okayButton:focus()\
end",["Canvas.lua"] = "\
class \"Canvas\" extends \"GraphicsObject\" {\
    fillColour = Graphics.colours.TRANSPARENT; -- The colour of the Canvas when it clears\
    buffer = {};\
    children = {};\
}\
\
--[[\
    @constructor\
    @desc Creates a canvas\
    @param [number] width -- the width of the canvas\
    @param [number] height -- the height of the canvas\
]]\
-- function Canvas:initialise( width, height )\
--     self.buffer = {}\
--     self.children = {}\
--     self.width = width\
--     self.height = height\
-- end\
\
--[[\
    @instance\
    @desc Sets the pixel colour and the given coordinates\
    @param [number] x -- the x coordinate of the pixel\
    @param [number] y -- the y coordinate of the pixel\
    @param [colour] colour -- the colour coordinate of the pixel\
]]\
function Canvas:setPixel( x, y, colour )\
    if colour ~= Graphics.colours.TRANSPARENT and x >= 1 and y >= 1 and x <= self.width and y <= self.height then\
        self.buffer[ ( y - 1 ) * self.width + x ] = colour\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Gets the pixel colour and the given coordinates\
    @param [number] x -- the x coordinate of the pixel\
    @param [number] y -- the y coordinate of the pixel\
    @return [colour] colour -- the colour of the pixel\
]]\
function Canvas:getPixel( x, y )\
    return self.buffer[ ( y - 1 ) * self.width + x ] or self.fillColour\
end\
\
--[[\
    @instance\
    @desc Clears the buffer\
    @return self\
]]\
function Canvas:clear()\
    self.buffer = {}\
    return self\
end\
\
--[[\
    @instance\
    @desc Adds a shader to screen area\
    @param [Canvas.shader] shader -- the shader to use\
    @param [number] x -- default 1, the x coordinate of the area\
    @param [number] y -- default 1, the y coordinate of the area\
    @param [number] width -- default canvas width, the width of the area\
    @param [number] height -- default canvas height, the height of the area\
    @return self\
]]\
function Canvas:map( shader, x, y, width, height )\
    local changes = {}\
    for _x = x or 1, ( x or 1 ) + ( width or self.width ) - 1 do\
        for _y = y or 1, ( x or 1 ) + ( height or self.height ) - 1 do\
            local colour = shader( _x, _y, self:getPixel( _x, _y ) )\
            if colour and colour ~= 0 then\
                changes[#changes + 1] = { _x, _y, colour }\
            end\
        end\
    end\
    local buffer = self.buffer\
    local width, height = self.width, self.height\
    local TRANSPARENT = Graphics.colours.TRANSPARENT\
    local function setPixel( x, y, colour )\
        if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= width and y <= height then\
            buffer[ ( y - 1 ) * width + x ] = colour\
        end\
        return self\
    end\
    for i = 1, #changes do\
        setPixel( unpack( changes[i] ) )\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Adds a graphics object to the canvas\
    @param [GraphicsObject] graphicsObject -- the graphics object to add\
    @return self\
]]\
function Canvas:insert( graphicsObject )\
    graphicsObject = graphicsObject\
    self.hasChanged = true\
    if graphicsObject.parent then\
        graphicsObject.parent:remove( graphicsObject )\
    end\
    graphicsObject.parent = self\
    self.children[#self.children + 1] = graphicsObject\
    return graphicsObject\
end\
\
--[[\
    @instance\
    @desc Removes a graphics object from the canvas\
    @param [GraphicsObject] graphicsObject -- the graphics object to remove\
    @return self\
]]\
function Canvas:remove( graphicsObject )\
    graphicsObject = graphicsObject\
    local c = false\
    for i = #self.children, 1, -1 do\
        if self.children[i] == graphicsObject then\
            graphicsObject.parent = nil\
            table.remove( self.children, i )\
            c = true\
        end\
    end\
    if c then\
        self.hasChanged = true\
    end\
    return graphicsObject\
end\
\
--[[\
    @instance\
    @desc Clears the buffer then draws the objects of the canvas\
    @return self\
]]\
function Canvas:draw()\
    if self.isVisible then\
        self.buffer = {}\
        local children = self.children\
        for i = 1, #children do\
            children[i]:drawTo( self )\
        end\
        self.hasChanged = false\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Draws the canvas to another canvas\
    @param [Canvas] canvas -- the canvas to draw to\
    @return self\
]]\
function Canvas:drawTo( canvas )\
    if self.isVisible then\
        if self.hasChanged then\
            local drawdt = os.clock()\
            self:draw()\
            -- log( tostring( self ) .. 'is rerendering dt ' .. os.clock() - drawdt )\
        end\
        \
        local width = self.width\
        local height = self.height\
        local fillColour = self.fillColour\
        local buffer = self.buffer\
        local _x = self.x - 1\
        local _y = self.y\
        \
\
        local start = os.clock()\
        -- log( tostring( self ) .. 'is drawing to parent at ' .. os.clock() )\
\
        local canvasWidth = canvas.width\
        local canvasHeight = canvas.height\
        local canvasBuffer = canvas.buffer\
        local TRANSPARENT = Graphics.colours.TRANSPARENT\
        for x = 1, width do\
            for y = 0, height - 1 do -- just so there's no need for y-1 below\
                local colour = buffer[y * width + x] or fillColour\
                local nx, ny = x + _x, y + _y\
                if colour ~= TRANSPARENT and nx >= 1 and ny >= 1 and nx <= canvasWidth and ny <= canvasHeight then\
                    canvasBuffer[( ny - 1 ) * canvasWidth + nx] = colour\
                end\
            end\
        end\
\
        -- log( tostring( self ) .. 'is done drawing to parent dt ' .. os.clock() - start )\
\
    end\
    return self\
end\
\
--[[\
    @instance\
    @desc Hit tests the canvas' buffer to see if the colour is set (return false if transparent)\
    @param [number] x -- the x coordinate to hit test\
    @param [number] y -- the y coordinate to hit test\
    @return [boolean] didHit -- whether the colour was set/not transparent\
]]\
function Canvas:hitTest( x, y )\
    return self:getPixel( x, y ) ~= 0\
end",["KeyUpEvent.lua"] = "\
class \"KeyUpEvent\" extends \"KeyEvent\" {\
\9eventType = Event.KEY_UP;\
}",["Font.lua"] = "\
local floor, ceil = math.floor, math.ceil\
local cache = {}\
\
local function readstring( handle )\
\9local v = handle.read()\
\9local s = \"\"\
\9while v ~= 0 do\
\9\9s = s .. string.char( v )\
\9\9v = handle.read()\
\9end\
\9return s\
end\
local function writestring( handle, text )\
\9for i = 1, #text do\
\9\9handle.write( text:byte( i ) )\
\9end\
end\
\
local function renderCharacterScaledDown( setPixel, character, _x, _y, cw, ch, scale, colour )\
\9_x = _x - 1\
\9_y = _y - 1\
\9for x = 1, cw do\
\9\9for y = 1, ch do\
\9\9\9if character[y] and character[y][x] then\
\9\9\9\9setPixel( ceil( _x + x * scale - .5 ), ceil( _y + y * scale - .5 ), colour )\
\9\9\9end\
\9\9end\
\9end\
end\
\
local no_char_map = {\
\9width = 5;\
\9{ true,  true,  true,  true, true };\
\9{ true, false, false, false, true };\
\9{ true, false, false, false, true };\
\9{ true, false, false, false, true };\
\9{ true, false, false, false, true };\
\9{ true,  true,  true,  true, true };\
}\
\
class \"Font\" {\
\9height = 0;\
\9desiredHeight = 0;\
\9spacing = 1;\
\
\9alignments = {\
\9\9LEFT = 0;\
\9\9CENTER = 1;\
\9\9RIGHT = 2;\
\9\9JUSTIFIED = 3;\
\9};\
}\
\
--[[\
\9@constructor\
\9@desc Create a font with the given name\
\9@param [string] fontName -- the name of the desired font\
\9@param [number] desiredHeight -- the height of the desired font\
\9@param [boolean] reload -- default is false, whether the cache should be ignored and the font reloaded\
]]\
function Font:initialise( name, desiredHeight, reload )\
\9local characters, height\
\9desiredHeight = desiredHeight or 8\
\9if cache[name] and cache[name][desiredHeight] and not reload then\
\9\9characters, height = cache[name][desiredHeight][1], cache[name][desiredHeight][2]\
\9else\
\9\9local resource = Resource( name .. \".sfont\", \"fonts\" )\
\9\9characters, height = BitmapFont.decodeResource( resource )\
\9\9cache[name] = cache[name] or {}\
\9\9cache[name][desiredHeight] = { characters, height }\
\9end\
\9self.characters = characters\
\9self.height = height\
\9self.desiredHeight = desiredHeight or height\
\9self.scale = ( desiredHeight or height ) / height\
end\
\
function Font.initialisePresets()\
\9-- TODO: make this come from the theme\
\9Font.systemFont = Font( \"Auckland\" )\
end\
\
function Font.readMetadata( file )\
\9local h = fs.open( file, \"rb\" )\
\9if h then\
\9\9local metadata = {}\
\9\9local v = h.read()\
\9\9while v == 0 do\
\9\9\9local key, value = readstring( h ), readstring( h )\
\9\9\9metadata[key] = value\
\9\9\9v = h.read()\
\9\9end\
\9\9h.close()\
\9\9return metadata\
\9end\
end\
\
function Font.encodeFile( file, characters, height, metadata )\
\9local h = fs.open( file, \"wb\" )\
\9if h then\
\9\9for k, v in pairs( metadata or {} ) do\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( k ) )\
\9\9\9h.write( 0 )\
\9\9\9writestring( h, tostring( v ) )\
\9\9\9h.write( 0 )\
\9\9end\
\9\9h.write( 1 )\
\9\9h.write( height )\
\9\9local bytes\
\9\9if metadata.fontType == \"vector\" then\
\9\9\9bytes = BitmapFont.encodeSet( characters, height )\
\9\9else\
\9\9\9bytes = VectorFont.encodeSet( characters, height )\
\9\9end\
\9\9for _, byte in ipairs( bytes ) do\
\9\9\9h.write( byte )\
\9\9end\
\9\9h.close()\
\9\9return true\
\9end\
end\
\
function Font.decodeResource( resource )\
\9local contents = resource.contents\
\9if contents then\
\9\9local i = 1\
\9\9local contentsLen = #contents\
\9\9local b = string.byte\
\9\9local h = {}\
\
\9\9function h.read()\
\9\9\9if i <= contentsLen then\
\9\9\9\9local value = b( contents:sub( i, i ) )\
\9\9\9\9i = i + 1\
\9\9\9\9return value\
\9\9\9end\
\9\9end\
\
\9\9return Font.decodeHandle( h )\
\9end\
end\
\
function Font.decodeFile( file )\
\9local h = fs.open( file, \"rb\" )\
\9return Font.decodeHandle( h )\
end\
\
function Font.decodeHandle( h )\
\9if h then\
\9\9local metadata = {}\
\9\9local v = h.read()\
\9\9while v == 0 do\
\9\9\9local key, value = readstring( h ), readstring( h )\
\9\9\9metadata[key] = value\
\9\9\9v = h.read()\
\9\9end\
\9\9local height = h.read()\
\9\9local bytes = {}\
\9\9for byte in h.read do\
\9\9\9bytes[#bytes + 1] = byte\
\9\9end\
\
\9\9local fontType = metadata.fontType\
\9\9local characters\
\
\9\9if fontType == \"bitmap\" then\
\9\9\9characters = BitmapFont.decodeSet( bytes, height )\
\9\9else\
\9\9\9characters = VectorFont.decodeSet( bytes, height )\
\9\9end\
\9\9return characters, height, metadata\
\9end\
end\
\
function Font:getHeight()\
\9return self.height\
end\
\
function Font:getWidth( text )\
\9if not text then return 0 end\
\9local width = 0\
\9local scale, characters, desiredHeight, spacing = self.scale, self.characters, self.desiredHeight, self.spacing\
\9for i = 1, #text do\
\9\9local char = text:byte( i )\
\9\9local scale, bitmap = scale -- localise scale so it can be changed if the character isn't defined\
\9\9if characters[char] then\
\9\9\9bitmap = characters[char]\
\9\9else\
\9\9\9bitmap = no_char_map\
\9\9\9scale = desiredHeight / 6\
\9\9end\
\9\9width = width + bitmap.width * scale + spacing * scale\
\9end\
\9return width\
end\
\
function Font:getRawWidth( text )\
\9if not text then return 0 end\
\9local width = 0\
\9local scale, characters, desiredHeight, spacing = self.scale, self.characters, self.desiredHeight, self.spacing\
\9for i = 1, #text do\
\9\9local char = text:byte( i )\
\9\9local scale, bitmap = scale -- localise scale so it can be changed if the character isn't defined\
\9\9if characters[char] then\
\9\9\9bitmap = characters[char]\
\9\9else\
\9\9\9bitmap = no_char_map\
\9\9\9scale = desiredHeight / 6\
\9\9end\
\9\9width = width + bitmap.width * scale\
\9end\
\9return width\
end\
\
function Font:render( canvas, text, x, y, colour )\
\9y = y - 1\
\9x = x - 1\
\9text = text == nil and \"\" or tostring( text )\
\9local buffer = canvas.buffer\
\9local width, height, _height = canvas.width, canvas.height, self.height\
\9local TRANSPARENT = Graphics.colours.TRANSPARENT\
\9local scale, characters, desiredHeight, spacing = self.scale, self.characters, self.desiredHeight, self.spacing\
\9local function setPixel( x, y, colour )\
\9\9if colour ~= TRANSPARENT and x >= 1 and y >= 1 and x <= width and y <= height then\
\9        buffer[ ( y - 1 ) * width + x ] = colour\
\9    end\
\9end\
\9for i = 1, #text do\
\9\9local char = text:byte( i )\
\9\9local bitmap\
\9\9if characters[char] then\
\9\9\9bitmap = characters[char]\
\9\9else\
\9\9\9bitmap = no_char_map\
\9\9\9scale = desiredHeight / 6\
\9\9end\
\9\9local cwidth = bitmap.width * scale\
\9\9if scale < 1 then\
\9\9\9renderCharacterScaledDown( setPixel, bitmap, x, y, bitmap.width, _height, scale, colour )\
\9\9else\
\9\9\9for _y = 1, desiredHeight do\
\9\9\9\9for _x = 1, ceil( cwidth ) do\
\9\9\9\9\9local bx, by = ceil( _x / scale ), ceil( _y / scale )\
\9\9\9\9\9local char_is_on = bitmap[by] and bitmap[by][bx]\
\9\9\9\9\9if char_is_on then\
\9\9\9\9\9\9setPixel( floor( x + _x + .5 ), floor( y + _y + .5 ), colour ) -- oh no, not this...\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9\9x = x + cwidth + spacing * scale\
\9end\
end",["Cursor.lua"] = "\
class \"Cursor\" extends \"GraphicsObject\" {\
\9fillColour = Graphics.colours.BLACK;\
}\
\
function Cursor:initialise( x, y, height )\
\9self.super:initialise( x, y, 1, height )\
end\
\
--[[\
    @instance\
    @desc Gets the pixes to be filled\
    @return [table] fill -- the pixels to fill\
]]\
function Cursor:getFill()\
\9if self.fill then return self.fill end\
\9local fill = {}\
\9local fillX = {}\
\9for y = 1, self.height do\
\9\9fillX[y] = true\
\9end\
\9fill[1] = fillX\
\9return fill\
end",["EventManager.lua"] = "\
class \"EventManager\" {\
\9owner = false;\
\9handles = {};\
\9handlesGlobal = {};\
\
\9-- functions can be called either before or after tickle down\
\9phase = {\
\9\9BEFORE = 1;\
\9\9AFTER = 2;\
\9};\
}\
\
\
--[[\
\9@constructor\
\9@desc Creates an EventManager for the provided owner, with owner reverting to the EventManager instance\
\9@param [class] owner -- the owner of the EventManger (i.e. what self will be on function calls)\
]]\
function EventManager:initialise( owner )\
\9self.owner = owner or self\
\9self.owner = self.owner\
\
\9-- allow the class to be called as a shorthand for :connect\
\9self.mt.__call = function(self, _, ...) return self:connect( ... ) end\
\9setmetatable( self, self.mt )\
end\
\
--[[\
\9@instance\
\9@desc Subscribes a function to the given event\
\9@param [Event.eventType] eventType -- the name of the event type\
\9@param [EventManager] eventManager -- the handle manager \
\9@param [function] func -- the function called when the event occurs\
\9@param [class] sender -- the value passed as self. defaults to eventManager.owner\
]]\
function EventManager:connect( eventType, func, phase, eventManager, sender )\
\9if not eventType then error( \"No event type given to EventManager:connect!\", 2 ) end\
\9\
\9if func and type( func ) == \"function\" then\
\9\9phase = phase or EventManager.phase.BEFORE\
\9\9eventManager = eventManager or self\
\9\9self:disconnect( eventType, func, phase, eventManager, sender ) -- ensure duplicates won't be made\
\
\9\9if not self.handles[eventType] then\
\9\9\9self.handles[eventType] = {}\
\9\9end\
\
\9\9table.insert( self.handles[eventType], { func, phase, eventManager, sender or eventManager.owner } )\
\9else\
\9\9error( \"Attempted to connect non-function to event: \" .. eventType .. ' for class: ' .. tostring( self.owner or nil ), 0 )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Unsubscribes a function to the given event\
\9@param [Event.eventType] eventType -- the name of the event type\
\9@param [function] func -- the function called when the event occurs\
\9@param [class] sender -- the value passed as self. defaults to eventManager.owner\
]]\
function EventManager:disconnect( eventType, func, phase, eventManager, sender )\
\9phase = phase or EventManager.phase.BEFORE\
\9eventManager = eventManager or self\
\9sender = sender or eventManager.owner\
\
\9if self.handles[eventType] then\
\9\9for i, handle in pairs( self.handles[eventType] ) do\
\9\9\9if handle[1] == func and handle[2] == phase and handle[3] == eventManager and handle[4] == sender then\
\9\9\9\9self.handles[eventType][i] = nil\
\9\9\9end\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Subscribes a function globally to the given event\
\9@param [Event.eventType] eventType -- the name of the event type\
\9@param [function] func -- the function called when the event occurs\
]]\
function EventManager:connectGlobal( eventType, func, phase, sender )\
\9if func and type( func ) == \"function\" then\
\9\9phase = phase or EventManager.phase.BEFORE\
\9\9sender = sender or self.owner\
\9\9self:disconnectGlobal( eventType, func, phase, sender ) -- ensure duplicates won't be made\
\
\9\9if not self.handlesGlobal[eventType] then\
\9\9\9self.handlesGlobal[eventType] = {}\
\9\9end\
\
\9\9table.insert( self.handlesGlobal[eventType], { func, phase, sender } )\
\9\9self.application.event:connect( eventType, func, phase, self, sender )\
\9else\
\9\9error( \"Attempted to connect non-function to global event: \" .. eventType .. ' for class: ' .. tostring( self.owner or nil ), 0 )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Unsubscribes a function to globally the given event\
\9@param [Event.eventType] eventType -- the name of the event type\
\9@param [function] func -- the function called when the event occurs\
]]\
function EventManager:disconnectGlobal( eventType, func, phase, sender, eventManager )\
\9phase = phase or EventManager.phase.BEFORE\
\9sender = sender or self.owner\
\9self.application.event:disconnect( eventType, func, phase, self, sender )\
\
\9if self.handlesGlobal[eventType] then\
\9\9for i, handle in pairs( self.handlesGlobal[eventType] ) do\
\9\9\9if handle[1] == func and handle[2] == phase and handle[3] == eventManager and handle[4] == sender then\
\9\9\9\9self.handlesGlobal[eventType][i] = nil\
\9\9\9end\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Unsubscribes all global events\
]]\
function EventManager:disconnectAllGlobals()\
\9for eventType, v in pairs( self.handlesGlobal ) do\
\9\9for i, handle in pairs( v ) do\
\9\9\9self.application.event:disconnect( eventType, handle[1], handle[2], handle[3], self)\
\9\9\9v[i] = nil\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the EventManager has any handles for the given type\
\9@param [Event.eventType] eventType -- the name of the even type\
\9@return [boolean] hasConnections\
]]\
function EventManager:hasConnections( eventType )\
\9return self.handles[eventType] and #self.handles[eventType] >= 1\
end\
\
--[[\
\9@instance\
\9@desc Returns true if the EventManager has any global handles for the given type\
\9@param [Event.eventType] eventType -- the name of the even type\
\9@return [boolean] hasConnections\
]]\
function EventManager:hasConnectionsGlobal( eventType )\
\9return self.handlesGlobal[eventType] and #self.handlesGlobal[eventType] >= 1\
end\
\
--[[\
\9@instance\
\9@desc Perfoms the appropriate handles for the given event\
\9@param [Event] event -- the event to handle\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function EventManager:handleEvent( event )\
\9if self:handleEventPhase( event, self.phase.BEFORE ) then\
\9\9return true\
\9end\
\
\9if self:handleEventPhase( event, self.phase.AFTER ) then\
\9\9return true\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Performs the handles for a specific phase\
\9@param [Event] event -- the event to handle\
\9@param [EventManager.phase] phase -- the phase desired\
\9@return [boolean] stopPropagation -- whether no further handles should recieve this event\
]]\
function EventManager:handleEventPhase( event, phase )\
\9if self.handles[event.eventType] then\
\9\9for i, handle in pairs( self.handles[event.eventType] ) do\
\9\9\9if handle and phase == handle[2] then\
\9\9\9\9-- handle[1] is the handle function\
\9\9\9\9-- handle[2] is the phase\
\9\9\9\9-- handle[3] is the event manager\
\9\9\9\9-- handle[4] is the sender\
\9\9\9\9if handle[1]( handle[4], event, handle[2] ) then\
\9\9\9\9\9return true\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
end\
\
function EventManager:dispose()\
\9self:disconnectAllGlobals()\
end",["ScreenCanvas.lua"] = "\
class \"ScreenCanvas\" extends \"Canvas\" {\
\9fillColour = Graphics.colours.LIGHT_BLUE;\
\9drawn = {};\
}\
\
--[[\
\9@instance\
\9@desc Draws the canvas to the terminal/screen provided\
\9@param [term] terminal -- the terminal object to draw to\
\9@return self\
]]\
function ScreenCanvas:drawToTerminal( terminal )\9\
    if self.isVisible then\
\9\9if self.hasChanged then\
\9\9\9local startScr = os.clock()\
        \9-- log( 'Starting ScreenCanvas:draw() at ' .. startScr )\
\
\9\9\9self:draw()\
        \9-- log( 'Finished ScreenCanvas:draw() dt: ' .. os.clock() - startScr )\
\
        \9-- log( 'Starting render to screen at ' .. os.clock() )\
\
\9\9\9terminal = terminal or term\
\
\9\9\9local currentLength, currentX, currentY, currentColour\
\9\9\9local function draw()\
\9\9\9\9if currentLength == 0 then return end\
\9\9\9\9term.setBackgroundColour( currentColour )\
\9\9\9\9term.setCursorPos( currentX, currentY )\
\9\9\9\9term.write( (\" \"):rep( currentLength ) )\
\9\9\9end\
\
\9\9\9local buffer = self.buffer\
\9\9\9local colour = self.fillColour or 1\
\9\9\9local width = self.width\
\9\9\9local height = self.height\
\9\9\9local drawn = self.drawn\
\9\9\9-- the blacked out corners. if theres a faster way to do this then feel free to change it\
\9\9\9local corner = { \
\9\9\9\9[1]={ [1]=true, [2]=true, [3]=true, [4]=true, [height - 3]=true, [height - 2]=true, [height - 1]=true, [height]=true },\
\9\9\9\9[2]={ [1]=true, [2]=true, [height - 1]=true, [height]=true },\
\9\9\9\9[3]={ [1]=true, [height]=true },\
\9\9\9\9[4]={ [1]=true, [height]=true },\
\9\9\9\9[width - 3]={ [1]=true, [height]=true },\
\9\9\9\9[width - 2]={ [1]=true, [height]=true },\
\9\9\9\9[width - 1]={ [1]=true, [2]=true, [height - 1]=true, [height]=true },\
\9\9\9\9[width]={ [1]=true, [2]=true, [3]=true, [4]=true, [height - 3]=true, [height - 2]=true, [height - 1]=true, [height]=true },\
\9\9\9}\
\9\9\9local cornerColour = Graphics.colours.BLACK\
\9\9\9for x, v in pairs( corner ) do -- ipairs won't do the [height-3] indexes, for example\
\9\9\9\9for y, v in pairs( v ) do\
\9\9\9\9\9buffer[ ( y - 1 ) * width + x ] = cornerColour\
\9\9\9\9end\
\9\9\9end\
\9\9\9for y = 1, self.height do\
\9\9\9\9currentY = y\
\9\9\9\9currentLength = 0\
\9\9\9\9currentColour = nil\
\9\9\9\9for x = 1, width do\
\9\9\9\9\9local p = ( y - 1 ) * width + x\
\9\9\9\9\9local c = buffer[p] or colour\
\9\9\9\9\9if c ~= drawn[p] then\
\9\9\9\9\9\9drawn[p] = c\
\9\9\9\9\9\9if currentColour == c then\
\9\9\9\9\9\9\9currentLength = currentLength + 1\
\9\9\9\9\9\9else\
\9\9\9\9\9\9\9draw()\
\9\9\9\9\9\9\9currentLength = 1\
\9\9\9\9\9\9\9currentX = x\
\9\9\9\9\9\9\9currentColour = c\
\9\9\9\9\9\9end\
\9\9\9\9\9elseif currentLength ~= 0 then\
\9\9\9\9\9\9draw()\
\9\9\9\9\9\9currentLength = 0\
\9\9\9\9\9\9currentColour = nil\
\9\9\9\9\9else\
\9\9\9\9\9\9currentColour = nil\
\9\9\9\9\9end\
\9\9\9\9end\
\9\9\9\9draw()\
\9\9\9end\
\
        \9-- log( 'Finished render to screen at ' .. os.clock() )\
\
\9\9end\
\9end\
\9return self\
end",["MenuChangedInterfaceEvent.lua"] = "\
class \"MenuChangedInterfaceEvent\" extends \"InterfaceEvent\" {\
\9eventType = Event.MENU_CHANGED;\
\9isSentToChildren = false;\
}",["ProgressBarStripes.lua"] = "\
class \"ProgressBarStripes\" extends \"RoundedRectangle\" {\
\9stripeColour = nil;\
\9animationStep = 0;\
\9stripeWidth = 9;\
}\
\
function ProgressBarStripes:initialise( x, y, width, height, fillColour, outlineColour, stripeColour, radius ) -- @constructor( number x, number y, number width, number height, graphics.fillColour fillColour )\
\9self.super:initialise( x, y, width, height, fillColour, outlineColour, radius, 0, radius, 0 )\
\9self.fillColour = fillColour\
\9self.outlineColour = fillColour\
\9self.stripeColour = stripeColour\
end\
\
function ProgressBarStripes:setAnimationStep( animationStep )\
\9self.hasChanged = true\
\9self.animationStep = math.floor( animationStep )\
end\
\
-- doing this is a little naughty, but it is the easiest and nope way to doing it\
function ProgressBarStripes:drawTo( canvas )\
\9if self.isVisible then\
\9\9local fill = self.fill\
\9\9local outline\
\9\9if self.outlineColour ~= Graphics.colours.TRANSPARENT then\
\9\9\9outline = self:getOutline( fill )\
\9\9end\
\
\9\9local fillColour = self.fillColour\
\9\9local stripeColour = self.stripeColour\
\9\9local outlineColour = self.outlineColour\
\9\9local stripeWidth = self.stripeWidth\
\9\9local animationStep = self.animationStep\
\9\9local _x = self.x - 1\
\9\9local _y = self.y - 1\
\
\9\9local function fmap( x, y, colour )\
\9\9\9if fill[x] and fill[x][y] then\
\9\9\9\9return ( ( ( x + y - animationStep ) / stripeWidth ) % 2 < 1 ) and fillColour or stripeColour\
\9\9\9end\
\9\9end\
\9\9local function ofmap( x, y, colour )\
\9\9\9if outline[x] and outline[x][y] then\
\9\9\9\9return outlineColour\
\9\9\9elseif fill[x] and fill[x][y] then\
\9\9\9\9return ( ( ( x + y - animationStep ) / stripeWidth ) % 2 < 1 ) and fillColour or stripeColour\
\9\9\9end\
\9\9end\
\9\9canvas:map( outline and ofmap or fmap, _x, _y, self.width, self.height )\
\
\9\9if outline then\
\9\9\9for x, row in pairs( outline ) do\
\9\9\9\9for y, _ in pairs( row ) do\
\9\9\9\9\9canvas:setPixel( _x + x, _y + y, outlineColour )\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9\
    return self\
end",["TextFormatter.lua"] = "\
-- written in love2d so I'll port it over at some point\
\
class \"TextFormatter\" {\
\9width = 0;\
\9height = 0;\
\
\9text = \"\";\
\
\9-- this stuff is actually controlled by the Font class\
\9-- might be better to make it a table of fonts and the range of the string\
\9-- but up to you, i'm not really sure how it works\
\
\9-- these are defaults, since they can change\
\9colour = Graphics.colours.GREY;\
\9underline = false;\
\9strikethrough = false;\
\
\9font_name = \"default\";\
\9font_size = 5;\
\9font_mode = \"default\"; -- italic, bold, bolditalic\
\
\9xAlignment = \"left\"; -- alignment.LEFT ?\
\9yAlignment = \"top\"; -- alignment.TOP?\
\
\9changed = false;\
\9stream = nil;\
\9wrappedStream = nil;\
}\
\
function TextFormatter:initialise( text, width, height )\
\9self.text = text\
\9self.width = width\
\9self.height = height\
end\
\
function TextFormatter:set() -- this is called when a variable is set right?:  Yes, arguments are key, value if you want them\
\9self.changed = true\
end\
\
function TextFormatter:tostream()\
\9if not self.changed and self.stream then\
\9\9return self.stream\
\9end\
\9-- convert text into a formatted stream of characters\
end\
\
function TextFormatter:wrapstream( display_width, display_height, stream )\
\9if not self.changed and self.wrappedStream then\
\9\9return self.wrappedStream\
\9end\
\9stream = stream or self:tostream()\
\9-- wordwrap the stream and sort out alignment\
end",["MouseScrollEvent.lua"] = "\
class \"MouseScrollEvent\" extends \"MouseEvent\" {\
\9eventType = Event.MOUSE_SCROLL;\
\9direction = false;\
}\
\
--[[\
\9@constructor\
\9@desc Creates a click mouse event from the arguments\
\9@param [MouseEvent.direction] direction -- the direction of the scroll\
\9@param [number] x -- the x screen coordinate\
\9@param [number] y -- the y screen coordinate\
]]\
function MouseScrollEvent:initialise( direction, x, y )\
\9self.direction = direction\
\9self.x = x\
\9self.y = y\
\9self.globalX = x\
\9self.globalY = y\
end\
",["Button.lua"] = "\
class \"Button\" extends \"View\" {\
\
    height = 16; -- the default height\
    width = 36;\
    text = nil;\
\
    isPressed = false;\
    isFocused = false;\
    isAutosizing = true;\
    font = nil;\
\
    shadowObject = nil;\
    backgroundObject = nil;\
    isFocusDismissable = false;\
    textObject = nil;\
\
    needsAutosize = false;\
\
    leftMargin = 0;\
    rightMargin = 0;\
}\
\
-- action Button.buttonOne function( event )\
-- end\
\
--[[\
    @constructor\
    @desc Creates a button object and connects the event handlers\
]]\
function Button:initialise( ... )\
    self.super:initialise( ... )\
\
    self:event( Event.MOUSE_DOWN, self.onMouseDown )\
    self:event( Event.KEY_DOWN, self.onKeyDown )\
    self:event( Event.KEY_UP, self.onKeyUp )\
    self:event( Event.FOCUS_CHANGED, self.onFocusChanged )\
    self.event:connectGlobal( Event.MOUSE_UP, self.onGlobalMouseUp, EventManager.phase.BEFORE )\
    if self.onMouseUp then self:event( Event.MOUSE_UP, self.onMouseUp ) end\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Button:initialiseCanvas()\
    self.super:initialiseCanvas()\
    local width, height, theme = self.width, self.height, self.theme\
    local shadowObject = self.canvas:insert( RoundedRectangle( 2, 2, width - 1, height - 1, theme.shadowColour ) )\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, width - 1, height - 1, theme.fillColour, theme.outlineColour, cornerRadius ) )\
    local textObject = self.canvas:insert( Text( 1, 5, self.width, 10, self.text ) )\
\
    theme:connect( backgroundObject, \"fillColour\" )\
    theme:connect( backgroundObject, \"outlineColour\" )\
    theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    theme:connect( shadowObject, \"fillColour\", \"shadowColour\" )\
    theme:connect( shadowObject, \"radius\", \"cornerRadius\" )\
    theme:connect( textObject, \"textColour\" )\
    theme:connect( self, \"leftMargin\" )\
    theme:connect( self, \"rightMargin\" )\
\
    self.backgroundObject = backgroundObject\
    self.shadowObject = shadowObject\
    self.textObject = textObject\
\
    if not self.font then\
        self.font = Font.systemFont\
    end\
end\
\
function Button:updateHeight( height )\
    self.backgroundObject.height = height - 1\
    self.shadowObject.height = height - 1\
    self.needsAutosize = true\
end\
\
function Button:updateWidth( width )\
    self.backgroundObject.width = width - 1\
    self.shadowObject.width = width - 1\
    local textObject = self.textObject\
    local leftMargin, rightMargin = self.leftMargin, self.rightMargin\
    textObject.x = self.isPressed and leftMargin + 2 or leftMargin + 1\
    textObject.width = width - leftMargin - rightMargin\
end\
\
function Button:setText( text )\
    self.text = text\
    self.textObject.text = text\
    self.needsAutosize = true\
end\
\
--[[\
    @instance\
    @desc Set the margin on either side of the text\
    @param [number] margin -- the space around the text\
]]\
function Button:setMargin( margin )\
    self.leftMargin = margin\
    self.rightMargin = margin\
end\
\
--[[\
    @instance\
    @desc Set the margin on the left side of the text\
    @param [number] margin -- the space around the left side of the text\
]]\
function Button:setLeftMargin( leftMargin )\
    self.leftMargin = leftMargin\
    self.needsAutosize = true\
end\
\
--[[\
    @instance\
    @desc Set the margin on the left side of the text\
    @param [number] margin -- the space around the left side of the text\
]]\
function Button:setRightMargin( rightMargin )\
    self.rightMargin = rightMargin\
    self.needsAutosize = true\
end\
\
function Button:update( deltaTime )\
    self.super:update( deltaTime )\
    if self.needsAutosize then\
        self:autosize()\
    end\
end\
\
function Button:setFont( font )\
    self.font = font\
    local textObject = self.textObject\
    if textObject then\
        self.textObject.font = font\
        self.needsAutosize = true\
    end\
end\
\
function Button:setNeedsAutosize( needsAutosize )\
    self.needsAutosize = needsAutosize\
end\
\
--[[\
    @instance\
    @desc Automatically resizes the button, regardless of isAutosizing value, to fit the text\
]]\
function Button:autosize()\
    -- TODO: support self.isAutosizing\
    local font, text, textObject = self.font, self.text, self.textObject\
\
    if font and text then\
        local fontWidth = font:getWidth( text )\
        self.width = fontWidth + self.leftMargin + self.rightMargin\
\
        local fontHeight = font.height\
        self.height = fontHeight + 8\
    end\
    self.needsAutosize = false\
end\
\
function Button:updateThemeStyle()\
    self.theme.style = self.isEnabled and ( self.isPressed and \"pressed\" or ( self.isFocused and \"focused\" or \"default\" ) ) or \"disabled\"\
end\
\
function Button:setIsEnabled( isEnabled )\
    self.isEnabled = isEnabled\
    self:updateThemeStyle()\
end\
\
function Button:setIsPressed( isPressed )\
    self.isPressed = isPressed\
    self:updateThemeStyle()\
    local backgroundObject = self.backgroundObject\
    backgroundObject.x = isPressed and 2 or 1\
    backgroundObject.y = isPressed and 2 or 1\
    local textObject = self.textObject\
    -- textObject.x = isPressed and self.leftMargin + 2 or self.leftMargin + 1\
    textObject.y = isPressed and 6 or 5\
end\
\
--[[\
    @instance\
    @desc Sets whether the button is focused. DO NOT CALL/SET THIS DIRECTLY! Use :focus and :unfocus instead.\
    @param [boolean] isFocused -- whether the button is focused\
]]\
function Button:setIsFocused( isFocused )\
    local wasFocused = self.isFocused\
    if wasFocused ~= isFocused then\
        self.isFocused = isFocused\
        self:updateThemeStyle()\
    end\
end\
\
--[[\
    @instance\
    @desc Focuses the button, making it so when enter is pressed it is clicked.\
]]\
function Button:focus()\
    self.application.focus = self\
end\
\
--[[\
    @instance\
    @desc Unfocuses the button, making no other view focused\
]]\
function Button:unfocus()\
    self.application:clearFocus()\
end\
\
--[[\
    @instance\
    @desc Fired when the focused view changes\
    @param [FocusChangedInterfaceEvent] event -- the focus changed event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onFocusChanged( event )\
    self.isFocused = ( self == event.newFocus )\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is released anywhere on screen. Removes the pressed appearance.\
    @param [Event] event -- the mouse up event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onGlobalMouseUp( event )\
    if self.isPressed and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = false\
        if self.isEnabled and self:hitTestEvent( event ) then\
        self.event:handleEvent( ActionInterfaceEvent( self ) )\
            local result = self.event:handleEvent( event )\
            return result == nil and true or result\
        end\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when the mouse is pushed anywhere on screen. Adds the pressed appearance.\
    @param [MouseDownEvent] event -- the mouse down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onMouseDown( event )\
    if self.isEnabled and event.mouseButton == MouseEvent.mouseButtons.LEFT then\
        self.isPressed = true\
    end\
    return true\
end\
\
--[[\
    @instance\
    @desc Fired when a key is pressed down. Presses the button down if it isin focus and it was the enter key.\
    @param [KeyDownEvent] event -- the key down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onKeyDown( event )\
    if self.isEnabled and self.isFocused and event.keyCode == keys.enter then\
        self.isPressed = true\
        return true\
    end\
end\
\
--[[\
    @instance\
    @desc Fired when a key is pressed released. Fires the button action if the button is pressed, in focus and it was the enter key.\
    @param [KeyUpEvent] event -- the key down event\
    @return [boolean] preventPropagation -- prevent anyone else using the event\
]]\
function Button:onKeyUp( event )\
    if self.isEnabled and self.isPressed and self.isFocused and event.keyCode == keys.enter then\
        self.isPressed = false\
    self.event:handleEvent( ActionInterfaceEvent( self ) )\
        return true\
    end\
end",["Menu.lua"] = "\
local MENU_OWNER_LEFT_OFFSET = 5\
local MENU_OWNER_TOP_OFFSET = 9\
local MENU_CONTEXT_OFFSET = 5\
\
class \"Menu\" extends \"Container\" {\
-- TODO: prevent menu going out of the screen\
\9targetX = 1; -- the desired location of the menu. this is the originally set x value, the actual x value can change to prevent overflowing with the screen\
\9targetY = 1;\
\
\9isPressed = false;\
    isEnabled = true;\
    -- isVisible acts as the boolans of whether the menu is open or closed.\
\
\9isSingleShot = false; -- true if the menu should be removed and unlinked when closed (as opposed to simply hiding for reuse only)\
\9hitTestOwner = false; -- true if clicks should first be sent to the owner if they hit test (and it has one)\
\
\9topMargin = 3;\
\9bottomMargin = 5;\
\9shadowRightMargin = 1;\
\9shadowTopMargin = 2;\
\
    cornerRadius = 4;\
\
    shadowObject = nil;\
    backgroundObject = nil;\
\
    width = 40;\
    height = 40;\
\
\9needsLayoutUpdate = false;\9\
}\
\
--[[\
\9@constructor\
\9@desc Initialise a application container instance\
\9@param [table] properties -- the properties for the view\
]]\
function Menu:initialise( ... )\
\9self.super:initialise( ... )\
\
    self.event:connectGlobal( Event.MOUSE_DOWN, self.onGlobalMouseDown, EventManager.phase.BEFORE )\
end\
\
--[[\
    @instance\
    @desc Sets up the canvas and it's graphics objects\
]]\
function Menu:initialiseCanvas()\
\9self.super:initialiseCanvas()\
    local cornerRadius = self.cornerRadius\
    local shadowObject = self.canvas:insert( RoundedRectangle( 1 + self.shadowRightMargin, 1 + self.shadowTopMargin, self.width - 1, self.height - 2 ) )\
    local backgroundObject = self.canvas:insert( RoundedRectangle( 1, 1, self.width - 1, self.height - 2 ) )\
\
    self.theme:connect( backgroundObject, \"fillColour\" )\
    self.theme:connect( backgroundObject, \"outlineColour\" )\
    self.theme:connect( backgroundObject, \"radius\", \"cornerRadius\" )\
    self.theme:connect( shadowObject, \"fillColour\", \"shadowColour\" )\
    self.theme:connect( shadowObject, \"radius\", \"cornerRadius\" )\
\
\9self.shadowObject = shadowObject\
\9self.backgroundObject = backgroundObject\
end\
\
--[[\
\9@instance\
\9@desc Show the menu as a context menu (sets it as a single shot)\
\9@param [View] owner -- the object that invoked the context menu (usually the thing right clicked)\
\9@param [number] x -- the x coordinate of the click (from event.x)\
\9@param [number] y -- the y coordinate of the click (from event.y)\
]]\
function Menu:showContext( owner, x, y )\
\9self.owner = owner\
\9self.isSingleShot = true\
\9self.x = x + owner.x - 1 - MENU_CONTEXT_OFFSET\
\9self.y = y + owner.y - 1 - MENU_CONTEXT_OFFSET\
\9if self.parent then\
        self.parent:removeChild( self )\
    end\
\9owner.parent:insert( self )\
\9self.isVisible = true\
end\
\
function Menu:updateHeight( height )\
    self.backgroundObject.height = height - self.shadowTopMargin\
    self.shadowObject.height = height - self.shadowTopMargin\
end\
\
function Menu:updateWidth( width )\
\9local _width = width - self.shadowRightMargin\
    self.backgroundObject.width = _width\
    self.shadowObject.width = _width\
\
\9local height = self.topMargin\
\9for i, childView in ipairs( self.children ) do\
\9\9childView.width = _width\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Updates the location and size of the menu as well as the location and size of the menu items\
]]\
function Menu:updateLayout()\
\9local width = self.owner and ( self.owner.menuMargin and self.owner.width + 2 * self.owner.menuMargin or 1 ) or 1\
\9local height = self.topMargin\
\9for i, childView in ipairs( self.children ) do\
\9\9width = math.max( width, childView.width )\
\9end\
\9width = width + (1 - width % 2) -- it must be an odd number (for the separators)\
\9-- TODO: target position\
\9\
\9local height = self.topMargin\
\9for i, childView in ipairs( self.children ) do\
\9\9childView.x = 1\
\9\9childView.y = height + 1\
\9\9height = height + childView.height\
\9end\
\9self.width = width + self.shadowRightMargin\
\9self.height = height + self.bottomMargin\
\9self.needsLayoutUpdate = false\
end\
\
function Menu:update( deltaTime )\
    self.super:update( deltaTime )\
    if self.needsLayoutUpdate then\
        self:updateLayout()\
    end\
end\
\
function Menu:setIsVisible( isVisible )\
\9self.super:setIsVisible( isVisible )\
\9if isVisible then\
\9\9self.needsLayoutUpdate = true\
\9end\
end\
\
function Menu:insert( ... )\
\9self.super:insert( ... )\
\9self.needsLayoutUpdate = true\
end\
\
function Menu:removeChild( ... )\
\9self.super:removeChild( ... )\
\9self.needsLayoutUpdate = true\
end\
\
--[[\
\9@instance\
\9@param [Event] -- the mouse down event\
\9@desc Closes the menu when somewhere other than the menu is clicked, otherwise handles the event\
]]\
function Menu:onGlobalMouseDown( event )\
\9if self.isVisible then\
\9\9if self.hitTestOwner and self.owner and self.owner:hitTestEvent( event ) then\
\9\9\9self.owner.event:handleEvent( event )\
\9\9\9return true\
\9\9elseif self:hitTestEvent( event ) then\
\9\9\9self.event:handleEvent( event )\
\9\9\9return true\
\9\9else\
\9\9\9self:close()\
\9\9end\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Sets the open state of the menu\
\9@param [boolean] isOpen -- whether the menu should be open\
]]\
function Menu:setIsOpen( isOpen )\
\9if isOpen then\
\9\9self:open()\
\9else\
\9\9self:close()\
\9end\
end\
\
--[[\
\9@instance\
\9@desc The open state of the menu\
\9@return [boolean] isOpen -- whether the menu is open\
]]\
function Menu:getIsOpen( isOpen )\
\9return self.isVisible\
end\
\
--[[\
\9@instance\
\9@desc Opens the menu if closed, or closes the menu if open\
]]\
function Menu:toggle()\
\9self.isOpen = not self.isOpen\
end\
\
--[[\
\9@instance\
\9@desc Open the menu, hiding it from the screen\
]]\
function Menu:open()\
\9self.isVisible = true\
\9if self.owner then\
\9\9self.owner.event:handleEvent( MenuChangedInterfaceEvent( self ) )\
\9end\
end\
\
--[[\
\9@instance\
\9@desc Closes the menu, hiding it from the screen\
]]\
function Menu:close()\
\9self.isVisible = false\
\9if self.owner then\
\9\9self.owner.event:handleEvent( MenuChangedInterfaceEvent( self ) )\
\9end\
\9if self.isSingleShot then\
\9\9self:dispose()\
\9end\
end\
\
function Menu:dispose()\
\9self.super:dispose()\
\9self.parent:remove( self )\
end",},fonts = {["Auckland.sfont"] = "\0fontType\0bitmap\0\0version\0000.9\0\0name\0Auckland\0\0author\0oeed\0\1\8 \3\0\0\0!\1\"\3\0#\5((($\5$TTH%\5B\12\16`&\0048TT'\1(\2|)\2|*\3@+\5\16\16|\16\16,\2\1\2-\5\16\16\16\16\16.\1\2/\5\2\12\16`0\4||1\2@2\5Bb3\5Dl4\5\24(H5\56\5|L7\58\5ll9\5d|:\1\";\2\1\"<\3\8\20\"=\4\20\20\20\20>\3\"\20\8?\5``@\9~|A\5\14pp\14B\4lC\5|DD\4|E\4F\4G\5|LH\5\16\16\16I\5J\5\12\2\2\2K\5\16 PL\4\2\2\2M\7@ \16 @N\5@ \16O\5||P\4`Q\5|zR\4nS\5dLT\5U\5\2\2\2V\5\28\2\28W\7\2\12\16\12\2X\5P PY\50\0140Z\5[\2\\\5`\16\12\2]\2^\5 @@ _\5\2\2\2\2\2`\2@a\6\4***\28\2b\5\"\"\"\28c\5\28\"\"\"\20d\6\28\"\"\"\2e\5\28***\18f\4\16~g\5\25%%%\30h\4  \30i\1j\4\6\1\1k\4\8\20\"l\1m\7\30  \24  \30n\5>   \30o\5\28\"\"\"\28p\5?$$$\24q\5\24$$$?r\5\30   \16s\4\18**$t\4 \"\"u\6<\2\2\2<\2v\0050\12\2\0120w\5<\2\12\2<x\5\"\20\8\20\"y\0059\5\5\5>z\5\"&*2\"{\3\16l|\1}\3l\16~\6\8\16\16\8\8\16\127\0\6(|D\7\16>BB>\16\2\2\1\4\17~@\3\3\0\3\7\0\2\0\2\0\2\0\3  \3((\3@@\9DT*D\0\4\
\4\5\18j$\3\16(D\7|\7D|(|D\5\"j\"\6@@0HDD\9\16(D\2@\2@\5@\0@\5@\0@\0068|||8\0\5\16\16\16\16\16\8\16\16\16\16\16\16\16\16\4@@\9\0\4\18j\3D(\16\8\28\"\"\"\28**\18\7\8\28>\8\8\8x\3V\5 \14 \5\0\0\0\0\0\1\0048DD\5\18|B\0038(8\54\0304\1\4Z\5\0\0\0\6||\4@ \6\16(D\16(D\4   8\3\16\16\16\6||\5\3\5\"\"\"\"\3\3P\5\0\0@\0\5?\2\2<\2\5`\1\16\2\1\3\3H\8\4``\6D(\16D(\16\6\16 L\4\14\5\16 V\
\6R\4\11\17\3\5\12\18\2\4\5\2T\12\2\5\2\12T\2\5\2LL\2\5BT\2\5\6(\6\5\6\24\24\6\6\14p\5|D\4>j\"\4>j\"\4>jb\4>*\3\18R\3\18^\3RR\3>\5\16|\4^D\4\28b\28\4\28b\28\4\\b\28\4\\b\4\28\"\5D(\16(D\7\2||\5<B\2<\5<\2B<\5<BB<\5<\2<\5 \16N \4DD8\5\127j\4\6\4j*\28\2\6\4*j\28\2\6\4jj\28\2\6\4jj\2\6\4*\28\2\6\4**\28\2\9\4***\28***\18\5\28#\"\"\20\5\28j*\18\5\28*j\18\5\28jj\18\5\28*\18\2^\2^\3@@\3>\5\28\"\28\5^P\14\5\28b\"\28\5\28\"b\28\5\28bb\28\5\\b\28\5\28\"\28\5\16\16T\16\16\5\28&*2\28\6<B\2<\2\6<\2B<\2\6<BB<\2\6<\2<\2\0059\5E>\4~$$\24\0059\5>\0\0",["_Auckland.sfont"] = "\1 -- heading start\
F Auckland -- the font family name. note, if there are variations (bold, italic, etc) this is always the same. for example, in all the Helvetica variations (Regular, Light, etc) this is still \"Helvetica\"\
T 1234 -- traits of the font stored using bit API. bit 1 is isBold, 2 is isItalic, 3 isUnderlined (anything else?)\
\2 -- character definition\
O 5 2,1,4,3.5,3,1,3,2.25,1,4,3.5,3,1,3,2.25,1,4,3.5,3,1,3,2.25,1,4,3.5,3,1,3,2.25 2,1,4,3.5,3,1,3,2.25,1,4,3.5,3,1,3,2.25,1,4,3.5,3,1,3,2.25,1,4,3.5,3,1,3,2.25\
-- the line is split by a space character\
-- first letter of each line is the character it represents\
-- all sizes and quantities are for a standard 10 pixel high font. (i.e. the maximum y value for a point is 10 and minimum is 1)\
-- the second number is the character width using the same 10 pixel scale\
-- the line then consists of path definintions\
-- each number in a path is split by a comma\
-- the first and second numbers are the starting point of the path (x and y respectively)\
-- the remainder is a bezier path ",["Ben.sfont"] = "VECTOR SYNTAX:\
\9fuck knows\
BITMAP SYNTAX:\
\9sbyte: [1-255]\
\9bitmapdata: [0-255]{ ( height <= 8 ? 1 : 2 ) * width }\
\
\9\9([0][sbyte]+[0][sbyte]+[0])* // metadata\
\9\9[1] // start of font\
\9\9[0-255] // the height of the font\
\9\9([0-255][0-255][bitmapdata])+ // the character, the width, and the bitmap data associated",},}
_G.__resourceTables = _G.__resourceTables or {}
_G.__resourceTables[#_G.__resourceTables + 1] = files
local loaded = {}
local classes = files["classes"]
local loadClass

function _G.__loadClassNamed( name )
	loadClass( name .. ".lua" )
end

loadClass = function( name, content )
	if not loaded[name] then
		content = content or classes[name]
		local f, err = loadstring( content, name )
		if err then error( err, 0 ) end
		local ok, err = pcall( f )
		if err then error( err, 0 ) end
		loaded[name] = true
	end
end

if classes then
	local loadFirst = files["loadfirst.scfg"]
	if loadFirst then
		for name in loadFirst:gmatch( "[^\n]+" ) do
			loadClass( name )
		end
	end

	for name, contents in pairs( classes ) do
		loadClass( name, content )
	end
end

_G.__loadClassNamed = nil

